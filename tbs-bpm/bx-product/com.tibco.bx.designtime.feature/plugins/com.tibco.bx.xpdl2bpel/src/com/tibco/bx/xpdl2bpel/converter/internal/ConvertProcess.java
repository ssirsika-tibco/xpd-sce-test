package com.tibco.bx.xpdl2bpel.converter.internal;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.Properties;

import org.eclipse.bpel.model.Assign;
import org.eclipse.bpel.model.BPELFactory;
import org.eclipse.bpel.model.EventHandler;
import org.eclipse.bpel.model.Sources;
import org.eclipse.bpel.model.Targets;
import org.eclipse.bpel.model.Variable;
import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.Path;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.util.FeatureMap;
import org.w3c.dom.CDATASection;
import org.w3c.dom.Element;

import com.tibco.bx.bpelExtension.extensions.AuditAttribute;
import com.tibco.bx.bpelExtension.extensions.AuditAttributeType;
import com.tibco.bx.bpelExtension.extensions.AuditDescriptor;
import com.tibco.bx.bpelExtension.extensions.ExtensionsFactory;
import com.tibco.bx.bpelExtension.extensions.StartEventType;
import com.tibco.bx.bpelExtension.extensions.Task;
import com.tibco.bx.bpelExtension.extensions.VariableDescriptor;
import com.tibco.bx.bpelExtension.extensions.VariableDescriptorType;
import com.tibco.bx.xpdl2bpel.Messages;
import com.tibco.bx.xpdl2bpel.N2PEConstants;
import com.tibco.bx.xpdl2bpel.Tracing;
import com.tibco.bx.xpdl2bpel.analyzer.Analyzer;
import com.tibco.bx.xpdl2bpel.analyzer.AnalyzerLink;
import com.tibco.bx.xpdl2bpel.analyzer.AnalyzerParentTask;
import com.tibco.bx.xpdl2bpel.analyzer.AnalyzerProcess;
import com.tibco.bx.xpdl2bpel.analyzer.AnalyzerTask;
import com.tibco.bx.xpdl2bpel.converter.ConversionException;
import com.tibco.bx.xpdl2bpel.util.BPELUtils;
import com.tibco.bx.xpdl2bpel.util.ConverterUtil;
import com.tibco.bx.xpdl2bpel.util.WSDLUtils;
import com.tibco.bx.xpdl2bpel.util.XPDLUtils;
import com.tibco.xpd.analyst.resources.xpdl2.utils.ProcessInterfaceUtil;
import com.tibco.xpd.resources.util.ProjectUtil;
import com.tibco.xpd.resources.util.WorkingCopyUtil;
import com.tibco.xpd.xpdExtension.Audit;
import com.tibco.xpd.xpdExtension.AuditEvent;
import com.tibco.xpd.xpdExtension.AuditEventType;
import com.tibco.xpd.xpdExtension.DataWorkItemAttributeMapping;
import com.tibco.xpd.xpdExtension.ProcessDataWorkItemAttributeMappings;
import com.tibco.xpd.xpdExtension.XpdModelType;
import com.tibco.xpd.xpdl2.Activity;
import com.tibco.xpd.xpdl2.Condition;
import com.tibco.xpd.xpdl2.ConditionType;
import com.tibco.xpd.xpdl2.DataField;
import com.tibco.xpd.xpdl2.Description;
import com.tibco.xpd.xpdl2.Expression;
import com.tibco.xpd.xpdl2.ExtendedAttribute;
import com.tibco.xpd.xpdl2.Process;
import com.tibco.xpd.xpdl2.ProcessHeader;
import com.tibco.xpd.xpdl2.StartEvent;
import com.tibco.xpd.xpdl2.Transition;
import com.tibco.xpd.xpdl2.TriggerType;
import com.tibco.xpd.xpdl2.resolvers.DataReferenceContext;

public class ConvertProcess {

    private static String PROCESS_HEADER = "*** Generated by TIBCO Business Studio."; //$NON-NLS-1$

    private static final String SEQUENCE_FLOW_EXTENSION = "sequenceFlow"; //$NON-NLS-1$
    private static final String UNCONTROLLED_MERGE_EXTENSION = "uncontrolledMerge"; //$NON-NLS-1$
    private static final String MAX_TRUE_EXTENSION = "maxTrue"; //$NON-NLS-1$
    private static final String WAIT_FOR_EXTENSION = "waitFor"; //$NON-NLS-1$
    private static final String LOOPBACK_EXTENSION = "loopback";   //todo remove this one //$NON-NLS-1$
    private static final String IMPLEMENTS = "implements"; //$NON-NLS-1$
    private static final String EXPLICIT_COMPENSATION_EXTENSION = "explicitCompensation"; //$NON-NLS-1$
    private static final String INITIAL_PRIORITY = "initialPriority"; //$NON-NLS-1$
    private static final String SERVICE_PROCESS = "serviceProcess"; //$NON-NLS-1$

    /** Convert the Analyzer process into a BPEL process and return it.
     * @param context converter context
     * @param analyzerProcess The Analyzer Process to convert to BPEL.
     * @return The converted BPEL process. 
     * @throws ConversionException */
    public static org.eclipse.bpel.model.Process convertProcessToBPELProcess (
    		ConverterContext context, AnalyzerProcess analyzerProcess) throws ConversionException {
    	if (Tracing.ENABLED) Tracing.trace("convertProcessToBPELProcess: " + ConverterUtil.toString(analyzerProcess)); //$NON-NLS-1$

        Process process = analyzerProcess.getXpdlProcess();
        org.eclipse.bpel.model.Process bpelProcess = BPELFactory.eINSTANCE.createProcess();
        analyzerProcess.setBpelReference(bpelProcess);
        bpelProcess.setSuppressJoinFailure(true);

        context.beginElement(process);
    	try {
            BPELUtils.addN2PEExtension(bpelProcess);

            bpelProcess.setExitOnStandardFault(false);

        	String implementedInterfaceId = ProcessInterfaceUtil.getImplementedProcessInterfaceId(process);
            if (implementedInterfaceId!=null) {
            	BPELUtils.addExtensionAttribute(bpelProcess, IMPLEMENTS, implementedInterfaceId);
            }

            ConvertDataField.convertFormalParametersToBPEL(context, process);
            ConvertDataField.convertDataFieldsToBPEL(context, process);
            context.syncXpdlId(bpelProcess, process);
            bpelProcess.setName(process.getName());
            ProcessHeader header = process.getProcessHeader();
            String description = (header!=null && header.getDescription()!=null && header.getDescription().getValue()!=null
            		&& header.getDescription().getValue().length()>0)
            		? header.getDescription().getValue() : "" + PROCESS_HEADER; //$NON-NLS-1$
            BPELUtils.setDocumentation(bpelProcess, description);
            String initialPriority = (header!=null && header.getPriority()!=null) ? header.getPriority().getValue() : null; //$NON-NLS-1$
            if (initialPriority!=null && initialPriority.length()>0) {
            	BPELUtils.addExtensionAttribute(bpelProcess, INITIAL_PRIORITY, initialPriority);
            }
            XpdModelType type = XPDLUtils.getXpdModelType(process);
            if (XpdModelType.SERVICE_PROCESS.equals(type)) {
            	BPELUtils.addExtensionAttribute(bpelProcess, SERVICE_PROCESS, "yes");
            }
            
            /*
             * Sid ACE-1598 Add the dataFieldDescriptor information (this is a
             * per-process JS file and class that is generated for runtime
             * initialisation of the process data in a "data" object - and also
             * does JSON to JS data coercion and initialisation of arrays etc.
             */
            addDataFieldDescriptorInfo(bpelProcess, process);
            
            org.eclipse.bpel.model.Flow bpelFlow = convertFlowToBpel(context, analyzerProcess);
            if (context.isUseExplicitCompensation()) {
            	BPELUtils.addExtensionAttribute(bpelProcess, EXPLICIT_COMPENSATION_EXTENSION, "yes"); //$NON-NLS-1$
            }
            bpelProcess.setActivity(bpelFlow);
            
    		EventHandler eventHandler = bpelProcess.getEventHandlers();
    		if (eventHandler==null) {
    			eventHandler = BPELFactory.eINSTANCE.createEventHandler();
    			bpelProcess.setEventHandlers(eventHandler);
    		}
            new ConvertEventHandlers().convertEventHandlers(context, analyzerProcess.getEventHandlers(), eventHandler);
            
            AuditDescriptor auditDescriptor = convertProcessDataAudits(context, analyzerProcess);
            if (auditDescriptor != null) {
        		bpelProcess.addExtensibilityElement(auditDescriptor);
            }

            bpelProcess.setPartnerLinks(context.getPartnerLinks());
    		bpelProcess.setVariables(context.getVariables(process));
    		bpelProcess.setCorrelationSets(ConvertCorrelations.createCorrelationSets(context));
            // update wsdl files
    		Collection<URI> wsdlLocations = context.getWsdlLocations();
    		for (URI loc: wsdlLocations) {
    			ConvertCorrelations.addPropertiesToWSDL(context, loc);
				try {
					WSDLUtils.saveWSDLFile(loc, context.getWsdlDefinition(loc));
				} catch (Exception e) {
					context.logError(Messages.getString("XPDL2WSDL.cannotSaveWSDL") + loc, e); //$NON-NLS-1$
				}
    		}
    		
        	XPDLUtils.configureSystemErrorAction(bpelProcess, process);
        	
        	XPDLUtils.configureCalendarReference(bpelProcess, process, ProcessInterfaceUtil.getAllProcessRelevantData(process));
        	
        	configureTaskVariables(context, bpelProcess);
    		
    	} finally {
    		context.endElement();
    	}

        return bpelProcess;
    }
    
    /**
     * * Sid ACE-1598 Add the dataFieldDescriptor information (this is a
     * per-process JS file and class that is generated for runtime
     * initialisation of the process data in a "data" object - and also does
     * JSON to JS data coercion and initialisation of arrays etc.
     * 
     * <li>tibex:dataFieldDescriptorScript="/process-js/<process-package-name>/<process-name>/<process-name>.js"</li> 
     * <li>tibex:dataFieldDescriptorClass="<application-id>.<process-package-name>.<process-name>"</li>
     * 
     * @param bpelProcess
     * @param process
     */
    private static void addDataFieldDescriptorInfo(
            org.eclipse.bpel.model.Process bpelProcess, Process process) {
        /*
         * Build the path name.
         * 
         * /process-js/<process-package-name>/<process-name>/<process-name>.js
         */
        String pkgName = process.getPackage().getName();
        String processName = process.getName();

        IPath descriptorPath =
                new Path(IPath.SEPARATOR + "process-js").append(pkgName) //$NON-NLS-1$ //$NON-NLS-2$
                        .append(processName).append(processName + "." + "js"); //$NON-NLS-1$ //$NON-NLS-2$

        BPELUtils.addExtensionAttribute(bpelProcess,
                "dataFieldDescriptorScript", //$NON-NLS-1$
                descriptorPath.toString());

        /*
         * Build the class name.
         * 
         * <application-id>.<process-package-name>.<process-name>
         */
        String projectId = ProjectUtil
                .getProjectId(WorkingCopyUtil.getProjectFor(process));

        String className = projectId + "." + pkgName + "." + processName; //$NON-NLS-1$ //$NON-NLS-2$

        BPELUtils.addExtensionAttribute(bpelProcess,
                "dataFieldDescriptorClass", //$NON-NLS-1$
                className);
    }

    public static org.eclipse.bpel.model.Activity convertTaskToBpel(ConverterContext context, AnalyzerTask analyzerTask)
            throws ConversionException {
        org.eclipse.bpel.model.Activity result = null;
        boolean processLevel = false;
        int scriptType = 5;
        if (analyzerTask.isCreateInstance()) {
        	scriptType = 2;
        }
        if (analyzerTask.getParent() instanceof AnalyzerProcess) processLevel = true;

        Activity xpdlActivity = analyzerTask.getXpdlActivity();

        //perform task specific conversion
		switch (analyzerTask.getTaskType()) {
            case StartEvent:
            	if (xpdlActivity!=null) {
            		result = ConvertEvent.convertEventToBPELActivity(context, xpdlActivity, processLevel);
            	} else {
                    com.tibco.bx.bpelExtension.extensions.ReceiveEvent receiveEvent = ExtensionsFactory.eINSTANCE.createReceiveEvent();
                    com.tibco.bx.bpelExtension.extensions.StartEvent startEvent = ExtensionsFactory.eINSTANCE.createStartEvent();
                    startEvent.setEventType(StartEventType.DEFAULT_LITERAL); //$NON-NLS-1$                    
                    receiveEvent.setEventSource(startEvent);
                    receiveEvent.setCreateInstance(true);
                    BPELUtils.setType(receiveEvent, N2PEConstants.START_EVENT_TYPE);
                    
                    result = receiveEvent;
                    result.setName(context.genUniqueActivityName("startEvent")); //$NON-NLS-1$
            	}
            	scriptType = 2;
            	break;
            case IntermediateEvent:
                result = ConvertEvent.convertEventToBPELActivity(context, xpdlActivity, processLevel);
                scriptType = 4;
                break;
            case EndEvent:
            	if (xpdlActivity!=null) {
            		result = ConvertEvent.convertEventToBPELActivity(context, xpdlActivity, processLevel);
            	} else {
            		result = BPELFactory.eINSTANCE.createEmpty();
                    result.setName(context.genUniqueActivityName("endEvent")); //$NON-NLS-1$
            	}
            	scriptType = 1;
                break;
            case Flow: 
            case EmbeddedSubProcess:
            case EventSubProcess:
            	result = convertFlowToBpel(context, (AnalyzerParentTask)analyzerTask);
            	org.eclipse.bpel.model.Activity flow = result;
    			List<AnalyzerTask> eventHandlerTasks = ((AnalyzerParentTask)analyzerTask).getEventHandlers();
    			if (eventHandlerTasks != null && !eventHandlerTasks.isEmpty()) {
    				String scopeName = context.generateActivityName("scope", xpdlActivity.getName(), xpdlActivity.getId());
    				result = BPELUtils.wrapInScope(result, scopeName);
            		EventHandler bpelEventHandler = BPELFactory.eINSTANCE.createEventHandler();
        			((org.eclipse.bpel.model.Scope)result).setEventHandlers(bpelEventHandler);
            		new ConvertEventHandlers().convertEventHandlers(context, eventHandlerTasks, bpelEventHandler);
    			}

    			if (analyzerTask.getTaskType() == Analyzer.TaskType.EmbeddedSubProcess) {
                	BPELUtils.setType(result, N2PEConstants.EMBEDDED_SUB_PROCESS_TYPE);
                	if (analyzerTask.getXpdlActivity() != null) {
                		BPELUtils.setLabel(result, analyzerTask.getXpdlActivity());
                		context.syncXpdlId(result, analyzerTask.getXpdlActivity());
                		flow.setName(context.generateActivityName("flow", xpdlActivity.getName(), xpdlActivity.getId()));
                		result.setName(xpdlActivity.getName());
                	}
            	}
                break;
            case Gateway:
                result = BPELFactory.eINSTANCE.createEmpty();
                String name = xpdlActivity.getName();
                if (name==null || name.length()<1) {
                	// name = context.makeUniqueActivityName("gateway"); //$NON-NLS-1$
                	name = context.generateActivityName("gateway", xpdlActivity.getId(), null); //$NON-NLS-1$
                }
                result.setName(name);
            	String gatewayType = N2PEConstants.GATEWAY_TYPE;
            	switch (analyzerTask.getGatewayType()) {
                	case AND:
                		gatewayType = N2PEConstants.GATEWAY_AND_TYPE;
                		break;
                	case COMPLEX:
                		gatewayType = N2PEConstants.GATEWAY_COMPLEX_TYPE;
                		break;
                   	case OR:
                   		gatewayType = N2PEConstants.GATEWAY_OR_TYPE;
                   		break;
                	case XOR:
                		gatewayType = N2PEConstants.GATEWAY_XOR_TYPE;
                		break;
                	case XOR_EVENT:
                		gatewayType = N2PEConstants.GATEWAY_XOR_EVENT_TYPE;
                }
                BPELUtils.setType(result, gatewayType);
                BPELUtils.setLabel(result, xpdlActivity);
                scriptType = 3;
                break;
            case Pick:
                result = ConvertPick.convertPick(context, (AnalyzerParentTask)analyzerTask);
                break;
            case IndependedSubProcess:
            	result = convertTask(context, xpdlActivity, processLevel, analyzerTask.isCreateInstance(), N2PEConstants.REUSEABLE_SUB_PROCESS_TYPE);
            	break;
            case ManaualTask:
            	result = convertTask(context, xpdlActivity, processLevel, analyzerTask.isCreateInstance(), N2PEConstants.MANUAL_TASK_TYPE); 
                break;
            case ReceiveTask:
            	result = convertTask(context, xpdlActivity, processLevel, analyzerTask.isCreateInstance(), N2PEConstants.RECEIVE_TASK_TYPE); 
                break;
            case ScriptTask:
              	result = convertTask(context, xpdlActivity, processLevel, analyzerTask.isCreateInstance(), N2PEConstants.SCRIPT_TASK_TYPE); 
                break;
            case SendTask:
               	result = convertTask(context, xpdlActivity, processLevel, analyzerTask.isCreateInstance(), N2PEConstants.SEND_TASK_TYPE); 
                break;
            case ServiceTask:
            	result = convertTask(context, xpdlActivity, processLevel, analyzerTask.isCreateInstance(), N2PEConstants.SERVICE_TASK_TYPE); 
                break;
            case UserTask:
                result = convertTask(context, xpdlActivity, processLevel, analyzerTask.isCreateInstance(), N2PEConstants.USER_TASK_TYPE); 
                for (AnalyzerTask boundaryTask:analyzerTask.getSignalUpdateBoundaryTasks()) {
                    com.tibco.xpd.xpdl2.Activity eventAct = boundaryTask.getXpdlActivity();
                    ConvertBoundaryEvents.makeOnSignalUpdate(context, eventAct, result, analyzerTask);
                }    		
                break;
            case Task:
                result = BPELFactory.eINSTANCE.createEmpty();
                BPELUtils.setType(result, N2PEConstants.TASK_TYPE);
                BPELUtils.setLabel(result, xpdlActivity);
                break;
            case OTHER:
            	if (xpdlActivity!=null && xpdlActivity.getEvent() instanceof StartEvent) {
            		StartEvent startEvent = (StartEvent)xpdlActivity.getEvent();
            		if (startEvent.getTriggerResultSignal() !=null &&     XPDLUtils.isGlobalSignalType(startEvent.getTriggerResultSignal())) {
            			Assign assign = BPELFactory.eINSTANCE.createAssign();
            			BPELUtils.addExtensionAttribute(assign, "useGlobalSignalMapping", "yes"); //$NON-NLS-1$  //$NON-NLS-2$
            			result = assign;
            		}
        		}
            default:
        }

        if (result==null) {
            result = BPELFactory.eINSTANCE.createEmpty();
            if (xpdlActivity != null && xpdlActivity.getName() != null) {
                result.setName(xpdlActivity.getName());
            } else {
                result.setName(context.makeUniqueActivityName("empty")); //$NON-NLS-1$
            }
        }
        
    	//see if the activity has local data fields. If it does, we need to create a <scope> wrapper
    	//to which the local variables will be added. Note that if the activity is in a loop, we will 
    	//defer the local data field handling to ConvertLoops.convertLoop(, where the <scope> wrapper will be created anyway.
    	if (xpdlActivity!=null && !XPDLUtils.isLoopActivity(xpdlActivity)) {
    		EList<DataField> dataFields = xpdlActivity.getDataFields();
    		if (dataFields != null && !dataFields.isEmpty()) { //has local data
                org.eclipse.bpel.model.Scope scope;
                if (result instanceof org.eclipse.bpel.model.Scope) {
                	scope = (org.eclipse.bpel.model.Scope) result;
                } else {
                	if (result.getName() == null || result.getName().length() == 0) {
                    	result.setName(xpdlActivity.getName());
                	}
                	
                	scope = BPELFactory.eINSTANCE.createScope();
//                    scope.setName("scope" + xpdlActivity.getId()); //$NON-NLS-1$
                    scope.setName(context.generateActivityName("scope", xpdlActivity.getName(), xpdlActivity.getId()));
                	//set the xpdl id at the scope wrapper
                    context.syncXpdlId(scope, xpdlActivity);
                	scope.setActivity(result);
                	result = scope;
                }
                if (scope.getVariables() == null) {
                	scope.setVariables(org.eclipse.bpel.model.BPELFactory.eINSTANCE.createVariables());
                }
    			for (DataField dataField : dataFields) {
        			Variable variable = ConvertDataField.convertDataFieldToBPELVariable(xpdlActivity.getProcess(), dataField);
        			scope.getVariables().getChildren().add(variable);
				}
    		}
    	}

    	// set name
    	if (result.getName() == null || result.getName().length() == 0) {
            context.setActivityName(xpdlActivity, result, "un-named"); //$NON-NLS-1$
    	}
        analyzerTask.setBpelReference(result);


        if (xpdlActivity!=null) {
            // set description
            Description description = xpdlActivity.getDescription();
            if (description!=null) {
            	BPELUtils.setDocumentation(result, description.getValue());
            }
            // set extended attributes
            if (result instanceof org.eclipse.bpel.model.ExtensionActivity) {
                convertExtendedAttributes(context, xpdlActivity, result);
            }
            if (analyzerTask.getTaskType() != Analyzer.TaskType.EventSubProcess) {
            	context.syncXpdlId(result, xpdlActivity);
            }
            
            // set task scripts
            convertTaskScripts(context, result, xpdlActivity, scriptType);
            // set migrationAllowed attribute
            if (analyzerTask.isMigrationAllowed()) {
            	BPELUtils.addExtensionAttribute(result, N2PEConstants.MIGRATION_ALLOWED_TAG, "yes");
            }
        }

        // make temporary place holder for each boundary task
        if (analyzerTask.getParent()!=null) {
        	org.eclipse.bpel.model.Flow bpelFlow = ( org.eclipse.bpel.model.Flow)analyzerTask.getParent().getBpelReference();
        	List<org.eclipse.bpel.model.Activity> flowActivities =
        		(List<org.eclipse.bpel.model.Activity>) bpelFlow.getActivities();
        	for (AnalyzerTask task: analyzerTask.getBoundaryTasks()) {
        		org.eclipse.bpel.model.Empty placeholder = BPELFactory.eINSTANCE.createEmpty();
        		flowActivities.add(placeholder);
        		task.setBpelReference(placeholder);
        		if (task.getAssociation()!=null) {
        			convertTaskToBpel(context, task.getAssociation());
        		}
        	}
        }

        // set uncontrolled merge
        if (analyzerTask.isUncontrolledMerge()) {
            BPELUtils.addExtensionAttribute(result, UNCONTROLLED_MERGE_EXTENSION, "yes"); //$NON-NLS-1$
        }


        return result;
    }

    private static org.eclipse.bpel.model.Activity convertTask(ConverterContext context, Activity xpdlActivity, boolean processLevel, boolean createInstance, String type) throws ConversionException {
    	org.eclipse.bpel.model.Activity result = ConvertTask.convertTaskActivityToBPELActivity(context, xpdlActivity, processLevel, createInstance);
        if (result != null) {
        	BPELUtils.setType(result, type);
            BPELUtils.setLabel(result, xpdlActivity);
            context.syncXpdlId(result, xpdlActivity);
        }
    	return result;
    }

    /**
     * convert task scripts
     * @param context 
     * @param bpel
     * @param xpdlActivity
     * @param scriptType  1=Initiated only, 2=Completed only,
     * 					  3= Initiated and Completed
     * 					  4=Initiated, Completed and Cancel
     * 					  5=All
     */
    public static void convertTaskScripts(ConverterContext context, org.eclipse.bpel.model.ExtensibleElement bpel, Activity xpdlActivity, int scriptType) {
        Audit audit = null;
        FeatureMap featureMap = xpdlActivity.getOtherElements();
		FeatureMap.ValueListIterator iter = featureMap.valueListIterator();
		while (iter.hasNext()) {
			EObject obj = (EObject) iter.next();
			if (obj instanceof Audit) {
				audit = (Audit) obj;
				break;
			}
		}
		if (audit!=null) {
			EList<AuditEvent> auditEvents = audit.getAuditEvent();
			Iterator<AuditEvent> eventIter = auditEvents.iterator();
			while (eventIter.hasNext()) {
				AuditEvent auditEvent = eventIter.next();
				Expression expr = auditEvent.getInformation();
				String exprText = expr != null ? expr.getText() : "";
				if("DataMapper".equals(expr.getScriptGrammar())){
					exprText = XPDLUtils.getDataMapperScript(expr);
				}
				if (exprText!=null && exprText.length()>0) {
					Element ele = null;
					AuditEventType type = auditEvent.getType();
					if (type.equals(AuditEventType.COMPLETED_LITERAL) && scriptType!=1) {
						ele = BPELUtils.makeExtensionElement(bpel, "completedScript");
						XPDLUtils.findReferencedDataInScript(context, xpdlActivity, xpdlActivity.getName(), DataReferenceContext.CONTEXT_COMPLETE_SCRIPT);
					} else if (type.equals(AuditEventType.INITIATED_LITERAL) && scriptType!=2) {
						ele = BPELUtils.makeExtensionElement(bpel, "initiatedScript");
						XPDLUtils.findReferencedDataInScript(context, xpdlActivity, xpdlActivity.getName(), DataReferenceContext.CONTEXT_INITIATE_SCRIPT);
					} else if (type.equals(AuditEventType.CANCELLED_LITERAL) && scriptType>3) {
						ele = BPELUtils.makeExtensionElement(bpel, "cancelScript");
						XPDLUtils.findReferencedDataInScript(context, xpdlActivity, xpdlActivity.getName(), DataReferenceContext.CONTEXT_CANCEL_SCRIPT);
					} else if (type.equals(AuditEventType.DEADLINE_EXPIRED_LITERAL) && scriptType>4) {
						ele = BPELUtils.makeExtensionElement(bpel, "timeoutScript");
						XPDLUtils.findReferencedDataInScript(context, xpdlActivity, xpdlActivity.getName(), DataReferenceContext.CONTEXT_TIMEOUT_SCRIPT);
					}
					if (ele != null) {
						CDATASection cdata = ele.getOwnerDocument().createCDATASection(exprText);
						ele.appendChild(cdata);
						ele.setAttribute("expressionLanguage", N2PEConstants.JSCRIPT_LANGUAGE);
					}
				}
			}
		}
    }
    
    public static org.eclipse.bpel.model.Expression getCompletedTaskScript(Activity xpdlActivity) {
        Audit audit = null;
		org.eclipse.bpel.model.Expression result = null;
        FeatureMap featureMap = xpdlActivity.getOtherElements();
		FeatureMap.ValueListIterator iter = featureMap.valueListIterator();
		while (iter.hasNext()) {
			EObject obj = (EObject) iter.next();
			if (obj instanceof Audit) {
				audit = (Audit) obj;
				break;
			}
		}
		if (audit!=null) {
			EList<AuditEvent> auditEvents = audit.getAuditEvent();
			Iterator<AuditEvent> eventIter = auditEvents.iterator();
			while (eventIter.hasNext()) {
				AuditEvent auditEvent = eventIter.next();
				Expression expr = auditEvent.getInformation();
				if (expr!=null && expr.getText()!=null && expr.getText().length()>0) {
					AuditEventType type = auditEvent.getType();
					if (type.equals(AuditEventType.COMPLETED_LITERAL)) {
						result = BPELFactory.eINSTANCE.createExpression();
						result.setExpressionLanguage(N2PEConstants.JSCRIPT_LANGUAGE);
						result.setBody(expr.getText());
						break;
					}
				}
			}
		}
		return result;
    }
    
    private static void convertExtendedAttributes(ConverterContext context, Activity xpdlActivity, org.eclipse.bpel.model.Activity bpelActivity) {
        List<ExtendedAttribute> list = xpdlActivity.getExtendedAttributes();
        if (list!=null && list.size()>0) {
            Properties properties = new Properties();
            for (ExtendedAttribute attr: list) {
                if (attr.getValue()!=null) {
                    properties.put(attr.getName(), attr.getValue());
                }
            }
            //turn properties into extended attribute on bpel activity
            OutputStream os = new ByteArrayOutputStream();
            try {
            	properties.store(os, null);
            } catch (IOException e) {
            	context.logError("Failed to convert the extended attributes.", e);
            }
            String data = os.toString();
            data = data.substring(data.indexOf('\n')+1);  // eliminate time stamp so each run is the same
            BPELUtils.addExtensionAttribute(bpelActivity, "extendedAttributes", data); //$NON-NLS-1$
        }
    }

    static org.eclipse.bpel.model.Flow convertFlowToBpel(ConverterContext context, AnalyzerParentTask analyzerFlow)
        throws ConversionException {

        org.eclipse.bpel.model.Flow bpelFlow = BPELFactory.eINSTANCE.createFlow();
        analyzerFlow.setBpelReference(bpelFlow);
        if (analyzerFlow.getXpdlActivity() != null) {
    		bpelFlow.setName(analyzerFlow.getXpdlActivity().getName());
        }
		if (bpelFlow.getName() == null || bpelFlow.getName().length() == 0) {
		    
            /*
             * XPD-8210 For bpel:flow's that have been added by the flow
             * analyzer (e.g. NOT ones derived from xpdl Embedded / Event
             * Sub-processes then we a method to generate name in the form
             * _BX_flow_<UUID>
             * 
             * For more info as to why see XPD-8210. But basically it is because
             * when changes are made to process it can cause groups of
             * activities added to v2 of process to be encapsulated in a
             * bpel:flow whose name was used for a different set of activities
             * in v1 of process (which then move to a new _BX_flow). This could
             * happen becase uinique naming was based on numeric suffix.
             * 
             * The issue is that if in v2 the process is migrated just before a
             * bpel:flow that originally (by name) appeared upstream in the
             * flow, then IT is considered to have been process already and the
             * flow halts unexpectedly.
             * 
             * Using UUID naming for the bpel:flow's means that they will never
             * be confused with existing flows.
             * 
             * CHANGE REQUESTED BY MARK / STEVE(C) ON PE RUNTIME TEAM
             */
	        bpelFlow.setName(context.genUniqueActivityNameWithUUID("flow")); //$NON-NLS-1$
		}

        // do child activities
        List<org.eclipse.bpel.model.Activity> flowActivities =
			(List<org.eclipse.bpel.model.Activity>) bpelFlow.getActivities();
        for (AnalyzerTask task: analyzerFlow.getChildren()) {
            if (task.getXpdlActivity()!=null) {
                context.beginElement(task.getXpdlActivity());
            }
            try {
                org.eclipse.bpel.model.Activity bpelActivity = convertTaskToBpel(context, task);
                if (task.equals(analyzerFlow.getStartEvent())) {
                	// update task type for event sub-proc start event
                	switch (((StartEvent)task.getXpdlActivity().getEvent()).getTrigger().getValue()) {
        				case TriggerType.NONE:
        					BPELUtils.setType(bpelActivity, N2PEConstants.START_EVENT_TYPE);
        					break;
        				case TriggerType.SIGNAL:
        					BPELUtils.setType(bpelActivity, N2PEConstants.SIGNAL_START_EVENT_TYPE);
        					break;
        				case TriggerType.MESSAGE:
        					BPELUtils.setType(bpelActivity, N2PEConstants.MESSAGE_START_EVENT_TYPE);
                	}
                }
                
                flowActivities.add(bpelActivity);
            } finally {
                if (task.getXpdlActivity()!=null) {
                    context.endElement();
                }
            }
        }

        // do links
        AnalyzerLink[] links = analyzerFlow.getLinks().toArray(new AnalyzerLink[0]);
        Arrays.sort(links);
        convertAnalyzerLinksToBPELLinks(context, links, bpelFlow);

        // do looping tasks
        for (AnalyzerTask task: analyzerFlow.getChildren()) {
            if (task.getXpdlActivity()!=null && XPDLUtils.isLoopActivity(task.getXpdlActivity())) {
                org.eclipse.bpel.model.Activity activityWrapper =
                ConvertLoops.convertLoop(context, bpelFlow, task, null);
                if (activityWrapper!=null) {
                    task.setBpelReference(activityWrapper);
                }
            }
        }

        // do boundary tasks
        for (AnalyzerTask task: analyzerFlow.getChildren()) {
            if (task.isBoundaryHost()) {
                ConvertBoundaryEvents.convertBoundaryEvents(context, bpelFlow, task);
            }
        }

        //Note, links crossing in or out only come from generated structures like flow or pick.
        //Looping or boundary tasks come from actual structures so are mutually exclusive from crossing links
        for (AnalyzerTask task: analyzerFlow.getChildren()) {
        	if (task instanceof AnalyzerParentTask) {
        		if (((AnalyzerParentTask)task).getInCrossingLinks().size()>0) {
        			ConvertControlFlow.doFanIn(context, (AnalyzerParentTask)task);
        		}
        	}
        }

        // out crossing links
        for (AnalyzerTask task: analyzerFlow.getChildren()) {
            if (task instanceof AnalyzerParentTask) {
                if (((AnalyzerParentTask)task).getOutCrossingLinks().size()>0) {
                    ConvertControlFlow.doFanOut(context, analyzerFlow, (AnalyzerParentTask)task);
                }
            }
        }

        // set cycle
        if (analyzerFlow.isContainsCycle()) {
            BPELUtils.addExtensionAttribute(bpelFlow, SEQUENCE_FLOW_EXTENSION, "yes"); //$NON-NLS-1$
        }

        // misc - maxTrue, waitFor
        for (AnalyzerTask task: analyzerFlow.getChildren()) {
            if (task.getMaxTrue()!=null) {
                Sources sources = ((org.eclipse.bpel.model.Activity)task.getBpelReference()).getSources();
                BPELUtils.addExtensionAttribute(sources, MAX_TRUE_EXTENSION, task.getMaxTrue().toString());
            }
            if (task.getWaitFor()!=null) {
                Targets targets = ((org.eclipse.bpel.model.Activity)task.getBpelReference()).getTargets();
                BPELUtils.addExtensionAttribute(targets, WAIT_FOR_EXTENSION, task.getWaitFor().toString());
            }
        }

        return bpelFlow;
    }
    
    public static void convertAnalyzerLinksToBPELLinks (ConverterContext context, final AnalyzerLink[] links,
                                                        final org.eclipse.bpel.model.Flow bpelFlow) {
        // This code assumes the transitions being traversed only refer to Activities that
        // have already been traversed, this is supposed to be a safe assumption
        if (links != null && links.length > 0) {
            org.eclipse.bpel.model.Links  bpelLinks = BPELFactory.eINSTANCE.createLinks ();
            bpelFlow.setLinks (bpelLinks);
            List<org.eclipse.bpel.model.Link>  flowLinks = bpelFlow.getLinks().getChildren();
            for (AnalyzerLink link: links) {
                Transition transition = link.getXpdlTransition();
                context.beginElement(transition);
                try {
                    org.eclipse.bpel.model.Link bpelLink = BPELFactory.eINSTANCE.createLink();
                    Condition condition = null;
                    if (transition!=null) condition = transition.getCondition();
                    org.eclipse.bpel.model.Condition bpelCondition = convertConditionToBPELCondition(context, condition, bpelLink);
                    org.eclipse.bpel.model.Activity sourceActivity = (org.eclipse.bpel.model.Activity)link.getRealSourceTask().getBpelReference();
                    if(sourceActivity==null && Tracing.ENABLED) {
                    	Tracing.trace("no bpel reference for: "+link.getRealSourceTask().getProcess().getName()+"."+link.getRealSourceTask().getName());
                    }
                    org.eclipse.bpel.model.Source source = BPELFactory.eINSTANCE.createSource();
                    source.setTransitionCondition(bpelCondition);
                    source.setActivity(sourceActivity);
                    bpelLink.getSources().add(source);
                    org.eclipse.bpel.model.Activity targetActivity = (org.eclipse.bpel.model.Activity)link.getRealTargetTask().getBpelReference();
                    org.eclipse.bpel.model.Target target = BPELFactory.eINSTANCE.createTarget();
                    target.setActivity(targetActivity);
                    bpelLink.getTargets().add(target);
                    String uniqueLinkName = context.getUniqueLinkName(transition, sourceActivity, targetActivity);
                    if (Tracing.ENABLED) Tracing.trace("Link named: " + uniqueLinkName + " from: " + sourceActivity.getName() + " to: " //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
                            + targetActivity.getName());
                    bpelLink.setName(uniqueLinkName);
                    if (transition != null) context.syncXpdlId(bpelLink, transition);
                    flowLinks.add(bpelLink);
                    link.setBpelReference(bpelLink);
                    if (link.isLoopBack()) {
                        BPELUtils.addExtensionAttribute(bpelLink, LOOPBACK_EXTENSION, "yes"); //$NON-NLS-1$
                    }
                } finally {
                    context.endElement();
                }
            }
        }
    }
    
    private static void configureTaskVariables(ConverterContext context, org.eclipse.bpel.model.Process bpelProcess) {
    	VariableDescriptor variableDescriptor = ExtensionsFactory.eINSTANCE.createVariableDescriptor();
    	variableDescriptor.setType(VariableDescriptorType.PERSISTENT_BATCHING_LITERAL);
    	Task[] taskDescriptors = context.getTaskDescriptors();
    	for (Task task : taskDescriptors) {
    		variableDescriptor.getTasks().add(task);
		}
    	
		bpelProcess.addExtensibilityElement(variableDescriptor);
	}

	private static AuditDescriptor convertProcessDataAudits(ConverterContext context, AnalyzerProcess analyzerProcess) {
		ProcessDataWorkItemAttributeMappings auditMappings = XPDLUtils.getProcessDataWorkItemAttributeMappings(analyzerProcess.getXpdlProcess());
		if (auditMappings != null && auditMappings.getDataWorkItemAttributeMapping() != null) {
			AuditDescriptor auditDescriptor = ExtensionsFactory.eINSTANCE.createAuditDescriptor();
			List<DataWorkItemAttributeMapping> attributeMappings = auditMappings.getDataWorkItemAttributeMapping();
			for (DataWorkItemAttributeMapping mapping : attributeMappings) {
				AuditAttribute auditAttribute = ExtensionsFactory.eINSTANCE.createAuditAttribute();
				auditAttribute.setName(mapping.getAttribute());
				auditAttribute.setValue(mapping.getProcessData());
				auditAttribute.setType(auditAttribute.getValue().indexOf(".") < 0 ?
						AuditAttributeType.SIMPLE_LITERAL : AuditAttributeType.COMPLEX_LITERAL);

				auditDescriptor.getAttributes().add(auditAttribute);
			}
			return auditDescriptor;
		}
		
		return null;
	}

    /**
	 * Convert the Condition passed from XPDL to BPEL.
	 * 
	 * @param context
	 *            converter context
	 * @param condition
	 *            The XPDL Condition to convert.
	 * @param bpelLink
	 *            The parent link of the condition.
	 * @return The Condition converted to BPEL. <element name="Condition">
	 *         <complexType mixed="true"> <choice minOccurs="0"> <element
	 *         ref="deprecated:Xpression" minOccurs="0"/> <element
	 *         name="Expression" type="xpdl:ExpressionType" minOccurs="0"/>
	 *         </choice> <attribute name="Type"> <simpleType> <restriction
	 *         base="NMTOKEN"> <enumeration values="CONDITION", "OTHERWISE",
	 *         "EXCEPTION", "DEFAULTEXCEPTION"/> </restriction> </simpleType>
	 *         </attribute> <anyAttribute namespace="##other"
	 *         processContents="lax"/> </complexType> </element>
	 */
    public static org.eclipse.bpel.model.Condition convertConditionToBPELCondition (
    		ConverterContext context, final Condition condition, final org.eclipse.bpel.model.Link bpelLink) {
        if (condition == null) {
        	return null;
        }
        ConditionType  conditionType = condition.getType();
        if (conditionType == null) {
        	return null;
        }
        
        org.eclipse.bpel.model.Condition bpelCondition = BPELFactory.eINSTANCE.createCondition();
        bpelCondition.setExpressionLanguage (N2PEConstants.JSCRIPT_LANGUAGE);
        switch (conditionType.getValue ()) {
            case ConditionType.CONDITION:
                // Normal condition
                com.tibco.xpd.xpdl2.Expression  expression = condition.getExpression();
                if (expression != null) {
                    String  expressionText = expression.getText();
                    if (expressionText != null) {
                        bpelCondition.setBody (expressionText);
                   }
                }
            break;
            case ConditionType.OTHERWISE:
                // Default condition
                bpelCondition.setBody ("##otherwise##"); //$NON-NLS-1$
                break;
            case ConditionType.EXCEPTION:
                // TODO Don't know what to put here yet
            break;
            case ConditionType.DEFAULTEXCEPTION:
                // TODO Don't know what to put here yet
            break;
        }

        return bpelCondition;
    }

    static class GatewayToInfo {
    	String gatewayId;
    	String toId;
    }
}
