import wsdlSchema;
import xmlSchema;
import type;
import uml;
import com::tibco::xpd::bom::xsdtransform::exports::template;

extension org::openarchitectureware::xsd::lib::qname;
extension org::openarchitectureware::xsd::lib::map;
extension com::tibco::xpd::bom::xsdtransform::exports::template::IncrementalBom2Xsd reexport;
	
// create a DocumentRoot for every sub-Epackage
Object incrementalTransformToWsdl(ExportTransformationData data, Class tempClass, String bomFullPathUri) :
	let wsdlSchemaRoot = new WsdlSchemaDocumentRoot :
	let tDefin = new TDefinitions :
	let ttypes = new TTypes :
	let typesList = {} :
	let docRootList = {incrementalTransform(data, tempClass, bomFullPathUri)} :
	let namespace = getNamespace(tempClass.getModel(), true) :
	wsdlSchemaRoot.xMLNSPrefixMap.put("xsd","http://www.w3.org/2001/XMLSchema") ->	
	docRootList.typeSelect(XmlSchemaDocumentRoot).collect(e | addXSDSchemaToWsdlExt(data, ttypes, e.schema, wsdlSchemaRoot)) ->		
	typesList.add(ttypes) ->	
	tDefin.setTypes(typesList) ->		
	addPortTypesFromClass(data, tempClass, tDefin, docRootList) ->
	tDefin.setTargetNamespace(namespace) ->
	wsdlSchemaRoot.setDefinitions(tDefin) ->
	docRootList.add(wsdlSchemaRoot) ->
	wsdlSchemaRoot;
	

	
addXSDSchemaToWsdlExt(ExportTransformationData data, TTypes ttypes, SchemaType schemaType, WsdlSchemaDocumentRoot wsdlSchemaRoot) :
	let prefixForNamespace = data.getPrefixForNamespace(schemaType.targetNamespace) :
	traceMe("namey = "+schemaType.targetNamespace) ->
	traceMe("tsPrefix = "+prefixForNamespace) ->
	traceMe("schem = "+schemaType) ->
	ttypes.any.add(xmlSchema::XmlSchemaDocumentRoot::schema, schemaType) -> // this is now used for oaw 4.3.1
	ttypes.any.addFrom(schemaType.eContainer) -> // this is now used for oaw 4.3.1
	traceMe("ttype = "+ttypes.any) ->
	//addSchema(ttypes.any, schemaType) ->    // this is needed for oaw 4.3.0 or lower
	wsdlSchemaRoot.xMLNSPrefixMap.put(prefixForNamespace, schemaType.targetNamespace);

addPortTypesFromClass(ExportTransformationData data, Class tempClass, TDefinitions tDefin, List[XmlSchemaDocumentRoot] docRootList) :	
	tDefin.setPortType({}) ->
	tDefin.setMessage({}) ->
	(tempClass.ownedOperation != null && tempClass.ownedOperation.size > 0) ? (
		createIncrementalPortType(data, tempClass, tDefin, docRootList)
	) : null;	

createIncrementalPortType(ExportTransformationData data, Class classWithOperations, TDefinitions tDefin, List[XmlSchemaDocumentRoot] docRootList) :
	let portType = new TPortType :
	let operations = {} :	
	portType.setName(classWithOperations.name) ->
	portType.setOperation(operations) ->
	classWithOperations.ownedOperation.collect(e | createIncrementalOperation(data, classWithOperations, e, portType, tDefin, docRootList)) ->	
	tDefin.portType.add(portType);
	
createIncrementalOperation(ExportTransformationData data, Class classWithOperations, Operation ownedOperation, TPortType portType, TDefinitions tDefin, List[XmlSchemaDocumentRoot] docRootList) :
	let operation = new TOperation :	
	let prefixForModel = data.getPrefixForNamespace(classWithOperations.getModel().name) :
	let mainDocRoot = docRootList.select(e| e.xMLNSPrefixMap.get(prefixForModel) != null).first() :		
	operation.setName(ownedOperation.name) ->	
	ownedOperation.ownedParameter.select(e|e.direction != null && e.type != null && e.direction == ParameterDirectionKind::return).collect(e|createIncrementalOutputMessagePart(data, classWithOperations,e, operation, tDefin, docRootList)) ->
	ownedOperation.ownedParameter.select(e|e.direction == null || e.direction != ParameterDirectionKind::return).size > 0 ? (
		let tParam = new TParam :
		let message = new TMessage :
		message.setPart({}) ->
		tParam.setName(operation.name+"_inputMessage") ->
		message.setName(classWithOperations.name+"_"+operation.name+"_inputMessage") ->
		ownedOperation.ownedParameter.select(e|e.direction == null || e.direction != ParameterDirectionKind::return).collect(e|createIncrementalInputParts(data, e, operation, tDefin, docRootList, message)) ->
		tDefin.message.add(message) ->
		tParam.setMessage(createQName(mainDocRoot.xMLNSPrefixMap.get(prefixForModel), message.name, prefixForModel)) ->	
		operation.setInput(tParam)
	) : (
		null
	) ->	
	
	portType.operation.add(operation);	
	
createIncrementalOutputMessagePart(ExportTransformationData data, Class classWithOperations, Parameter parameter, TOperation operation, TDefinitions tDefin, List[XmlSchemaDocumentRoot] docRootList) :	
	let paramPackage = parameter.type.package :
	let paramTypeName = (
		isAnonymousTopLevelElement(parameter.type) ? (
			let name = getAnonymousTopLevelElementName(parameter.type) :
			name
		) : parameter.type.name
	) :
	let xsdType = getQName(parameter.type, null) :	
	let prefixForModel = data.getPrefixForNamespace(paramPackage.getModel().name) :	
	let mainDocRoot = docRootList.select(e| e.xMLNSPrefixMap.get(prefixForModel) != null).first() :
	let isElementType = mainDocRoot.eAllContents.typeSelect(TopLevelElement).select(e|e.name==paramTypeName).first() : 	
	let tParam = new TParam :
	let message = new TMessage :
	let tPart = new TPart :
	traceMe("param type="+ paramTypeName) ->	
	traceMe("is element="+ isElementType) ->	
	tParam.setName(operation.name+"_outputMessage") ->
	message.setName(classWithOperations.name+"_"+operation.name+"_outputMessage") ->
	tPart.setName(operation.name+"_outputPart") ->
	xsdType != null ? (
		tPart.setType(xsdType)
	) : (
		isElementType == null ? (			
			tPart.setType(createQName(mainDocRoot.xMLNSPrefixMap.get(prefixForModel),paramTypeName,prefixForModel))
		) : (
			tPart.setElement(createQName(mainDocRoot.xMLNSPrefixMap.get(prefixForModel),paramTypeName,prefixForModel))
		)
	) ->
	message.setPart({tPart}) ->
	tDefin.message.add(message) ->
	tParam.setMessage(createQName(mainDocRoot.xMLNSPrefixMap.get(prefixForModel),message.name,prefixForModel)) ->	
	operation.setOutput(tParam);
	
createIncrementalInputParts(ExportTransformationData data, Parameter parameter, TOperation operation, TDefinitions tDefin, List[XmlSchemaDocumentRoot] docRootList, TMessage message) :
	let paramPackage = parameter.type.package :
	let paramTypeName = (
		isAnonymousTopLevelElement(parameter.type) ? (
			let name = getAnonymousTopLevelElementName(parameter.type) :
			name
		) : parameter.type.name
	) :
	let xsdType = getQName(parameter.type, null) :	
	let prefixForModel = data.getPrefixForNamespace(paramPackage.getModel().name) :	
	let mainDocRoot = docRootList.select(e| e.xMLNSPrefixMap.get(prefixForModel) != null).first() :
	let isElementType = mainDocRoot.eAllContents.typeSelect(TopLevelElement).select(e|e.name==paramTypeName).first() : 		
	let tPart = new TPart :
	tPart.setName(parameter.name) ->
	xsdType != null ? (
		tPart.setType(xsdType)
	) : (
		isElementType == null ? (
			tPart.setType(createQName(mainDocRoot.xMLNSPrefixMap.get(prefixForModel),paramTypeName,prefixForModel))
		) : (
			tPart.setElement(createQName(mainDocRoot.xMLNSPrefixMap.get(prefixForModel),paramTypeName,prefixForModel))
		)
	) ->
	message.part.add(tPart);

