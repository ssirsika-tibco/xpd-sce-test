import xmlSchema;
import type;
import uml;
import xsd;
import com::tibco::xpd::bom::xsdtransform::exports::template;

extension org::openarchitectureware::xsd::lib::qname;
extension org::openarchitectureware::xsd::lib::map;
extension com::tibco::xpd::bom::xsdtransform::exports::template::Extensions reexport;
extension com::tibco::xpd::bom::xsdtransform::exports::template::HelperFuncs reexport;
extension com::tibco::xpd::bom::xsdtransform::exports::template::RestrictionFuncs reexport;
	
parseAssociations(ExportTransformationData data, Collection[xmlSchema::SchemaType] schemaTypeList, Collection[Association] associations, Collection[Package] packageList) :	
	associations.typeSelect(Association).collect(e | parseAssociation(data, schemaTypeList, e, packageList));
	
parseAssociation(ExportTransformationData data, Collection[xmlSchema::SchemaType] schemaTypeList, Association association, Collection[Package] packageList) :
	let associations = association.getAssociations() :
	
	association.ownedEnd.size == 0 ? parseBiDirectionalComposition(data, schemaTypeList, association, packageList) : null ->
	association.ownedEnd.size > 0 ? ( traceMe("parseComposition") -> parseComposition(data, schemaTypeList, association, packageList)) : null ->
	associations != null && associations.size > 0 ? parseAssociations(data, schemaTypeList, associations, packageList) : null;
	
parseBiDirectionalComposition(ExportTransformationData data, Collection[xmlSchema::SchemaType] schemaTypeList, Association association, Collection[Package] packageList) :
	let property1 = association.member.first() :
	let property2 = association.member.last() :
	
	let lowerBound1 = getPropertyMinOccurs(property1) :
	let upperBound1 = getPropertyMaxOccurs(property1) :
	
	let lowerBound2 = getPropertyMinOccurs(property2) :
	let upperBound2 = getPropertyMaxOccurs(property2) :	
	
	parseComposition(data, schemaTypeList, association, packageList, property1, property2)
	
	// this is the original call before supporting XPD-1916.	
	//parseComposition(data, schemaTypeList, packageList, lowerBound2, upperBound2, property1, property2) ->
    //parseComposition(data, schemaTypeList, packageList, lowerBound1, upperBound1, property2, property1)
	
	//let localElement = parseComposition(data, schemaTypeList, association, packageList, property1, property2) :
	//let containedElementSchema = schemaTypeList.typeSelect(SchemaType).select(e|e.targetNamespace == getNamespace(((Class)property2.eContainer).package,true)).first() :
	//let containedComplexType = getComplexOrGroup(containedElementSchema, property2.type.name) : 	
	//let explicitGroup = getElementSequence(data, containedComplexType, property2) :				 
	//let alreadyExists = explicitGroup.element.select(e | e.name == property1.name).first() :
	//alreadyExists == null ? (
		//let tmpLocalElement = new LocalElement : 	
		//let xrefId = getXRefID(property1) :				
		//xrefId == null || xrefId.trim().length == 0 ? null : (
			//tmpLocalElement.setId(xrefId)		
		//) ->
		//tmpLocalElement.setName(property1.name) ->
		//tmpLocalElement.setType(createQName("http://www.w3.org/2001/XMLSchema","anyURI")) ->
		//tmpLocalElement.setMinOccurs(lowerBound1) ->
		//tmpLocalElement.setMaxOccurs(upperBound1) ->												
		//addSortElementToExplicitGroup(tmpLocalElement, explicitGroup, (Class)property2.eContainer) ->
		// XPD-2569: adding ecore:name 
		//addFeatureMapEntry(tmpLocalElement.anyAttribute, property1.name, "name") ->
		//addFeatureMapEntry(tmpLocalElement.anyAttribute, property1.type.name, "reference") ->
		//(
			//let appliedModelStereotype = property2.class.getModel().getAppliedStereotypes().select(e|e.name == "XsdBasedModel").first() :
			//appliedModelStereotype == null ? (			
				//addFeatureMapEntry(tmpLocalElement.anyAttribute, property2.name, "opposite")
			//) : null
		//)
	//) : null ->													
	//(
		//	let appliedModelStereotype = property1.class.getModel().getAppliedStereotypes().select(e|e.name == "XsdBasedModel").first() :
			//appliedModelStereotype == null ? (		
				//addFeatureMapEntry(localElement.anyAttribute, property1.name, "opposite")
			//) : null
	//) ->	
	//association.memberEnd.last().aggregation == AggregationKind::none || association.memberEnd.last().aggregation == AggregationKind::shared ? (
		//localElement.setType(createQName("http://www.w3.org/2001/XMLSchema","anyURI")) ->
		// XPD-2569: adding ecore:name 
		//addFeatureMapEntry(localElement.anyAttribute, property2.name, "name") ->
		//addFeatureMapEntry(localElement.anyAttribute, property2.type.name, "reference") 
	//) : null;
	;

// use this for seprate associations in bidirectional compositions
parseComposition(ExportTransformationData data, Collection[xmlSchema::SchemaType] schemaTypeList, Collection[Package] packageList, Integer lowerBound, Integer upperBound, Property containerElement, Property containedElement) :	
	traceMe("-> parseComposition 1") ->
	(
		let containerElementSchema = schemaTypeList.typeSelect(SchemaType).select(e|e.targetNamespace == getNamespace(((Class)containerElement.eContainer).package,true)).first() :	
		let containedElementSchema = schemaTypeList.typeSelect(SchemaType).select(e|e.targetNamespace == getNamespace(((Class)containedElement.eContainer).package,true)).first() :
		let containerComplexType = (
			let temp1 = getComplexOrGroup(containerElementSchema, containerElement.type.name) : 
			let temp2 = getComplexOrGroup(containedElementSchema, containerElement.type.name) :		
			temp1 == null ? temp2 : temp1		
		) :		
		let containedComplexType = (
			let temp1 = getComplexOrGroup(containedElementSchema, containedElement.type.name) : 
			let temp2 = getComplexOrGroup(containerElementSchema, containedElement.type.name) :		 
			temp1 == null ? temp2 : temp1		
		) :	
		let estimatedContainerComplexType = getComplexOrGroup(containerElementSchema, containerElement.type.name) :
		estimatedContainerComplexType == containerComplexType ? (
			parseMe(data, schemaTypeList, packageList, lowerBound, upperBound, containerElement, containedElement, containerElementSchema, containedElementSchema, containerComplexType, containedComplexType )	
		) : (
			parseMe(data, schemaTypeList, packageList, lowerBound, upperBound, containerElement, containedElement, containedElementSchema, containerElementSchema, containerComplexType, containedComplexType )
		)
	);			
		
	
parseMe(ExportTransformationData data, Collection[xmlSchema::SchemaType] schemaTypeList, Collection[Package] packageList, Integer lowerBound, Integer upperBound, Property containerElement, Property containedElement, SchemaType containerElementSchema, SchemaType containedElementSchema, Object containerComplexType, Object containedComplexType ) :
	let localElement = new LocalElement :	
	containerElementSchema != containedElementSchema ? addImportType(data, containerElementSchema, containedElementSchema, ((Class)containerElement.eContainer).package, getPrefix(data, ((Class)containerElement.eContainer).package), containerElementSchema.targetNamespace) : null ->
	parseComplexWithAnonymous(containerElement, containedElement, containerElementSchema, containerComplexType, containedComplexType) ? null : 
	(		
		let appliedRestrictionStereotype = ((Class)containedElement.eContainer).getAppliedStereotypes().select(e|e.name == "XsdBasedClass").first() :
		let isAnonymousContained = getStereotypeValue(((Class)containedElement.eContainer), appliedRestrictionStereotype, "xsdIsAnonType") :
		isAnonymousContained == true ? (
			let topLevelElement = schemaTypeList.eAllContents.typeSelect(xmlSchema::TopLevelElement).select(e|e.name == containedElement.type.name).first() :									
			topLevelElement != null ? (						
				let localComplexType = new LocalComplexType :
				// XPD-2569: adding ecore:name 
				addFeatureMapEntry(localComplexType.anyAttribute, containedElement.name, "name") ->
				localElement.setComplexType(localComplexType) ->
				localElement.setType(createQName(containedElementSchema.targetNamespace,containedElement.type.name)) ->
				setElementStereotypedValues(data, containedElement, localElement)
			) : (										
				localElement.setType(createQName(containedElementSchema.targetNamespace,containedElement.type.name)) ->
				setElementStereotypedValues(data, containedElement, localElement)
			)
		)
		:(
			let xrefId = getXRefID(containedElement) :
			let topLevelElement = schemaTypeList.eAllContents.typeSelect(xmlSchema::TopLevelElement).select(e|e.name == containedElement.type.name).first() :
			localElement.setMinOccurs(lowerBound) ->
			upperBound.toString() == "-1" ? localElement.setMaxOccurs(AllNniMember1::unbounded) : localElement.setMaxOccurs(upperBound) ->						
			localElement.setName(containedElement.name) ->
			// XPD-2569: adding ecore:name 
			addFeatureMapEntry(localElement.anyAttribute, containedElement.name, "name")  ->	
			data.addOriginalName(localElement, getOriginalName(containedElement)) ->	
			xrefId == null || xrefId.trim().length == 0 ? null : (
				localElement.setId(xrefId)
				//localElement.setAnnotation(createAnnotationType("xsdID="+xrefId))
			) ->									
			topLevelElement != null ? (						
				let localComplexType = new LocalComplexType :
				// XPD-2569: adding ecore:name 
				addFeatureMapEntry(localComplexType.anyAttribute, containedElement.name, "name") ->
				localElement.setComplexType(localComplexType) ->
				localElement.setType(createQName(containedElementSchema.targetNamespace,containedElement.type.name)) ->
				setElementStereotypedValues(data, containedElement, localElement)
			) :	(									
				localElement.setType(createQName(containedElementSchema.targetNamespace,containedElement.type.name)) ->
				setElementStereotypedValues(data, containedElement, localElement)
			)
		) ->		
		containerComplexType != null ? (
			(containerComplexType.metaType.name == "xmlSchema::ComplexType" || containerComplexType.metaType.name == "xmlSchema::LocalComplexType" || containerComplexType.metaType.name == "xmlSchema::TopLevelComplexType") ? (
				let explicitGroup = getElementSequence(data, containerComplexType, containedElement) :				 
				let alreadyExists = explicitGroup.element.select(e | e.name == localElement.name).first() :					
				alreadyExists == null ? (													
					addSortElementToExplicitGroup(localElement, explicitGroup, (Class)containedElement.eContainer)
				) : null								
			) : (
				containerComplexType.metaType.name == "xmlSchema::NamedGroup" ? (
					let explicitGroup = getElementSequence(data, containerComplexType, containedElement) :				 
					let alreadyExists = explicitGroup.element.select(e | e.name == localElement.name).first() :					
					alreadyExists == null ? (													
						addSortElementToExplicitGroup(localElement, explicitGroup, (Class)containedElement.eContainer)
					) : null
					//let sequence = createGroupSequence(containerComplexType) :
					//sequence.element.add(localElement) ->					
				) : (
					containerComplexType.metaType.name == "xmlSchema::NamedAttributeGroup" ? (
						null
					) : null				
				)
			)		
		) : (
			let containerComplexType = getComplexWithAnonymousContainer(containerElementSchema, (Class)containedElement.eContainer, packageList) :
			
			let explicitGroup = getElementSequence(data, containerComplexType, containedElement) :   // might be containerElement???				 
			let alreadyExists = explicitGroup.element.select(e | e.name == localElement.name).first() :					
			alreadyExists == null ? (													
				addSortElementToExplicitGroup(localElement, explicitGroup, (Class)containedElement.eContainer)
			) : null					
		)			
	);	
	
Element parseComposition(ExportTransformationData data, Collection[xmlSchema::SchemaType] schemaTypeList, Association association, Collection[Package] packageList, Property containerElement, Property containedElement) :
	traceMe("-> parseComposition 2") ->
	(
		let lowerBound = getPropertyMinOccurs(containedElement) :
		let upperBound = getPropertyMaxOccurs(containedElement) :
		
		// could be this schema (selecting the schema that has a namespace matching the namespace of the container element's package)
		let containerElementSchema = schemaTypeList.typeSelect(xmlSchema::SchemaType).select(e|e.targetNamespace == getNamespace(((Class)containerElement.eContainer).package,true)).first() :	
		
		// could be this schema or other schema (selecting the schema that has a namespace matching the namespace from the contained element's package)
		let containedElementSchema = schemaTypeList.typeSelect(xmlSchema::SchemaType).select(e|e.targetNamespace == getNamespace(((Class)containedElement.eContainer).package,true)).first() :
		
		// the complex type representing/acting as a container
		let containerAnonyComplexType = containerElementSchema.complexType.select(e|e.name == containerElement.type.name).first() :
		
		// the complex type representing/acting as contained element
		//TODO: should we get this with the target namespace prefix??
		let containedAnonyComplexType = containedElementSchema.complexType.select(e|e.name == containedElement.type.name).first() :
		
		// could be in this schema (searching for the class that this container element points to, for the matching namespace of the containerElement class. ) 
		//TODO: this will be always null because containerElement.class will be null. should we not try and get something different here??
		let containerComplexType = containerElementSchema.complexType.select(e|e.name == containerElement.type.name && containerElementSchema.targetNamespace ==  getNamespace(containerElement.class.package,true) ).first() :
		
		// could be in this schema or other schema (searching for the class that this contained element points to, for the matching namespace of the containedElement class. this class may be present in this (contained element) schema or other schema. 
		let containedComplexType = containedElementSchema.complexType.select(e|e.name == containedElement.type.name && containedElementSchema.targetNamespace ==  getNamespace(containedElement.class.package,true)).first() :
		
		let localElement = new LocalElement :	
		
		let propertySchema = (
			schemaTypeList.size == 1 ? schemaTypeList.first() : getPropertySchema(schemaTypeList, containedElement)
		) :				
		
		let propertyTypeSchema = (
			schemaTypeList.size == 1 ? schemaTypeList.first() : getPropertyTypeSchema(schemaTypeList, containedElement)
		) :
		
		let appliedModelStereotype = containedElement.type.package.getAppliedStereotypes().select(e|e.name == "XsdBasedModel").first() :
		
		let stereotypeTargetNamespace = (
			let tmpNamespace = getStereotypeValue(containedElement.type.package, appliedModelStereotype, "xsdTargetNamespace") :
			tmpNamespace != null ? tmpNamespace : getNamespace(containedElement.type.package,true) 
		):
		
		traceMe("\ncontainerElement.type = " + containerElement.type + " containerElement.type.name =  " + containerElement.type.name)->
		traceMe("\ncontainedElement.type = " + containedElement.type + " containedElement.type.name =  " + containedElement.type.name)->		
		traceMe("\ncontainerElement.class.name = " + containerElement.class.name + " containerElement.class =  " + containerElement.class)->
		traceMe("\ncontainedElement.class.name = " + containedElement.class.name + " containedElement.class =  " + containedElement.class)->
		
		traceMe("\ncontainerComplexType containerElement.name = " + containerElement.name) -> 
		traceMe("containerComplexType containedElement.name  = " + containedElement.name) -> 
		traceMe("parseComposition containerComplexType.name = " + containerComplexType.name + " containerComplexType = " + containerComplexType) -> 
		traceMe("parseComposition containedComplexType.name = " + containedComplexType.name + " containedComplexType = " + containedComplexType ) ->
		traceMe("containerAnonyComplexType.name = " + containerAnonyComplexType.name + " containerAnonyComplexType = " + containerAnonyComplexType)->
		traceMe("containedAnonyComplexType.name = " + containedAnonyComplexType.name + " containedAnonyComplexType = " + containedAnonyComplexType)->
			
		// add the imports for prefixes and namespaces
		containerComplexType == null ? ( // couldnt find container so look in another schema
			// get the container from another (contained) schema
			let containerComplexType = containedElementSchema.complexType.select(e|e.name == containerElement.type.name).first() :
			// find the contained complex type in container schema
			let containedComplexType = containerElementSchema.complexType.select(e|e.name == containedElement.type.name).first() :
			let tmpPackage = containedElement.type.package : // packageList.eAllContents.typeSelect(Class).select(e|e == containedElement.type).first().eContainer :
			let containerElementSchema = schemaTypeList.typeSelect(xmlSchema::SchemaType).select(e|e.targetNamespace == getNamespace(tmpPackage,true)).first() :

			containerElementSchema != containedElementSchema ? (
				addImportType(data, containerElementSchema, containedElementSchema, tmpPackage, getPrefix(data, tmpPackage), containerElementSchema.targetNamespace) ->
				// check property type to see if its type needs an import for another schema
				(propertyTypeSchema != propertySchema) && (propertySchema != null) && (propertyTypeSchema != null) && propertyTypeSchema != containerElementSchema ? addImportType(data, propertyTypeSchema, propertySchema, containedElement.type.package, getPrefix(data, containedElement.type.package), propertyTypeSchema.targetNamespace) : null 
			) : null
		) : (
			containerElementSchema != containedElementSchema ? addImportType(data, containerElementSchema, containedElementSchema, ((Class)containerElement.eContainer).package, getPrefix(data, ((Class)containerElement.eContainer).package), containerElementSchema.targetNamespace) : null ->
			// check property type to see if its type needs an import for another schema
			(propertyTypeSchema != propertySchema) && (propertySchema != null) && (propertyTypeSchema != null) && propertyTypeSchema != containerElementSchema ? addImportType(data, propertyTypeSchema, propertySchema, containedElement.type.package, getPrefix(data, containedElement.type.package), propertyTypeSchema.targetNamespace) : null
		) ->
				
		parseComplexWithAnonymous(containerElement, containedElement, containerElementSchema, containerAnonyComplexType, containedAnonyComplexType) ? null : 
		(
			let appliedRestrictionStereotype = ((Class)containedElement.eContainer).getAppliedStereotypes().select(e|e.name == "XsdBasedClass").first() :
			let isAnonymousContained = getStereotypeValue(((Class)containedElement.eContainer), appliedRestrictionStereotype, "xsdIsAnonType") :		
				
			let xrefId = getXRefID(containedElement) :						
			localElement.setMinOccurs(lowerBound) ->
			//localElement.setMaxOccurs(upperBound) ->		
			//localElement.setMaxOccurs(upperBound.toString() == "-1" ? AllNNIMember1::unbounded : upperBound) ->
			upperBound.toString() == "-1" ? localElement.setMaxOccurs(AllNniMember1::unbounded) : localElement.setMaxOccurs(upperBound) ->	
			localElement.setName(containedElement.name) ->
			// XPD-2569: adding ecore:name 
			addFeatureMapEntry(localElement.anyAttribute, containedElement.name, "name")  ->
			data.addOriginalName(localElement, getOriginalName(containedElement)) ->			
			xrefId == null || xrefId.trim().length == 0 ? null : (
				localElement.setId(xrefId)
				//localElement.setAnnotation(createAnnotationType("xsdID="+xrefId))
			) ->			
			
			// both the objects checked for null were containerAnonyComplexType!! 
			// i think the intention is to check for containerAnonyComplexType null and containedAnonyComplexType null
			containerAnonyComplexType == null && containedAnonyComplexType == null ? (
				let containerComplexType = containedElementSchema.complexType.select(e|e.name == containerElement.type.name).first() :
				let containedComplexType = containerElementSchema.complexType.select(e|e.name == containedElement.type.name).first() :					
				containedComplexType == null ? (
					let tmpPackage = containedElement.type.package : // packageList.eAllContents.typeSelect(Class).select(e|e == containedElement.type).first().eContainer :
					let containerElementSchema = schemaTypeList.typeSelect(xmlSchema::SchemaType).select(e|e.targetNamespace == getNamespace(tmpPackage,true)).first() :
					let topLevelElement = schemaTypeList.eAllContents.typeSelect(xmlSchema::TopLevelElement).select(e|e.name == containedElement.type.name).first() :									
					topLevelElement != null ? (						
						let localComplexType = new LocalComplexType :
						localElement.setComplexType(localComplexType) ->
						
						localElement.setType(createQName(stereotypeTargetNamespace,getLocalPart(getPropertyTypeName(data, containedElement)))) ->
						setElementStereotypedValues(data, containedElement, localElement)	
					) :						
								
					localElement.setType(createQName(stereotypeTargetNamespace, getLocalPart(getPropertyTypeName(data, containedElement))))
				) : (		
					let topLevelElement = schemaTypeList.eAllContents.typeSelect(xmlSchema::TopLevelElement).select(e|e.name == containedElement.type.name).first() :									
					topLevelElement != null ? (						
						let localComplexType = new LocalComplexType :
						localElement.setComplexType(localComplexType) ->						
						localElement.setType(createQName(stereotypeTargetNamespace, getLocalPart(getPropertyTypeName(data, containedElement)))) ->
						setElementStereotypedValues(data, containedElement, localElement)
					) :	(						
									
						localElement.setType(createQName(stereotypeTargetNamespace, getLocalPart(getPropertyTypeName(data, containedElement)))) ->
						setElementStereotypedValues(data, containedElement, localElement)
					)
				)
			) :
			(	// check for containedAnonyComplexType being null. // comes to this block and goes to the else part for XPD-3460 scenario
				containedAnonyComplexType == null ? (					
					let tmpPackage = containedElement.type.package : // packageList.eAllContents.typeSelect(Class).select(e|e == containedElement.type).first().eContainer :
					let containerElementSchema = schemaTypeList.typeSelect(xmlSchema::SchemaType).select(e|e.targetNamespace == getNamespace(tmpPackage,true)).first() :
					let topLevelElement = schemaTypeList.eAllContents.typeSelect(xmlSchema::TopLevelElement).select(e|e.name == containedElement.type.name).first() :
					
					topLevelElement != null ? (						
						let localComplexType = new LocalComplexType :
						localElement.setComplexType(localComplexType) ->						
						localElement.setType(createQName(containerElementSchema.targetNamespace,getLocalPart(containedElement.type.name))) ->
						setElementStereotypedValues(data, containedElement, localElement)
					) : (										
						traceMe("\n************************ HERE I A M FOR D I F F NAMES SCENARIO **************\n")->	
						localElement.setType(createQName(containerElementSchema.targetNamespace,getLocalPart(getPropertyTypeName(data, containedElement)))) ->
						setElementStereotypedValues(data, containedElement, localElement)
					)
				) : (
				
					// TODO We are searching here for the first TLE in ANY schema with the same name as the containedElement.type, that can't be correct
					// we should be looking ONLY in the schema for the containedElement.type
					let topLevelElement = schemaTypeList.eAllContents.typeSelect(xmlSchema::TopLevelElement).select(e|e.name == containedElement.type.name).first() :
												
					topLevelElement != null ? (						
						let localComplexType = new LocalComplexType :
						localElement.setComplexType(localComplexType) ->						
						localElement.setType(createQName(containerElementSchema.targetNamespace,getLocalPart(containedElement.type.name))) ->
						setElementStereotypedValues(data, containedElement, localElement)
					) : (									
						// XPD-3460: creating the package from contained element's type and using the namespace of this package to select the container element's schema 
						let tmpPackage = containedElement.type.package :
						let containerElementSchema = schemaTypeList.typeSelect(xmlSchema::SchemaType).select(e|e.targetNamespace == getNamespace(tmpPackage,true)).first() :
					
						traceMe("\n************************ HERE I A M FOR S A M E NAMES SCENARIO **************\n")->		
						localElement.setType(createQName(containerElementSchema.targetNamespace,getLocalPart(containedElement.type.name))) ->
						
						setElementStereotypedValues(data, containedElement, localElement)
					)
				)					
			) ->
			// finally check for containerAnonyComplexType being null
			containerComplexType == null ? (
				let containerComplexType = (
					let tmpComplexType = containedElementSchema.complexType.select(e|e.name == containerElement.type.name).first() :
					let tmpElemWithAnonComplexType = containedElementSchema.element.select(e|e.name +"Type" == containerElement.type.name).first() :
					tmpComplexType == null ? tmpElemWithAnonComplexType.complexType : tmpComplexType
				) :			
				let containedComplexType = (				
					let tmpComplexType = containedElementSchema.complexType.select(e|e.name == containedComplexType.name).first() :				
					let tmpElemWithAnonComplexType = containedElementSchema.element.select(e|e.name +"Type" == containedComplexType.name).first() :				
					tmpComplexType == null ? tmpElemWithAnonComplexType.complexType : tmpComplexType
				) :
				//let containerComplexType = containedElementSchema.complexType.select(e|e.name == containerElement.type.name).first() :
				//let containedComplexType = containerElementSchema.complexType.select(e|e.name == containedElement.type.name).first() :				
				containerComplexType != null ? (
					let explicitGroup = getElementSequence(data, containerComplexType, containedElement) :				 
					let alreadyExists = explicitGroup.element.select(e | e.name == localElement.name).first() :
					// XPD-5378: localElement if participating in composition association only then output in the xsd, else ignore
					let addAssocElem = _toAddAssocElement(localElement, (Class)containedElement) :	
					alreadyExists == null ? (	
						addAssocElem ?												
							addSortElementToExplicitGroup(localElement, explicitGroup, (Class)containedElement.eContainer) : null
					) : null													
				) : (
					let containerComplexType = getComplexWithAnonymousContainer(containerElementSchema, (Class)containedElement.eContainer, packageList) :
					
					let explicitGroup = getElementSequence(data, containerComplexType, containedElement) :		// might be containerElement???		 
					let alreadyExists = explicitGroup.element.select(e | e.name == localElement.name).first() :
					// XPD-5378: localElement if participating in composition association only then output in the xsd, else ignore
					let addAssocElem = _toAddAssocElement(localElement, (Class)containedElement) :	
					alreadyExists == null ? (	
						addAssocElem ?												
							addSortElementToExplicitGroup(localElement, explicitGroup, (Class)containedElement.eContainer) : null
					) : null					
				)
			) : (
				containerComplexType != null ? (
					let explicitGroup = getElementSequence(data, containerComplexType, containedElement) :				 
					let alreadyExists = explicitGroup.element.select(e | e.name == localElement.name).first() :
					// XPD-5378: localElement if participating in composition association only then output in the xsd, else ignore
					let addAssocElem = _toAddAssocElement(localElement, (Class)containedElement) :												
					// check if (Class)				
					alreadyExists == null ? (	
						addAssocElem ? 
							addSortElementToExplicitGroup(localElement, explicitGroup, (Class)containedElement.eContainer) : null
					) : null									
				) : (
					let containerComplexType = getComplexWithAnonymousContainer(containerElementSchema, (Class)containedElement.eContainer, packageList) :
					
					let explicitGroup = getElementSequence(data, containerComplexType, containedElement) :		// might be containerElement???		 
					let alreadyExists = explicitGroup.element.select(e | e.name == localElement.name).first() :
					// XPD-5378: localElement if participating in composition association only then output in the xsd, else ignore
					let addAssocElem = _toAddAssocElement(localElement, (Class)containedElement) :
					alreadyExists == null ? (
						addAssocElem ?													
							addSortElementToExplicitGroup(localElement, explicitGroup, (Class)containedElement.eContainer) : null
					) : null
				)			
			)
		) ->
		localElement
	);	
	
parseComposition(ExportTransformationData data, Collection[xmlSchema::SchemaType] schemaTypeList, Association association, Collection[Package] packageList) :
	let containerElement = association.member.first() :
	let property1 = association.memberEnd.first() :
	let property2 = association.memberEnd.last() :
	traceMe("\nparseComposition 4 args containerElement = " + containerElement.name ) ->
	traceMe("\nproperty1 = " + property1)->
	traceMe("\nproperty2 = " + property2 + "\n")->
	
	(containerElement == property1) ? (
		parseComposition(data, schemaTypeList, association, packageList, property1, property2) ->
		//let localElement = parseComposition(data, schemaTypeList, association, packageList, property1, property2) :
		traceMe("111 " + association.memberEnd.last().aggregation) 
		//association.memberEnd.last().aggregation == AggregationKind::none || association.memberEnd.last().aggregation == AggregationKind::shared ? (
			//localElement.setType(createQName("http://www.w3.org/2001/XMLSchema","anyURI")) ->
			//addFeatureMapEntry(localElement.anyAttribute, property2.type.name, "reference") 
		//) : null
	) : (
		parseComposition(data, schemaTypeList, association, packageList, property2, property1) ->
		//let localElement = parseComposition(data, schemaTypeList, association, packageList, property2, property1) :
		traceMe("222 " + association.memberEnd.last().aggregation) 
		//association.memberEnd.first().aggregation == AggregationKind::none || association.memberEnd.first().aggregation == AggregationKind::shared ? (
			//localElement.setType(createQName("http://www.w3.org/2001/XMLSchema","anyURI")) ->
			// XPD-2569: adding ecore:name 
			//addFeatureMapEntry(localElement.anyAttribute, property1.name, "name") ->
			//addFeatureMapEntry(localElement.anyAttribute, property1.type.name, "reference") 
		//) : null
	);	