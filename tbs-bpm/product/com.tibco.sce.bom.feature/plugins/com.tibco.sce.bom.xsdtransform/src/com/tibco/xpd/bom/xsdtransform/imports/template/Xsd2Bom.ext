// author glewis

import xmlSchema;
import type;
import uml;
import com::tibco::xpd::bom::xsdtransform::imports::template;

extension org::openarchitectureware::xsd::lib::qname;
extension org::openarchitectureware::xsd::lib::map;
extension com::tibco::xpd::bom::xsdtransform::imports::template::Extensions reexport;
//extension com::tibco::xpd::bom::xsdtransform::imports::template::debug::Xsd2BomDebugExtensions reexport;
extension com::tibco::xpd::bom::xsdtransform::imports::template::TopLevelFuncs reexport;
extension org::openarchitectureware::xsd::lib::xmlreader;


// SID XPD-1741: Transform a list of schemaTypes into BOM's (I __THINK__ this is only called for importing schema from WSDL)
// SID XPD-1741: Added schemaTypeToLocationMap - this must be a Map<Object, String> mapping schemaType to the wsdl import location for the given xsd.
List[uml::Model] transformSchemaTypesToBom(ImportTransformationData data, List[SchemaType] schemaTypes, String rootTargetNamespace, Object schemaTypeToLocationMap):	  
	  traceMeDebug("resetIndent") ->
	  traceMeDebug("=> transformSchemaTypesToBom") ->
	  //_debug_transformSchemaTypesToBom(data, schemaTypes, rootTargetNamespace, schemaTypeToLocationMap) ->
	  (
	  let models = {} :
	  let rootModelName = data.getResolvedPackageNamespace(rootTargetNamespace) :
	  
	  data.monitor.createTransformMonitor(schemaTypes.size + 2) ->
	  
	  // Do some normalisation and fixing of names etc (Sid: "I think!")
	  data.monitor.subTaskNormalisingAndFixingNames() ->
	  
	  schemaTypes.collect(e | (
	  	let schemaType = e :
	  	
	  	schemaType.eAllContents.typeSelect(xmlSchema::Attribute).select(e | isUndeclaredFormValue(e, data.attrUndeclaredForms) == true).collect(e | (	
		  	e.setForm(schemaType.attributeFormDefault)	
		)) ->
	  	schemaType.eAllContents.typeSelect(xmlSchema::Element).select(e | isUndeclaredFormValue(e, data.elemUndeclaredForms) == true).collect(e | (
			e.setForm(schemaType.elementFormDefault)	
	  	)) ->	  	
	  	
	  	data.wsdlSchemaTypes.add(e)
	  )) ->
	  
	  data.monitor.subTaskDone() ->
	  
	  schemaTypes.collect(e | (
	  		let schemaType = e :
	  		// Sid XPD-1741: Must pass the schema location that was used in the wsdl import of this xsd (so that schema's relative to IT are resolved correctly).
	  		transformSchemaToBomWithModelCache(data, schemaTypeToLocationMap.get(e), e, models, rootTargetNamespace)
	  	)	  	
	  ) ->
	  
	  data.monitor.subTaskCleanUpAndFixTargetNamespaces() ->
	  
	  //data.ctx.showStatus("transformSchemaTypesToBom: after subTaskCleanUpAndFixTargetNamespaces()") ->
	  
	  // Looks like root model is done last!
	  (
	  	let rootModel = models.select(e | e.name == rootModelName).first() :	  	
	  	rootModel == null ? (
	  		let newRootModel = new uml::Model :
	  		let newModels = {newRootModel}.addAll(models) :
	  		newRootModel.setName(rootModelName) ->
			addOtherResultModel(data, newRootModel) ->
			setUniqueId(data, newRootModel) ->
			setOriginalTargetNamespace(newRootModel,newRootModel,rootTargetNamespace) ->
			setOriginalSchemaLocation(data, newRootModel,newRootModel,null,null) ->
			setStudioVersion(newRootModel) ->

			data.monitor.subTaskDone() ->
			data.monitor.transformDone() ->
			//data.ctx.showStatus("transformSchemaTypesToBom: after transfromDone() 1") ->
			traceMeDebug("<= transformSchemaTypesToBom") ->			
			newModels
	  	) : (
	  		addOtherResultModel(data, rootModel) ->
	  		models.remove(rootModel) ->
	  		(
	  			let tmpModels = {rootModel}.addAll(models) :

				data.monitor.subTaskDone() ->
				data.monitor.transformDone() ->
				//data.ctx.showStatus("transformSchemaTypesToBom: after transfromDone() 2") ->
	  			traceMeDebug("<= transformSchemaTypesToBom in else part") ->	  		
	  			tmpModels	  			
	  		)
	  	)	    
	  )
	  );
	  
// SID XPD-1741: transform a schema to bom (I __THINK__ whilst caching the models loaded for each schema file) 
// SID XPD-1741: Added importOrIncludeSchemaLocation which is the location from the wsdl import statement for the given xsd.
transformSchemaToBomWithModelCache(ImportTransformationData data, String importOrIncludeSchemaLocation, SchemaType schemaType, List[uml::Model] models, String rootTargetNamespace): 
	traceMeDebug("=> transformSchemaToBomWithModelCache") ->
	//_debug_transformSchemaToBomWithModelCache (data, importOrIncludeSchemaLocation, schemaType, models, rootTargetNamespace) ->
	
	data.monitor.subTaskCreateBOMForSchema(schemaType.targetNamespace) ->
	
	(
		let model = (
			// The model name needs to be a valid Java package name. This is derived from the
			// schema target namspace OR if this is not defined, then from the "root" target namspace
			// (which will probably be from a WSDL)
			let modelName = (
				(schemaType.targetNamespace == null || schemaType.targetNamespace == "") ? (
					data.getResolvedPackageNamespace(rootTargetNamespace)
				) : (
					data.getResolvedPackageNamespace(schemaType.targetNamespace)
				)
			) :
			
			// Looks like its possible that we may have already populated the model list?
			// Pull out an existing model if there is a name match otherwise create a new UML model
			// (All creation of model should be encapsulated really)
			let existingModel = models.select(e | e.name == modelName).first() :		 
			existingModel == null ? (
				let newModel = new uml::Model :
				traceMe("transformSchemaToBomWithModelCache: Creating new uml::Model : " + modelName) ->
				schemaType.targetNamespace != null ? newModel.setName(data.getResolvedPackageNamespace(schemaType.targetNamespace)) : newModel.setName(resolveFileName(data)) ->			
				addOtherResultModel(data, newModel) ->
				setUniqueId(data, newModel) ->
				
				setOriginalTargetNamespace(newModel,newModel,schemaType.targetNamespace) ->			
				setOriginalSchemaLocation(data, newModel,newModel,null,null) ->
				setStudioVersion(newModel) ->
				setFormDefaults(newModel, schemaType.elementFormDefault.toString(), schemaType.attributeFormDefault.toString()) ->				
				// Set existingModel to the newly created one
				newModel
			) : (
				// Looks like we are going to do a reset/remove of an existing schema/model
				// First pull out the schema for this namespace from the current data and remove
				let existingSchema = data.schemaTypes.typeSelect(SchemaType).select(e|e.targetNamespace == schemaType.targetNamespace).first() :			
				traceMe("transformSchemaToBomWithModelCache: BOM model already exists so reset/remove : " + modelName) ->
				
				existingSchema == null ? 
				(
					traceMe("transformSchemaToBomWithModelCache: existing schema is null") ->
					null
				) :
				(
					traceMe("transformSchemaToBomWithModelCache: remove existing schema from current list, pull out the existing model and augment it") ->
					data.schemaTypes.remove(existingSchema) ->
					// Send the existing model to this completely mis-named java method so that we can
					// do what?
					addOtherResultModel(data, existingModel) ->
					existingModel
				)
			)
		) :
		
		// So at this point we have:
		// 1. Schema to transform
		// 2. A BOM model created with the correct name
		// 3. A Resource for the BOM 
		// 4. BOM filenames for the schemas in the WSDL?
		traceMe("transformSchemaToBomWithModelCache: Call parseSchema: " + schemaType) ->
		//data.ctx.inspectObject("transformSchemaToBomWithModelCache", model, schemaType, importOrIncludeSchemaLocation) ->
		
		// Now the work begins!	
		parseSchemaType(data, importOrIncludeSchemaLocation, schemaType, model, null) ->	
		
		parseTopLevelElementsAndAttributes(data, schemaType, model, model) ->
		
		data.schemaTypes.collect(e | parseTopLevelElementsAndAttributes(data, e, model, getNamespacePackage(data, e, model, null))) -> 
		
		data.otherResultModels.eAllContents.typeSelect(uml::Element).collect(e | applyElementStereotype(e, model)) ->
		
		data.monitor.subTaskDone() ->
				
		models.addAll(data.otherResultModels) ->
		
		//data.ctx.showStatus("transformSchemaToBomWithModelCache") ->
		traceMeDebug("<= transformSchemaToBomWithModelCache")	
	);
 

// create a DocumentRoot for every Sub-Epackage (SID XPD-1741: I __THINK__ this is only used for import or transform an individual XSD (not xsd's imported from wsdls).
List[uml::Model] transformIndividualSchemaToBom(ImportTransformationData data, SchemaType schemaType): 
	traceMeDebug("=> transformIndividualSchemaToBom") ->
	(
		let model = new uml::Model:	
		
		// OAW bug where element and attribute form defaults are taken from the schema default value in all cases so in Java we calculate early on
		// whether each individual element or attribute is of qualified or unqualified value and this section sets them accordingly before transformation begins.		
		schemaType.eAllContents.typeSelect(xmlSchema::Attribute).select(e | isUndeclaredFormValue(e, data.attrUndeclaredForms) == true).collect(e | (	
			e.setForm(schemaType.attributeFormDefault)	
		)) ->
		schemaType.eAllContents.typeSelect(xmlSchema::Element).select(e | isUndeclaredFormValue(e, data.elemUndeclaredForms) == true).collect(e | (	
			e.setForm(schemaType.elementFormDefault)	
		)) ->
			
		// initialisation of BOM - UML Model
		applyProfile(data, model) -> 
		addPackageToResource(data, model) ->
		schemaType.targetNamespace != null ? model.setName(data.getResolvedPackageNamespace(schemaType.targetNamespace)) : model.setName(resolveFileName(data)) ->
		addOtherResultModel(data, model) ->
		setUniqueId(data, model) ->
		setOriginalTargetNamespace(model,model,schemaType.targetNamespace) ->
		setOriginalSchemaLocation(data, model,model,null,null) ->
		setStudioVersion(model) ->
		setFormDefaults(model, schemaType.elementFormDefault.toString(), schemaType.attributeFormDefault.toString()) ->
		
		// parse the schema and all its includes / imports and potentially create multiple BOM models (stored in model resource map in Import Data object!)
		// This deals with everything apart from top level elements and attributes.
		parseSchemaType(data, null, schemaType, model, null) ->
		
		// This parses all the top level elements and attributes from all the schemas that we have encountered in previous method
		data.schemaTypes.collect(e | parseTopLevelElementsAndAttributes(data, e, model, getNamespacePackage(data, e, model, null))) -> 
		
		// this is setting up a stereotype xsdBasedElement on every uml classifier mainly to denote if it is dirty or not ... this may not be needed any more		
		data.otherResultModels.eAllContents.typeSelect(uml::Element).collect(e | applyElementStereotype(e, model)) ->
		
		traceMeDebug("<= transformIndividualSchemaToBom") ->			
		
		// this may not need to be returned - could be redundant now due to the models being populated inside the model resource map mentioned in earlier comment above.
		data.otherResultModels
	);

// checks a hashmap for an element or attribute and returns a preset key generated at start of transformation
cached String getElementOrAttributeKey(String key, Object container) :	
	//traceMe("=> getElementOrAttributeKey") ->
	xmlSchema::ComplexType.isInstance(container) ? (
		let name = (			
			(container.name == null || container.name.trim().length == 0) && xmlSchema::Element.isInstance(container.eContainer) ? (				
				container.eContainer.name
			) : (			
				container.name
			)
		) : (
			//traceMe("<= getElementOrAttributeKey") ->			
			getElementOrAttributeKey((name + "*" + key), container.eContainer)
		)		
	) : (
		xmlSchema::AttributeGroup.isInstance(container) ? (
			let name = container.name :
			//traceMe("<= getElementOrAttributeKey") ->				
			getElementOrAttributeKey((name + "*" + key), container.eContainer)
		) : (
			xmlSchema::Group.isInstance(container) && (!xmlSchema::ExplicitGroup.isInstance(container)) ? (
				let name = container.name :
				//traceMe("<= getElementOrAttributeKey") ->				
				getElementOrAttributeKey((name + "*" + key), container.eContainer)
			) : (
				xmlSchema::SchemaType.isInstance(container) ? (
					let name = container.targetNamespace :
					//traceMe("<= getElementOrAttributeKey") ->						
					(name + "*" + key)
				) : (			
					//traceMe("<= ") ->			
					getElementOrAttributeKey((""+key), container.eContainer)
				)
			)
		)
	);

// finds whether the element or attribute key (given from method getElementOrAttributeKey) is located inside 
// undeclaredList which is prepopulated in Java code before transformation due to a bug in oaw not being able to 
// determine if form is declared or not.
cached Boolean isUndeclaredFormValue(Object obj, List undeclaredList) :	
	//traceMe("=> isUndeclaredFormValue") ->
	(
		let key = getElementOrAttributeKey(obj.name, obj.eContainer) :	
		//traceMe("<= isUndeclaredFormValue") ->
		undeclaredList.contains(key)
	);

// searches the package for a classifier of a given name	
cached uml::Classifier getElementByName(String name, uml::Package package) :
	traceMe("=> getElementByName: '"+name + "' pkg="+package.name) ->
	(
		let foundClassifier = package.eAllContents.typeSelect(uml::Classifier).select(e | e.name == name).first() :
		
		traceMe("<= getElementByName: found: "+foundClassifier) ->
		foundClassifier
	);	

// transforms a schema into a uml model type	
uml::Model transformToBom(XmlSchemaDocumentRoot xmlSchemaDocumentRoot, ImportTransformationData data):
	  traceMe("=> transformToBom") ->
	  traceMe("<= transformToBom") ->
	  transformIndividualSchemaToBom(data, xmlSchemaDocumentRoot.schema);

// parses the schema and processes each construct in turn and attempts to create a uml equivalent inside the newly made model file
cached Boolean parseSchemaType(ImportTransformationData data, String importOrIncludeSchemaLocation, SchemaType schemaType, uml::Model model, uml::Package package) : 
	traceMeDebug("=>parseSchemaType(): importOrIncludeSchemaLocation=" + importOrIncludeSchemaLocation + " schemaType=" + schemaType.targetNamespace + " model=" + model.name + " package=" + package.name) ->
	
	schemaType != null ? (
		// check to ensure that this schema type and its dependencies have not already been parsed
		let isSchemaTypeExist = data.schemaTypes.typeSelect(SchemaType).exists(e|e == schemaType) :	
		// This is potentially an unused variable and the cache could be deleted...
		let isAlreadyRenamed = data.alreadyRenamedSchemaTypes.contains(schemaType) :
		traceMe("parseSchemaType(): schemaType="+schemaType.targetNamespace) ->
		isSchemaTypeExist ? null : (
			
			// Sid XPD-1741 Push this schema's location onto the stack (so we know what the base of the relative imports is
			data.pushImportSchemaLocation(importOrIncludeSchemaLocation) ->
			//data.ctx.showImportSchemaLocationStack() ->
			data.schemaTypes.add(schemaType) ->
			//data.ctx.showSchemaTypes() ->
			
			// OAW bug where element and attribute form defaults are taken from the schema default value in all cases so in Java we calculate early on
			// whether each individual element or attribute is of qualified or unqualified value and this section sets them accordingly before transformation begins.
			schemaType.eAllContents.typeSelect(xmlSchema::Attribute).select(e | isUndeclaredFormValue(e, data.attrUndeclaredForms) == true).collect(e | (	
			  	e.setForm(schemaType.attributeFormDefault)	
			)) ->
		  	schemaType.eAllContents.typeSelect(xmlSchema::Element).select(e | isUndeclaredFormValue(e, data.elemUndeclaredForms) == true).collect(e | (
				e.setForm(schemaType.elementFormDefault)	
		  	)) ->
			
			//schemaType.^import.collect(e| parseSchemaType(readXML(e.schemaLocation, "xsd"),model, (let newPackage = createNewPackage(e.namespace): package != null ? package.nestedPackage.add(newPackage) : model.nestedPackage.add(newPackage) -> newPackage))) ->
			
			// Collect all the <xsd:import> constructs and for each one we recursively call parseSchemaTypes
			// with the following criteria:
			// - subset the <import> list to those with a targetnamespace (POTENTIAL BUG -
			//   What if the import doesn't have a namespace. This is possible!
			// - subset this list eliminating the "KnownNamespaces" e.g. W3
			// - Collect the return from the recursive call to parseSchemaType,
			// even though this is a boolean and not used! I guess all the work is
			// saved inside the parameters i.e. model and data 
			// TODO: Workout what the role of the package is.
			traceMeDebug("parseSchemaType(): Iterate through any schema import constructs. START. (and recursively call parseSchemaType())") ->
			schemaType.^import.select(e|e.namespace != null)
							.select(e|!isKnownNamespace(e.namespace))
							.collect(e| parseSchemaType(data,
														 e.schemaLocation, 
														 resolveAndReadXML(data, e, e.schemaLocation, e.namespace),
														 model, 
														 (
														 	package != null ? (
														 	
														 	
														 	// XPD-6062: Now pass 'objectFromReferencingSchema' in so that schemaLocation is resovled relative to referencing schema/wsdl
														 	let newPackage = createNewPackage(data, model, e.namespace, e, e.schemaLocation, package) : newPackage) 
														 	: (
														 		let newPackage = createNewPackage(data, model, e.namespace, e, e.schemaLocation,  model) : newPackage
														 		)
														 	)
														 )
										)->
			traceMe("parseSchemaType(): Iterate through any schema import. END") ->
			// Transformation will start proper here
			// TODO: Again, when would package not be null?		
			// bharti: i think package would be not null when a schema is imported/included in a xsd		
			package != null ? (
						traceMe("parseSchemaType(): package is NOT null") ->
						createPackagedElements(data, schemaType, model, package)
					) : (
						traceMe("parseSchemaType(): package is null") ->
						createPackagedElements(data, schemaType, model)
					) ->
			
			// Sid XPD-1741 Now we're exiting this level of schema nesting, pop our schema location of the stack.
			data.popImportSchemaLocation() ->
			//data.ctx.showImportSchemaLocationStack() ->	
			traceMeDebug("<=parseSchemaType(): "+schemaType.targetNamespace)	
		)
	) : 
	traceMeDebug("<=parseSchemaType(): Schematype was null!!") ->
	null;	 
	
// given a schema location and namespace we read the schema and transform it into an oaw equivalent ready for parsing
// XPD4781: added a new argument schemaType (and updated all references to this method to pass this new argument) 
// so it gets passed on further down to readXML where we try to resolve base and relative uris w.r.to wsdl and imported/included xsd 
cached SchemaType resolveAndReadXML(ImportTransformationData data, Object schemaType, String schemaLocation, String namespace) : 
	traceMe("=>resolveAndReadXML(): schemaLocation=" + schemaLocation + " namespace=" +namespace) ->
	schemaLocation != null ? (
		let resolvedSchemaLocation = _createURIForSchemaLocation(data, schemaLocation) :  
		traceMe("<=resolveAndReadXML()") ->
		readXML(data, schemaType, resolvedSchemaLocation)
	) : ( // this means it is coming from a WSDL and is an inline schema
		let wsdlSchema = data.wsdlSchemaTypes.typeSelect(SchemaType).select(e|e.targetNamespace == namespace).first() :			
		traceMe("<=resolveAndReadXML(): From a WSDL inline schema") ->
		wsdlSchema != null ? wsdlSchema : readXMLFromURL(data, namespace)
	);

// creates a new uml package for a schema type with the resolved importTypeName used as the package name 
cached uml::Package createNewPackage(ImportTransformationData data, uml::Model model, String importTypeName, Object objectFromReferencingSchema, String schemaLocation, uml::Package parentPackage) :	
	traceMeDebug("=> createNewPackage(for schemaLocation: "+schemaLocation) ->
	(
		let resolvedImportName = data.getResolvedPackageNamespace(importTypeName) :
		let existingPackage = findPackage(data, parentPackage, resolvedImportName) :		
		existingPackage != parentPackage ? (
			traceMe("<= createNewPackage ends from the block when existingPackage != parentPackage") ->
			null
		) : (
			let packageName = data.getResolvedPackageNamespace(importTypeName) :
			let existingModel = data.otherResultModels.selectFirst(e|e.name==packageName) :
			existingModel != null ? existingModel : (
				let newRootModel = new uml::Model :					
				newRootModel.setName(data.getResolvedPackageNamespace(importTypeName)) ->						
				addOtherResultModel(data, newRootModel) ->		
				setUniqueId(data, newRootModel) ->		
				setOriginalTargetNamespace(model, newRootModel,importTypeName) ->

				// XPD-6062: Now pass 'objectFromReferencingSchema' in so that schemaLocation is resovled relative to referencing schema/wsdl
				setOriginalSchemaLocation(data, model, newRootModel, objectFromReferencingSchema, schemaLocation) ->
				
				setStudioVersion(newRootModel) ->
				traceMeDebug("<= createNewPackage(for schemaLocation: "+schemaLocation) ->
				newRootModel
			)
		)
	);

// for each included schema go thru its import and parse each imported xsd
cached parseImportsInIncludedSchemas(ImportTransformationData data, SchemaType includedSchemaType, uml::Model model, uml::Package package) :
	 traceMeDebug("parseImportsInIncludedSchemas(): includedSchemaType=" + includedSchemaType.targetNamespace + " model=" + model.name + " package=" + package.name) ->
	 // go through all imports for this schema and bring each one in
	 
	 includedSchemaType.^import.select(e|!isKnownNamespace(e.namespace))
	 						.collect(e| parseSchemaType
	 											(data, e.schemaLocation, resolveAndReadXML
	 																		(data, includedSchemaType, e.schemaLocation, e.namespace),
	 																		 model, 
	 																		(package != null ? 
	 																			// XPD-6062: Now pass 'objectFromReferencingSchema' in so that schemaLocation is resovled relative to referencing schema/wsdl
	 																			(let newPackage = createNewPackage(data, model, e.namespace, e, e.schemaLocation, package) : newPackage)
	 																			 :
	 																			 (let newPackage = createNewPackage(data, model, e.namespace, e, e.schemaLocation, model) : newPackage))
	 																		 ))
	;	 																		 

// parses each included schema and combines them with existing one
cached parseIncludedSchemas(ImportTransformationData data, SchemaType schemaType, List include, uml::Model model, uml::Package package) :
	traceMeDebug("=>parseIncludedSchemas(): schemaType:" + schemaType.targetNamespace + " model=" + model.name + " package=" + package.name) ->
	include != null ? 
			include.typeSelect(IncludeType)
				.select(e|!isKnownNamespace(e.schemaLocation)).
				collect(e | (
								let includedSchema = resolveAndReadXML(data, e, e.schemaLocation, null) :
								
								includedSchema != null && data.schemaTypes.contains(includedSchema) ? null :
								(
									data.schemaTypes.add(includedSchema)->
									
									// XPD-4166: set the schema location stereotype for included schemas also.
									// if this is not set then the indexer (WsdlBomIndexerProvider which looks at schema location for
	                             	// indexing xsd elements of this schema) does not index any elements that
	                             	// must be referenced by parts in the wsdl from this schema
	                             	
	                             	// XPD-6062: Now pass 'objectFromReferencingSchema' in so that schemaLocation is resovled relative to referencing schema/wsdl
									setOriginalSchemaLocation(data, model, model, e, e.schemaLocation)->
									
									includedSchema.eAllContents
										.typeSelect(xmlSchema::Attribute)
										.select(e | isUndeclaredFormValue(e, data.attrUndeclaredForms) == true)
										.collect(e | (e.setForm(includedSchema.attributeFormDefault))) ->
										
		  							includedSchema.eAllContents
		  								.typeSelect(xmlSchema::Element)
		  								.select(e | isUndeclaredFormValue(e, data.elemUndeclaredForms) == true)
		  								.collect(e | (e.setForm(includedSchema.elementFormDefault))) ->
		  										
		  							//traceMe("<=parseIncludedSchemas()") ->	
		  							
		  							 schemaType.annotation.addAll(includedSchema.annotation) ->
									 schemaType.annotation1.addAll(includedSchema.annotation1) ->
									 schemaType.attribute.addAll(includedSchema.attribute) ->
									 schemaType.attributeGroup.addAll(includedSchema.attributeGroup) ->	 
									 schemaType.complexType.addAll(includedSchema.complexType) ->	 
									 schemaType.element.addAll(includedSchema.element) ->
									 schemaType.group2.addAll(includedSchema.group2) ->
									 schemaType.notation.addAll(includedSchema.notation) ->
									 schemaType.simpleType.addAll(includedSchema.simpleType) ->
		  							
		  							 // add the document root lookup table i.e. tns="org.example.xsd" and tns1="org.example2.xsd" to schemaType doc root entry map.
									 (
									 	let isXmlSchemaDocRootType = XmlSchemaDocumentRoot.isInstance(schemaType.eContainer) :
									 	isXmlSchemaDocRootType == true ? (
									 		let xmlSchemaDocumentRoot = (XmlSchemaDocumentRoot)schemaType.eContainer :
									  		let xmlIncludedSchemaDocumentRoot = (XmlSchemaDocumentRoot)includedSchema.eContainer :
									  		xmlSchemaDocumentRoot.xMLNSPrefixMap.addAll(xmlIncludedSchemaDocumentRoot.xMLNSPrefixMap)
									  	) : (
									  		//data.ctx.inspectObject("parse included schemas(): 3", schemaType, includedSchema, model) ->
									  		traceMe("<=parse included schemas(): returning null") ->
									  		null
									  	)
									  )->
		  							
		  							// look for imports in the included schemas and parse them
		  							parseImportsInIncludedSchemas(data, includedSchema, model, package) ->
									
									// look for includes in the included schemas and parse them
									parseIncludedSchemas(data, schemaType, includedSchema.include, model, package)
								)
							)
						) 
	: 
	(
		traceMeDebug("<=parseIncludedSchemas(): schemaType:" + schemaType.targetNamespace + " model=" + model.name + " package=" + package.name)  ->
		null
	) ->
	
	traceMeDebug("<=parseIncludedSchemas(): schemaType:" + schemaType.targetNamespace + " model=" + model.name + " package=" + package.name) 
	
	;
	
// goes through the schema and processes all the schema includes, simple types, complex types and annotations
cached createPackagedElements(ImportTransformationData data, SchemaType schemaType, uml::Model model):	
	traceMeDebug("=>createPackagedElements(): Model only. TNS="+schemaType.targetNamespace) ->
	
	parseIncludedSchemas(data, schemaType, schemaType.include, model, null) ->	
	
	// parse all simple types that have NOT got enumerations and will resolve to primitive types
	schemaType.simpleType.select(e|e.restriction == null || (e.restriction != null && (e.restriction.enumeration == null || e.restriction.enumeration.size == 0)))
						.collect(e|toPrimitiveType(data, e, schemaType, model, model))
						.select(e| e!= null)->
	
	// parse all simple types that have 1 or more enumerations so will resolve to an enumeration
	schemaType.simpleType.select(e|e.restriction.enumeration != null && e.restriction.enumeration.size > 0)
							.collect(e|toEnumeration(data, e, schemaType, model, model, e.restriction.enumeration.id, e.restriction.enumeration.value))
							.select(e| e!= null)->
	
	// parse all complex types that are NOT anonymous and create a class for each one
	schemaType.complexType.select(e|e.name != null).collect(e|toClass(data, e, schemaType, model, null, model)).select(e| e!= null)->
	
	//parseTopLevelElementsAndAttributes(data, schemaType, model, model) ->
	
	schemaType.annotation.collect(e|parseAnnotations(model, schemaType, e, model)) ->
	
	traceMeDebug("<=createPackagedElements(): Model only. TNS="+schemaType.targetNamespace);		

// goes through the schema and processes all the schema includes, simpletypes, complex types and annotations	
cached createPackagedElements(ImportTransformationData data, SchemaType schemaType, uml::Model model, uml::Package package):

	traceMe("=>createPackagedElements(): Model + Package") ->
	traceMe("createPackagedElements(): schemaTypeNS=" + _getSchemaTypeNamespace(schemaType) + " model=" + model.name + " package=" + package.name) ->
	
	parseIncludedSchemas(data, schemaType, schemaType.include, model, package) ->	
	
	schemaType.simpleType.select(e|e.restriction == null || (e.restriction != null && (e.restriction.enumeration == null || e.restriction.enumeration.size == 0))).collect(e|toPrimitiveType(data, e, schemaType, model, package)).select(e| e!= null)->	
		
	schemaType.simpleType.select(e|e.restriction.enumeration != null && e.restriction.enumeration.size > 0).collect(e|toEnumeration(data, e, schemaType, model, package, e.restriction.enumeration.id, e.restriction.enumeration.value)).select(e| e!= null)->
		
	schemaType.complexType.select(e|e.name != null).collect(e|toClass(data, e, schemaType, model, null, package)).select(e| e!= null)->
	
	//parseTopLevelElementsAndAttributes(data, schemaType, model, package) ->
	
	schemaType.annotation.collect(e|parseAnnotations(model, schemaType, e, package)) ->
	
	traceMe("<=createPackagedElements(): Model + Package: schemaTypeNS=" + _getSchemaTypeNamespace(schemaType) + " model=" + model.name + " package=" + package.name);		

// parses the top level elements and attributes and applies a top level
// stereotype so we can differentiate upon exporting back
cached parseTopLevelElementsAndAttributes(ImportTransformationData data, SchemaType schemaType, uml::Model model, uml::Package package) :
	traceMe("=> parseTopLevelElementsAndAttributes") ->

	// XPD-4034: if one.xsd is included in two.xsd and if three.xsd imports one.xsd, 
	// then the top level elements in two.xsd are not getting generated. the reason being 
	// parsedTopLevelElementSchemas is a list of targetNamespace string and when include is used  
	// both the schemas would have same targetNamespace and one of the schema's top level elements are not getting parsed.
	// the solution would be to store schema type eobject rather than namespace. changed the parsedTopLevelElementSchemas list from string to eobject.
	// because this list was string it was being used in generateUniqueStandardUnionBaseTypeName and generateUniqueUnionSimpleTypeName which was inappropriate. 
	// made a change in the above two methods below to use a different list.

	data.parsedTopLevelElementSchemas.contains(schemaType) ? 	
	(
		traceMe("parseTopLevelElementsAndAttributes: schema target namespace is null") ->
		//data.ctx.inspectObject(schemaType.targetNamespace, schemaType)->
		null 
	)	
	: (	
		// Add to "processed" list. Looks like there is a sepearate map of schemas which
		// have had their TLEs processed	
		//data.ctx.inspectObject(schemaType.targetNamespace, schemaType)->
		data.parsedTopLevelElementSchemas.add(schemaType)-> 
	
				
		// parse top level attributes
		schemaType.attribute.select(e|(e.type == null && e.ref == null && e.simpleType == null && isComplexType(data, schemaType, e.type.namespaceURI, getAttributeLocalPart(data, e)) == false))
			.select(e|xmlSchema::SchemaType.isInstance(e.eContainer) == true)
			.collect(e|createRootAttributePrimitiveType(data, e, false, true, schemaType, model, getTopLevelPackage(data, model, e.eContainer)))
			.select(e| e!= null)->
		
		schemaType.attribute.select(e|(e.type != null && isComplexType(data, schemaType, e.type.namespaceURI, getAttributeLocalPart(data, e)) == false))
			.select(e|xmlSchema::SchemaType.isInstance(e.eContainer) == true)
			.collect(e|createRootAttributePrimitiveType(data, e, false, isKnownNamespace(e.type.namespaceURI), schemaType, model, getTopLevelPackage(data, model, e.eContainer)))
			.select(e| e!= null)->
		
		schemaType.attribute.select(e|(e.simpleType != null && e.simpleType.restriction != null && (e.simpleType.restriction.enumeration == null || (e.simpleType.restriction.enumeration == null || e.simpleType.restriction.enumeration.size == 0)) && e.type == null))
			.select(e|xmlSchema::SchemaType.isInstance(e.eContainer) == true)
			.collect(e|toAnonymousRootAttributePrimitiveType(data, e, e.simpleType, schemaType, model, getTopLevelPackage(data, model, e.eContainer), isKnownNamespace(e.simpleType.restriction.base.namespaceURI)))
			.select(e| e!= null)->
		
		schemaType.attribute.select(e|(e.simpleType != null && e.simpleType.restriction != null && e.simpleType.restriction.enumeration.size > 0 && e.type == null))
			.select(e|xmlSchema::SchemaType.isInstance(e.eContainer) == true)
			.collect(e|toAnonymousRootAttributeEnumeration(data, e, e.simpleType, schemaType, model, getTopLevelPackage(data, model, e.eContainer), e.simpleType.restriction.enumeration.id, e.simpleType.restriction.enumeration.value, isKnownNamespace(e.simpleType.restriction.base.namespaceURI)))
			.select(e| e!= null)->
		
		schemaType.attribute.select(e|(e.simpleType != null && e.simpleType.union != null && e.type == null))
			.select(e|xmlSchema::SchemaType.isInstance(e.eContainer) == true)
			.collect(e|toAnonymousRootAttributePrimitiveType(data, e, e.simpleType, schemaType, model, getTopLevelPackage(data, model, e.eContainer), false))
			.select(e| e!= null)->
		
		// parse top level elements			
		schemaType.element.select(e|(e.complexType == null && e.type == null && e.ref == null && e.simpleType == null && xmlSchema::SchemaType.isInstance(e.eContainer) == true 
					&& isComplexType(data, schemaType, e.type.namespaceURI, getElementLocalPart(data,e)) == false))
			.collect(e|createRootElementPrimitiveType(data, e, false, true, schemaType, model, getTopLevelPackage(data, model, e.eContainer)))
			.select(e| e!= null)->
			
		schemaType.element.select(e|(e.complexType == null && e.type != null && xmlSchema::SchemaType.isInstance(e.eContainer) == true 
					&& isComplexType(data, schemaType, e.type.namespaceURI, getElementLocalPart(data,e)) == false))
			.collect(e|createRootElementPrimitiveType(data, e, false, isKnownNamespace(e.type.namespaceURI), schemaType, model, getTopLevelPackage(data, model, e.eContainer)))
			.select(e| e!= null)->
			

																																																										
		schemaType.element.select(e|(e.simpleType != null && e.simpleType.restriction != null 
					&& (e.simpleType.restriction.enumeration == null || e.simpleType.restriction.enumeration.size == 0) && e.type == null))
			.select(e|xmlSchema::SchemaType.isInstance(e.eContainer) == true)
			.collect(e|toAnonymousRootElementPrimitiveType(data, e, e.simpleType, schemaType, model, getTopLevelPackage(data, model, e.eContainer), isKnownNamespace(e.simpleType.restriction.base.namespaceURI)))
			.select(e| e!= null)->
		
		schemaType.element.select(e|(e.simpleType != null && e.simpleType.restriction != null && e.simpleType.restriction.enumeration.size > 0 && e.type == null))
			.select(e|xmlSchema::SchemaType.isInstance(e.eContainer) == true)
			.collect(e|toAnonymousRootElementEnumeration(data, e, e.simpleType, schemaType, model, getTopLevelPackage(data, model, e.eContainer), e.simpleType.restriction.enumeration.id, e.simpleType.restriction.enumeration.value, isKnownNamespace(e.simpleType.restriction.base.namespaceURI)))
			.select(e| e!= null)->
		
		schemaType.element.select(e|(e.simpleType != null && e.simpleType.union != null && e.type == null))
			.select(e|xmlSchema::SchemaType.isInstance(e.eContainer) == true)
			.collect(e|toAnonymousRootElementPrimitiveType(data, e, e.simpleType, schemaType, model, getTopLevelPackage(data, model, e.eContainer), false))
			.select(e| e!= null)->
		
		schemaType.element.select(e|(e.complexType == null && e.type != null && isComplexType(data, schemaType, e.type.namespaceURI, getElementLocalPart(data,e))))
			.select(e|xmlSchema::SchemaType.isInstance(e.eContainer) == true)
			.collect(e| toRootElementClass(data, e, schemaType, e.type.namespaceURI, getElementLocalPart(data, e),  model, getTopLevelPackage(data, model, e.eContainer))) ->
		
		schemaType.element.select(e|(e.complexType == null && e.type == null && e.ref != null 
				&& isComplexType(data, schemaType, e.type.namespaceURI, getElementLocalPart(data,e))))
			.select(e|xmlSchema::SchemaType.isInstance(e.eContainer) == true)
			.collect(e| toRootElementClass(data, e, schemaType, e.ref.namespaceURI, e.ref.localPart,  model, getTopLevelPackage(data, model, e.eContainer))) ->
			
		schemaType.element.select(e|(e.complexType != null && e.type == null))
			.select(e|xmlSchema::SchemaType.isInstance(e.eContainer) == true)
			.collect(e| toAnonymousRootElementClass(data, e,e.complexType, schemaType, model, getTopLevelPackage(data, model, e.eContainer))) ->
		
		//data.ctx.showStatus("parseTopLevelElementsAndAttributes") ->	
		traceMe("<= parseTopLevelElementsAndAttributes")
	) 
	;

// gets the top level package associated with the given schema type
cached Package getTopLevelPackage(ImportTransformationData data, uml::Model model, SchemaType schemaType) :
	let packageName = data.getResolvedPackageNamespace(schemaType.targetNamespace) :
	let existingModel = data.otherResultModels.selectFirst(e|e.name==packageName) :
	existingModel != null ? existingModel : (
		let tmpPackage = (			
			let existingPackage = findPackage(data, model, packageName) :		
			existingPackage
		) :
		tmpPackage
	);
	
// determines whether the localPart is a known XML Schema b
cached Boolean isKnownXSDType(String localPart):	
	switch(localPart) {		
		case "anyType": true
		case "anySimpleType": true
		case "gYearMonth": true
		case "gYear": true
		case "gMonthDay": true
		case "gDay": true
		case "gMonth": true
		case "QName": true
		case "NOTATION": true
		case "normalizedString": true
		case "token": true
		case "nonPositiveInteger": true
		case "long": true
		case "nonNegativeInteger": true
		case "language": true
		case "Name": true
		case "NMTOKEN": true
		case "negativeInteger": true		
		case "unsignedLong": true
		case "positiveInteger": true
		case "NCName": true
		case "NMTOKENS": true
		case "short": true
		case "unsignedInt": true
		case "IDREF": true
		case "ENTITY": true
		case "byte": true
		case "unsignedShort": true
		case "IDREFS": true
		case "ENTITIES": true
		case "unsignedByte": true
		case "boolean": true
		case "string": true
		case "integer": true
		case "int": true
		case "decimal": true
		case "float": true
		case "double": true
		case "dateTime": true
		case "date": true
		case "time": true
		case "ID": true
		case "anyURI": true
		case "duration": true
		case "base64Binary": true
		case "hexBinary": true
		default: false
	};

// returns true if the construct is top level 
Boolean isRootDocumentObject(ImportTransformationData data, SchemaType schemaType, String name) :
	traceMe("=>isRootDocumentObject(): schemaType=" + schemaType.targetNamespace + " name=" + name) ->
	(
		let temp = (
			(schemaType.complexType != null && schemaType.complexType.select(e|getComplexName(data, e) == name).size > 0) ||
			(schemaType.simpleType != null && schemaType.simpleType.select(e|e.name == name).size > 0) ||
			(schemaType.attribute != null && schemaType.attribute.select(e|e.name == name).size > 0) ||
			(schemaType.attributeGroup != null && schemaType.attributeGroup.select(e|e.name == name).size > 0) ||
			(schemaType.element != null && schemaType.element.select(e|e.name == name).size > 0) ||
			(schemaType.group2 != null && schemaType.group2.select(e|e.name == name).size > 0)		
		) :	
		traceMe("<=isRootDocumentObject(): schemaType=" + schemaType.targetNamespace + " name=" + name + " result=" + temp) ->
		temp
	);
	
// finds the containing schema for a given construct name
cached SchemaType findSchemaTypeForLocalPart(ImportTransformationData data, String localPart, String namespaceURI) :
	traceMe("=> findSchemaTypeForLocalPart " + localPart) ->
	localPart != null ? (			
		let schemaTypeList = (			
			let tempList = {} :			
			data.schemaTypes == null ? null : tempList.addAll(data.schemaTypes) ->			
			data.wsdlSchemaTypes == null ? null : tempList.addAll(data.wsdlSchemaTypes) ->			
			tempList
		) :	
		let schemaList = schemaTypeList.typeSelect(SchemaType).simpleType.select(e| true == getSimpleName(data, e).contains(localPart)).eContainer :
		let complexSchemaList = schemaTypeList.typeSelect(SchemaType).complexType.select(e| true == getComplexName(data, e).contains(localPart)).eContainer :	
		let attributeGroupSchemaList = schemaTypeList.typeSelect(SchemaType).select(e| true == e.attributeGroup.name.contains(localPart)) :
		let groupSchemaList = schemaTypeList.typeSelect(SchemaType).select(e| true == e.group2.name.contains(localPart)) :
		
		schemaList.addAll(complexSchemaList) ->
		schemaList.addAll(attributeGroupSchemaList) ->
		schemaList.addAll(groupSchemaList) ->
		
		traceMe("<= ") ->
		//XPD-7553: If namespace uri is available then select the schema matching it, otherwise return the first one from the list
		namespaceURI != null ? schemaList.typeSelect(SchemaType).select(e|e.targetNamespace == namespaceURI).first() : schemaList.first()
	) : null;
	
// finds the containing package for a given construct name	
cached uml::Package findPackageForLocalPart(ImportTransformationData data, uml::Package package, String localPart, String namespaceURI) :
	traceMe("=> findPackageForLocalPart") ->
	(
		let schemaForLocalPart = findSchemaTypeForLocalPart(data, localPart, namespaceURI) :		
		schemaForLocalPart == null ? package : 
		(		
			let resolvedPackageNamespace = data.getResolvedPackageNamespace(schemaForLocalPart.targetNamespace) :
			let tempPackage = findPackage(data, package, resolvedPackageNamespace) :		
			traceMe("<= ") ->
			tempPackage
				
		)
	);

// gets a stereotype value for a given uml object	
Object getStereotypeValue(uml::Element umlElement, uml::Stereotype stereotype, String propertyName) :
	let hasValue = hasValue(umlElement, stereotype, propertyName) :
	hasValue == true ? getValue(umlElement, stereotype, propertyName) : null;
	
// returns the original xsd name for a uml classifier (this could be changed in UML from the duplicate renaming code at start) 
cached String getOriginalXSDName(Object obj) :
	uml::PrimitiveType.isInstance(obj) ? (
		let stereotype = obj.getAppliedStereotypes().select(e|e.name == "XsdBasedPrimitiveType").first() :
		getStereotypeValue(obj, stereotype, "xsdSimpleTypeName")		
	) : (
		uml::Enumeration.isInstance(obj) ? (
			let stereotype = obj.getAppliedStereotypes().select(e|e.name == "XsdBasedEnumeration").first() :
			getStereotypeValue(obj, stereotype, "xsdSimpleTypeName")
		) : (
			uml::Class.isInstance(obj) ? (
				let stereotype = obj.getAppliedStereotypes().select(e|e.name == "XsdBasedClass").first() :
				getStereotypeValue(obj, stereotype, "xsdName")
			) : obj.name
		)
	);

// find and return the uml class with the provided name from the model / packages  
uml::Class findTargetClass(ImportTransformationData data, String name, uml::Model model, uml::Package package, String namespaceURI) :	
	traceMe("=> findTargetClass") ->
	traceMe("<= ") ->
	(
		let tmpCls = model.eAllContents.typeSelect(uml::Class).select(e|e.name == name).first() :
		model.eAllContents.typeSelect(uml::Class).collect(e | traceMe(e.name)) ->
		tmpCls != null ? tmpCls : (
			let tmpCls2 = package.eAllContents.typeSelect(uml::Class).select(e|e.name == name).first() :
			tmpCls2 != null ? tmpCls2 : (				
				traceMe("looking for class "+name) ->
				findPackageForLocalPart(data, model, name, namespaceURI).eAllContents.typeSelect(uml::Class).select(e|e.name == name).first()
			)
		)
	);
	
// checks to see if primitive already exists and if not it creates one for a given attribute
cached uml::PrimitiveType toPrimitiveType(ImportTransformationData data, Attribute attribute, SchemaType schemaType, uml::Model model, uml::Package package): 
    traceMe("=> toPrimitiveType: From Attribute") ->
    (
	    let primitiveType = getPrimitiveTypeByName(data, model, getNamespacePackage(data, schemaType, package, null), attribute.name, false) : 
	    let primitiveType = createPrimitiveType(data, attribute, primitiveType, schemaType, model, package) :
		traceMe("<= toPrimitiveType: From Attribute") ->
		primitiveType
	);
	
// checks to see if primitive already exists and if not it creates one for a given anonymous simple type
cached uml::PrimitiveType toPrimitiveType(ImportTransformationData data, String name, LocalSimpleType simpleType, SchemaType schemaType, uml::Model model, uml::Package package): 
    traceMe("=> toPrimitiveType: Anonymous SimpleType") ->
    (
	    let primitiveType = getPrimitiveTypeByName(data, model, getNamespacePackage(data, schemaType, package, null), name, false) : 
	    let primitiveType = createPrimitiveType(data, name, primitiveType, simpleType, schemaType, model, package) :
		traceMe("<= toPrimitiveType: Anonymous SimpleType") ->
		primitiveType
	);
	
	
// checks to see if primitive already exists and if not it creates one for a given simple type
cached uml::PrimitiveType toPrimitiveType(ImportTransformationData data, SimpleType simpleType, SchemaType schemaType, uml::Model model, uml::Package package): 
    traceMe("=> toPrimitiveType: Standard SimpleType: "+ simpleType.name) ->
    (
    	let primitiveType = getPrimitiveTypeByName(data, model, getNamespacePackage(data, schemaType, package, null), getSimpleName(data, simpleType), false) : 
    	let primitiveType = createPrimitiveType(data, primitiveType, simpleType, schemaType, model, package) :
		traceMe("<= toPrimitiveType: Standard SimpleType: " + simpleType.name + " -> PrimitiveType: " + primitiveType.name) ->
		primitiveType
	);
	
// checks to see if primitive already exists and if not it creates one for a given elemet with anonymous simple type
cached uml::PrimitiveType toPrimitiveType(ImportTransformationData data, Element parentElement, SimpleType simpleType, SchemaType schemaType, uml::Model model, uml::Package package): 
	traceMe("=> toPrimitiveType: TLE with Anonymous SimpleType") ->
	(
		let primitiveType = getPrimitiveTypeByName(data, model, getNamespacePackage(data, schemaType, package, null), getElementName(data, parentElement), false) : 
		let primitiveType = createPrimitiveType(data, parentElement, primitiveType, simpleType, schemaType, model, package) :	
		traceMe("<= toPrimitiveType: TLE with Anonymous SimpleType") ->
		primitiveType
	);

// checks to see if primitive already exists and if not it creates one for a given
// attribute with an anonymous simple type	
cached uml::PrimitiveType toPrimitiveType(ImportTransformationData data, Attribute parentAttribute, SimpleType simpleType, SchemaType schemaType, uml::Model model, uml::Package package): 
	traceMe("=> toPrimitiveType: TLA with Anonymous SimpleType") ->
	(
		let primitiveType = getPrimitiveTypeByName(data, model, getNamespacePackage(data, schemaType, package, null), getAttributeName(data, parentAttribute), false) : 
		let primitiveType = createPrimitiveType(data, parentAttribute, primitiveType, simpleType, schemaType, model, package) :	
		traceMe("<= toPrimitiveType: TLA with Anonymous SimpleType") ->
		primitiveType
	);

// checks to see if enumeration already exists and if not it creates 
// one for a given anonymous simple type with enumeration values
cached uml::Enumeration toEnumeration(ImportTransformationData data, String name, LocalSimpleType simpleType, SchemaType schemaType, uml::Model model, uml::Package package, List enumIDList, List enumValueList) : 
	traceMe("=> toEnumeration 1. For anonymous SimpleType: name=" + name) ->
	(
		let enumType = getEnumTypeByName(data, getNamespacePackage(data, schemaType, package, null), name, false) : 
		let enumType = createEnumeration(data, name, enumType, simpleType, schemaType, model, package, enumIDList, enumValueList) :
		traceMe("<= toEnumeration 1. For anonymous SimpleType: Enum:" + enumType.name) ->
		enumType
	);

// checks to see if enumeration already exists and if not it creates
// one for a given simple type with enumeration values in its restriction	
cached uml::Enumeration toEnumeration(ImportTransformationData data, SimpleType simpleType, SchemaType schemaType, uml::Model model, uml::Package package, List enumIDList, List enumValueList) : 
	traceMe("=> toEnumeration 2. For Standard SimpleType with enum restriction. SimpleType: " + simpleType.name) ->
	(
		let enumType = getEnumTypeByName(data, getNamespacePackage(data, schemaType, package, null), getSimpleName(data, simpleType), false) : 
		let enumType = createEnumeration(data, enumType, simpleType, schemaType, model, package, enumIDList, enumValueList) :
		traceMe("<= toEnumeration 2. For Standard SimpleType with enum restriction Enum:" + enumType.name) ->
		enumType
	);

// checks to see if enumeration already exists and if not it creates 
// one for a given element with anonymous simple type with enumeration values in its restriction	
cached uml::Enumeration toEnumeration(ImportTransformationData data, Element parentElement, SimpleType simpleType, SchemaType schemaType, uml::Model model, uml::Package package, List enumIDList, List enumValueList) : 
	traceMe("=> toEnumeration 3. For anonymous SimpleType with enumeration values in its restriction.") ->
	traceMe("toEnumeration 3. TODO: How is this different from toEnumeration 1??") ->
	(
		let enumType = getEnumTypeByName(data, getNamespacePackage(data, schemaType, package, null), getElementName(data, parentElement), false) : 
		let enumType = createEnumeration(data, parentElement, enumType, simpleType, schemaType, model, package, enumIDList, enumValueList) :
		traceMe("<= toEnumeration 3. For anonymous SimpleType with enumeration values in its restriction.: Enum:" + enumType.name) ->
		enumType
	);	

// checks to see if enumeration already exists and if not it creates 
// one for a given attribute with anonymous simple type with enumeration values in its restriction
cached uml::Enumeration toEnumeration(ImportTransformationData data, Attribute parentAttribute, SimpleType simpleType, SchemaType schemaType, uml::Model model, uml::Package package, List enumIDList, List enumValueList) : 
	traceMe("=> toEnumeration 4. For anonymous SimpleType with enumeration values in its restriction.") ->
	traceMe("toEnumeration 4. TODO: How is this different from toEnumeration 1 and 3 ??") ->
	(
		let enumType = getEnumTypeByName(data, getNamespacePackage(data, schemaType, package, null), getAttributeName(data, parentAttribute), false) : 
		let enumType = createEnumeration(data, parentAttribute, enumType, simpleType, schemaType, model, package, enumIDList, enumValueList) :
		traceMe("<= toEnumeration 4. For anonymous SimpleType with enumeration values in its restriction.: Enum:" + enumType.name) ->
		enumType
	);

// returns the generic type (either enumeration or primitive type) for a construct with a given prefix and localPart
uml::Type toType(ImportTransformationData data, uml::Model model, String prefix, String localPart, SchemaType schemaType, uml::Package package):
	traceMe("=> toType") ->
	(
		let tempType = getEnumTypeByName(data, getNamespacePackage(data, schemaType, package, prefix), localPart, true) :
		tempType != null ? (
			traceMe("<= ") ->
			tempType
		) : (		 
			let tempType = getPrimitiveTypeByName(data, model, getNamespacePackage(data, schemaType, package, prefix), localPart, true) :
			tempType != null ? (
				traceMe("<= ") ->
				tempType 
			): (
				let tempType = getBOMType(data, tempType, model, localPart) : 
				tempType != null ? (
					traceMe("<= ") ->
					tempType
				) : (
					let tempType = getType(data, tempType, model, prefix, localPart, schemaType, package) :
					traceMe("<= ") ->
					tempType
				)
			)
		)
	);
	
// returns the standard BOM primitive type if there is a direct match for the XML Schema requestedType property
cached uml::Type getBOMType(ImportTransformationData data, uml::Type type, uml::Model model, String requestedType): 
	let bomPrimType = getBOMPrimitiveType(data, requestedType) :	
	traceMe("=> getBOMType") ->
	traceMe("<= ") ->
	type != null ? type : bomPrimType;

// returns the user created primitive type if there is a direct match for the XML Schema localPart property - creates one if cannot b
cached uml::Type getType(ImportTransformationData data, uml::Type type, uml::Model model, String prefix, String localPart, SchemaType schemaType, uml::Package package):	
	traceMe("=>getType(): type=" + type + " model=" + model + " prefix=" + prefix + " localPart=" + localPart + " schemaType=" + schemaType + " package=" + package) ->
	type != null ? type : (
		let schemaTypeForPrefix = getSchemaTypeForPrefix(data, schemaType,prefix) :
		let tmpp = schemaTypeForPrefix.eAllContents.typeSelect(xmlSchema::ComplexType).collect(e|traceMe("STname="+e.name)) : 
		let simpleType = schemaTypeForPrefix.eAllContents.typeSelect(xmlSchema::SimpleType).select(e|e.name == localPart).first() :
		let namespacePackage = getNamespacePackage(data, schemaType, package, prefix) :
		traceMe("getType(): schemaTypeForPrefix= " + schemaTypeForPrefix + " simpleType=" + simpleType + " namespacePackage=" + namespacePackage) ->

		simpleType.restriction.enumeration != null && simpleType.restriction.enumeration.size > 0 ? (		
			let tempType = createEnumeration(data, type, simpleType, schemaTypeForPrefix, model, namespacePackage, simpleType.restriction.enumeration.id, simpleType.restriction.enumeration.value) :
			traceMe("<==getType(): Enumeration") ->
			tempType	
		) : (			
			let tempType = createPrimitiveType(data, type, simpleType, schemaTypeForPrefix, model, namespacePackage) :
			traceMe("<==getType(): PrimitiveType") ->
			tempType
		)  
	);

// creates an enumeration for an anonymous simple type and applies its stereotype values along with creating any generalisations it may have
cached uml::Type createEnumeration(ImportTransformationData data, String name, uml::Type enumType, LocalSimpleType simpleType, SchemaType schemaType, uml::Model model, uml::Package package, List enumIDList, List enumValueList):    	
	traceMe("=>createEnumeration()1:") ->
	enumType != null ? enumType : 
		(name == null ? null : 
			(
			let newEnum = new uml::Enumeration :			
			newEnum.setPackage(package) ->		
			newEnum.setName(name) ->		
			setUniqueId(data, newEnum) ->			
			setAnonStereotypeValue(newEnum, false) ->
			
			simpleType.restriction == null ? null : (
				let generalisation = getGeneralization(data, simpleType, schemaType, model, 1, newEnum, package) :				
				generalisation.general != null ? newEnum.generalization.add(generalisation) : null ->
				applyPrimitiveStereotypeValues(newEnum, name, simpleType.id, getFinalListValue(simpleType.final), simpleType.restriction.id, simpleType.restriction.base.prefix + ":" + simpleType.restriction.base.localPart) ->
				setOtherStereotypeValues(null, getSimpleTypeBasePart(data, simpleType.eContainer, simpleType), null, newEnum, isSimpleType(data, simpleType.restriction))
			) ->
			simpleType.union == null ? null : (		
				let anonSimpleTypeNames = {} :	
				applyPrimitiveStereotypeValues(newEnum, name, simpleType.id, getFinalListValue(simpleType.final), simpleType.union.id, null) ->
				simpleType.union.memberTypes.collect(e | parseUnion(data, schemaType, model, newEnum, e, package)) ->
				simpleType.union.simpleType.collect(e | parseUnionSimples(data, schemaType, model, newEnum, e, anonSimpleTypeNames)) ->
				applyXSDUnionMembers(data, newEnum, simpleType.union.memberTypes.toString(), anonSimpleTypeNames, schemaType.targetNamespace)
			) ->
			
			parseAnnotations(model, schemaType, simpleType.annotation, newEnum, package) ->
				
			//enumList.typeSelect(String).select(e|e.trim().length > 0).collect(e| createEnumerationLiteral(newEnum, e.toString())) ->
			createEnumerationLiteral(newEnum, enumIDList, enumValueList) ->			
			
			//isRootDocumentObject(schemaType, newEnum.name) ? getDocumentClass(package).ownedAttribute.add(toProperty(model, getDocumentClass(package),simpleType.name, (uml::Type)newEnum, getSimpleMinSize(simpleType), getSimpleMaxSize(simpleType), schemaType, simpleType.annotation)) : null -> GLNEW
			isRootDocumentObject(data, schemaType, newEnum.name) && getSimpleTypeBasePart(data, simpleType.eContainer, simpleType) != null 
				&& getBOMPrimitiveType(data, getSimpleTypeBasePart(data, simpleType.eContainer, simpleType)) == null ? 
					(createGeneralization(model,
											newEnum,
											getCreateClassByName(data, schemaType, model, simpleType.^restriction.base.prefix,simpleType.^restriction.base.prefixsimpleType.^restriction.base.namespaceURI, getSimpleTypeBasePart(data, simpleType.eContainer, simpleType),
											package)))
					: null ->			
			
			isRootDocumentObject(data, schemaType, newEnum.name) && simpleType.^list.itemType.localPart != null 
				&& getBOMPrimitiveType(data, simpleType.^list.itemType.localPart) == null ? 
					(createGeneralization(model,
											newEnum,
											getCreateClassByName(data, schemaType, model, simpleType.^list.itemType.prefix, simpleType.^list.itemType.namespaceURI, simpleType.^list.itemType.localPart, package)))
											: null ->
			
			traceMe("<= ") ->
						
			newEnum)
		);
	
// creates an enumeration for a simple type and applies its stereotype values along with creating any generalisations it may have
cached uml::Type createEnumeration(ImportTransformationData data, uml::Type enumType, SimpleType simpleType, SchemaType schemaType, uml::Model model, uml::Package package, List enumIDList, List enumValueList):    	
	// XPD-3896: find the type of the parent/super class of the enumeration to set in the generalisation
	// super type can be enumeration/primitive type
	let superType = toType(data, model, simpleType.restriction.base.prefix, getSimpleTypeBasePart(data, simpleType.eContainer, simpleType), schemaType, package) :
	traceMe("=>createEnumeration()2:") ->
	enumType != null ? enumType : 
		(getSimpleName(data, simpleType) == null ? null : 
			(
			let newEnum = new uml::Enumeration :			
			newEnum.setPackage(package) ->		
			newEnum.setName(getSimpleName(data, simpleType)) ->		
			setUniqueId(data, newEnum) ->
			
			simpleType.restriction == null ? null : (
				applyPrimitiveStereotypeValues(newEnum, simpleType.name, simpleType.id, getFinalListValue(simpleType.final), simpleType.restriction.id, simpleType.restriction.base.prefix + ":" + simpleType.restriction.base.localPart) ->
				setOtherStereotypeValues(null, getSimpleTypeBasePart(data, simpleType.eContainer, simpleType), null, newEnum, isSimpleType(data, simpleType.restriction))
			) ->
			simpleType.union == null ? null : (	
				let anonSimpleTypeNames = {} :		
				applyPrimitiveStereotypeValues(newEnum, simpleType.name, simpleType.id, getFinalListValue(simpleType.final), simpleType.union.id, null) ->
				simpleType.union.memberTypes.collect(e | parseUnion(data, schemaType, model, newEnum, e, package)) ->
				simpleType.union.simpleType.collect(e | parseUnionSimples(data, schemaType, model, newEnum, e, anonSimpleTypeNames)) ->
				applyXSDUnionMembers(data, newEnum, simpleType.union.memberTypes.toString(), anonSimpleTypeNames, schemaType.targetNamespace)
			) ->
			
			parseAnnotations(model, schemaType, simpleType.annotation, newEnum, package) ->
				
			//enumList.typeSelect(String).select(e|e.trim().length > 0).collect(e| createEnumerationLiteral(newEnum, e.toString())) ->
			createEnumerationLiteral(newEnum, enumIDList, enumValueList) ->			
			
			//isRootDocumentObject(schemaType, newEnum.name) ? getDocumentClass(package).ownedAttribute.add(toProperty(model, getDocumentClass(package),simpleType.name, (uml::Type)newEnum, getSimpleMinSize(simpleType), getSimpleMaxSize(simpleType), schemaType, simpleType.annotation)) : null -> GLNEW
			//isRootDocumentObject(data, schemaType, newEnum.name) && getSimpleTypeBasePart(data, simpleType.eContainer, simpleType) != null && getBOMPrimitiveType(data, getSimpleTypeBasePart(data, simpleType.eContainer, simpleType)) == null ? (createGeneralization(model,newEnum,getCreateClassByName(data, schemaType, model, simpleType.^restriction.base.prefix, simpleType.^restriction.base.namespaceURI, getSimpleTypeBasePart(data, simpleType.eContainer, simpleType), package))) : null ->
			isRootDocumentObject(data, schemaType, newEnum.name) && getSimpleTypeBasePart(data, simpleType.eContainer, simpleType) != null && getBOMPrimitiveType(data, getSimpleTypeBasePart(data, simpleType.eContainer, simpleType)) == null ? (_setGeneralizationForSimpleTypeRestrictionOfEnumeration(data, newEnum, simpleType, superType)) : null ->
			isRootDocumentObject(data, schemaType, newEnum.name) && simpleType.^list.itemType.localPart != null && getBOMPrimitiveType(data, simpleType.^list.itemType.localPart) == null ? (createGeneralization(model,newEnum,getCreateClassByName(data, schemaType, model, simpleType.^list.itemType.prefix, simpleType.^list.itemType.namespaceURI, simpleType.^list.itemType.localPart, package))) : null ->
			
			traceMe("<=createEnumeration()2:") ->						
			newEnum)
		);
		
// creates an enumeration for an anonymous simple type and applies its stereotype values along with creating any generalisations it may have		
cached uml::Type createEnumeration(ImportTransformationData data, Element parentElement, uml::Type enumType, SimpleType simpleType, SchemaType schemaType, uml::Model model, uml::Package package, List enumIDList, List enumValueList):    	
	traceMe("=> createEnumeration 3") ->
	enumType != null ? enumType : 
		(getElementName(data, parentElement) == null ? null : 
			(
			let newEnum = new uml::Enumeration :			
			newEnum.setPackage(package) ->		
			newEnum.setName(getElementName(data, parentElement)+"Type") ->
			setUniqueId(data, newEnum) ->
			setAnonStereotypeValue(newEnum, false) ->
			
			simpleType.restriction == null ? null : (
				applyPrimitiveStereotypeValues(newEnum, parentElement.name, simpleType.id, getFinalListValue(simpleType.final), simpleType.restriction.id, simpleType.restriction.base.prefix + ":" + simpleType.restriction.base.localPart) ->
				setOtherStereotypeValues(null, getSimpleTypeBasePart(data, parentElement, simpleType), null, newEnum, isSimpleType(data, simpleType.restriction))
			) ->
			simpleType.union == null ? null : (		
				let anonSimpleTypeNames = {} :	
				applyPrimitiveStereotypeValues(newEnum, parentElement.name, simpleType.id, getFinalListValue(simpleType.final), simpleType.union.id, null) ->
				simpleType.union.memberTypes.collect(e | parseUnion(data, schemaType, model, newEnum, e, package)) ->
				simpleType.union.simpleType.collect(e | parseUnionSimples(data, schemaType, model, newEnum, e, anonSimpleTypeNames)) ->
				applyXSDUnionMembers(data, newEnum, simpleType.union.memberTypes.toString(), anonSimpleTypeNames, schemaType.targetNamespace)
			) ->
			
			parseAnnotations(model, schemaType, simpleType.annotation, newEnum, package) ->
			
			createEnumerationLiteral(newEnum, enumIDList, enumValueList) ->
						
			isRootDocumentObject(data, schemaType, getElementName(data, parentElement)) && getSimpleTypeBasePart(data, simpleType.eContainer, simpleType) != null && getBOMPrimitiveType(data, getSimpleTypeBasePart(data, parentElement, simpleType)) == null ? (createGeneralization(model,newEnum,getCreateClassByName(data, schemaType, model, simpleType.^restriction.base.prefix, simpleType.^restriction.base.namespaceURI, getSimpleTypeBasePart(data, parentElement, simpleType), package))) : null ->
			isRootDocumentObject(data, schemaType, getElementName(data, parentElement)) && simpleType.^list.itemType.localPart != null && getBOMPrimitiveType(data, simpleType.^list.itemType.localPart) == null ? (createGeneralization(model,newEnum,getCreateClassByName(data, schemaType, model, simpleType.^list.itemType.prefix, simpleType.^list.itemType.namespaceURI, simpleType.^list.itemType.localPart, package))) : null ->
			
			traceMe("<= ") ->
			
			newEnum)
		);
		
// creates an enumeration for an anonymous simple type and applies its stereotype values along with creating any generalisations it may have
cached uml::Type createEnumeration(ImportTransformationData data, Attribute parentAttribute, uml::Type enumType, SimpleType simpleType, SchemaType schemaType, uml::Model model, uml::Package package, List enumIDList, List enumValueList):    	
	traceMe("=> createEnumeration 4") ->
	enumType != null ? enumType : 
		(getAttributeName(data, parentAttribute) == null ? null : 
			(
			let newEnum = new uml::Enumeration :			
			newEnum.setPackage(package) ->		
			newEnum.setName(getAttributeName(data, parentAttribute)+"Type") ->
			setUniqueId(data, newEnum) ->
			setAnonStereotypeValue(newEnum, false) ->
			
			simpleType.restriction == null ? null : (
				applyPrimitiveStereotypeValues(newEnum, parentAttribute.name, simpleType.id, getFinalListValue(simpleType.final), simpleType.restriction.id, simpleType.restriction.base.prefix + ":" + simpleType.restriction.base.localPart) ->
				setOtherStereotypeValues(null, getSimpleTypeBasePart(data, parentAttribute, simpleType), null, newEnum, isSimpleType(data, simpleType.restriction))
			) ->
			simpleType.union == null ? null : (		
				let anonSimpleTypeNames = {} :	
				applyPrimitiveStereotypeValues(newEnum, parentAttribute.name, simpleType.id, getFinalListValue(simpleType.final), simpleType.union.id, null) ->
				simpleType.union.memberTypes.collect(e | parseUnion(data, schemaType, model, newEnum, e, package)) ->
				simpleType.union.simpleType.collect(e | parseUnionSimples(data, schemaType, model, newEnum, e, anonSimpleTypeNames)) ->
				applyXSDUnionMembers(data, newEnum, simpleType.union.memberTypes.toString(), anonSimpleTypeNames, schemaType.targetNamespace)
			) ->
			
			parseAnnotations(model, schemaType, simpleType.annotation, newEnum, package) ->
			
			createEnumerationLiteral(newEnum, enumIDList, enumValueList) ->
						
			isRootDocumentObject(data, schemaType, getAttributeName(data, parentAttribute)) && getSimpleTypeBasePart(data, simpleType.eContainer, simpleType) != null && getBOMPrimitiveType(data, getSimpleTypeBasePart(data, parentAttribute, simpleType)) == null ? (createGeneralization(model,newEnum,getCreateClassByName(data, schemaType, model, simpleType.^restriction.base.prefix, simpleType.^restriction.base.namespaceURI, getSimpleTypeBasePart(data, parentAttribute, simpleType), package))) : null ->
			isRootDocumentObject(data, schemaType, getAttributeName(data, parentAttribute)) && simpleType.^list.itemType.localPart != null && getBOMPrimitiveType(data, simpleType.^list.itemType.localPart) == null ? (createGeneralization(model,newEnum,getCreateClassByName(data, schemaType, model, simpleType.^list.itemType.prefix, simpleType.^list.itemType.namespaceURI, simpleType.^list.itemType.localPart, package))) : null ->
			
			traceMe("<= ") ->
			
			newEnum)
		);

// creates a primitive type for an attribute and applies its stereotype values along with creating any generalisations it may have
cached uml::Type createPrimitiveType(ImportTransformationData data, Attribute attribute, uml::Type primitiveType, SchemaType schemaType, uml::Model model, uml::Package package):    	
	traceMeDebug("=> createPrimitiveType 0 for attribute: "+attribute.name) ->
	primitiveType != null ? 
	(
		traceMeDebug("<= createPrimitiveType 0 for attribute: "+attribute.name) ->
		primitiveType 
	) :	(
		attribute.name == null ? null : 
			(
			let newPrim = createPrimitiveType() :
			newPrim.setPackage(package) ->		
			newPrim.setName(attribute.name) ->
			setUniqueId(data, newPrim) ->					
			attribute.type == null ? null : (
				let generalisation = (
					let tmpGeneralization = new uml::Generalization :	
					let type = getBOMPrimitiveType(data, getAttributeLocalPart(data, attribute)) :					
					tmpGeneralization.setGeneral(type) //->
					//setUndefinedRestrictions(newPrim)					
				) :				
				generalisation.general != null ? newPrim.generalization.add(generalisation) : null ->				
				applyPrimitiveStereotypeValues(newPrim, attribute.name, attribute.id, "", "", attribute.type.prefix + ":" + getAttributeLocalPart(data, attribute)) ->				
				setOtherStereotypeValues(null, getAttributeLocalPart(data, attribute), null, newPrim, isSimpleType(data, attribute.simpleType.restriction))				
			) ->				
			parseAnnotations(model, schemaType, attribute.annotation, newPrim, package) ->
			isRootDocumentObject(data, schemaType, newPrim.name) && getAttributeLocalPart(data, attribute) != null && getBOMPrimitiveType(data, getAttributeLocalPart(data, attribute)) == null ? (createGeneralization(model,newPrim,getCreateClassByName(data, schemaType, model, attribute.type.prefix, attribute.type.namespaceURI, getAttributeLocalPart(data, attribute), package))) :						
			
			traceMeDebug("<= createPrimitiveType 0 for attribute: "+attribute.name) ->
			
			newPrim)
		);

// creates a primitive type for an anonymous simple type and applies its stereotype values along with creating any generalisations it may have		
cached uml::Type createPrimitiveType(ImportTransformationData data, String name, uml::Type primitiveType, LocalSimpleType simpleType, SchemaType schemaType, uml::Model model, uml::Package package):    	
	traceMeDebug("=> createPrimitiveType 1 for name: "+name) ->

	primitiveType != null ? 
	(
		traceMeDebug("<= createPrimitiveType 1 for name: "+name) ->
		primitiveType 
	) : 
		(name == null ? null : 
			(
			let newPrim = createPrimitiveType() :			
			newPrim.setPackage(package) ->		
			newPrim.setName(name) ->
			setUniqueId(data, newPrim) ->				
			setAnonStereotypeValue(newPrim, false) ->
			simpleType.restriction == null ? null : (
				let generalisation = (
					setOtherStereotypeValues(null, getSimpleTypeBasePart(data, simpleType.eContainer, simpleType), null, newPrim, isSimpleType(data, simpleType.restriction)) ->
					getGeneralization(data, simpleType, schemaType, model, 1, newPrim, package)
				) : 
				generalisation.general != null ? newPrim.generalization.add(generalisation) : null ->
				applyPrimitiveStereotypeValues(newPrim, name, simpleType.id, getFinalListValue(simpleType.final), simpleType.restriction.id, simpleType.restriction.base.prefix + ":" + simpleType.restriction.base.localPart) //->
				//setUndefinedRestrictions(newPrim)								
			) ->
			simpleType.list == null ? null : (let generalisation = getGeneralization(data, simpleType, schemaType, model, 2, newPrim, package) : generalisation.general != null ? newPrim.generalization.add(generalisation) : null) ->
			simpleType.union == null ? null : (		
				let anonSimpleTypeNames = {} :	
				applyPrimitiveStereotypeValues(newPrim, name, simpleType.id, getFinalListValue(simpleType.final), simpleType.union.id, null) ->
				simpleType.union.memberTypes.collect(e | parseUnion(data, schemaType, model, newPrim, e, package)) ->
				simpleType.union.simpleType.collect(e | parseUnionSimples(data, schemaType, model, newPrim, e, anonSimpleTypeNames)) ->
				applyXSDUnionMembers(data, newPrim, simpleType.union.memberTypes.toString(), anonSimpleTypeNames, schemaType.targetNamespace)
			) ->
			
			parseAnnotations(model, schemaType, simpleType.annotation, newPrim, package) ->			
			
			isRootDocumentObject(data, schemaType, newPrim.name) && getSimpleTypeBasePart(data, simpleType.eContainer, simpleType) != null && getBOMPrimitiveType(data, getSimpleTypeBasePart(data, simpleType.eContainer, simpleType)) == null ? (createGeneralization(model,newPrim,getCreateClassByName(data, schemaType, model, simpleType.^restriction.base.prefix, simpleType.^restriction.base.namespaceURI, getSimpleTypeBasePart(data, simpleType.eContainer, simpleType), package))) : null ->
			isRootDocumentObject(data, schemaType, newPrim.name) && simpleType.^list.itemType.localPart != null && getBOMPrimitiveType(data, simpleType.^list.itemType.localPart) == null ? (createGeneralization(model,newPrim,getCreateClassByName(data, schemaType, model, simpleType.^list.itemType.prefix, simpleType.^list.itemType.namespaceURI, simpleType.^list.itemType.localPart, package))) : null ->
					
			traceMeDebug("<= createPrimitiveType 1 for name: "+name) ->
				
			newPrim)
		);
		
// creates a primitive type for a simple type and applies its stereotype values along with creating any generalisations it may have
cached uml::Type createPrimitiveType(ImportTransformationData data, uml::Type primitiveType, SimpleType simpleType, SchemaType schemaType, uml::Model model, uml::Package package):    	
	traceMeDebug("=> createPrimitiveType 2 for simpleType: "+getSimpleName(data, simpleType)) ->

	primitiveType != null ? 
	( 
		traceMeDebug("<= createPrimitiveType 2 for simpleType: "+getSimpleName(data, simpleType)) ->
		primitiveType 
	) : (
		getSimpleName(data, simpleType) == null ? null : 
			(
			let newPrim = createPrimitiveType() :
			newPrim.setPackage(package) ->		
			newPrim.setName(getSimpleName(data, simpleType)) ->
			setUniqueId(data, newPrim) ->				
			simpleType.restriction == null ? null : (
				let generalisation = (
					traceMe("createPrimitiveType()2: about to call setOtherStereotypeValues") ->
					setOtherStereotypeValues(null, getSimpleTypeBasePart(data, simpleType.eContainer, simpleType), null, newPrim, isSimpleType(data, simpleType.restriction)) ->
					getGeneralization(data, simpleType, schemaType, model, 1, newPrim, package) 
				): 
				generalisation.general != null ? newPrim.generalization.add(generalisation) : null ->
				applyPrimitiveStereotypeValues(newPrim, simpleType.name, simpleType.id, getFinalListValue(simpleType.final), simpleType.restriction.id, simpleType.restriction.base.prefix + ":" + simpleType.restriction.base.localPart) //->				
				
				//setUndefinedRestrictions(newPrim)				
			) ->
			simpleType.list == null ? null : (let generalisation = getGeneralization(data, simpleType, schemaType, model, 2, newPrim, package) : generalisation.general != null ? newPrim.generalization.add(generalisation) : null) ->			
			simpleType.union == null ? null : (		
				let anonSimpleTypeNames = {} :
				applyPrimitiveStereotypeValues(newPrim, simpleType.name, simpleType.id, getFinalListValue(simpleType.final), simpleType.union.id, null) ->
				simpleType.union.memberTypes.collect(e | parseUnion(data, schemaType, model, newPrim, e, package)) ->
				simpleType.union.simpleType.collect(e | parseUnionSimples(data, schemaType, model, newPrim, e, anonSimpleTypeNames)) ->
				applyXSDUnionMembers(data, newPrim, simpleType.union.memberTypes.toString(), anonSimpleTypeNames, schemaType.targetNamespace)
			) ->
			
			parseAnnotations(model, schemaType, simpleType.annotation, newPrim, package) ->
						
			isRootDocumentObject(data, schemaType, newPrim.name) && getSimpleTypeBasePart(data, simpleType.eContainer, simpleType) != null && getBOMPrimitiveType(data, getSimpleTypeBasePart(data, simpleType.eContainer, simpleType)) == null ? (createGeneralization(model,newPrim,getCreateClassByName(data, schemaType, model, simpleType.^restriction.base.prefix,  simpleType.^restriction.base.namespaceURI, getSimpleTypeBasePart(data, simpleType.eContainer, simpleType), package))) : null ->
			isRootDocumentObject(data, schemaType, newPrim.name) && simpleType.^list.itemType.localPart != null && getBOMPrimitiveType(data, simpleType.^list.itemType.localPart) == null ? (createGeneralization(model,newPrim,getCreateClassByName(data, schemaType, model, simpleType.^list.itemType.prefix, simpleType.^list.itemType.namespaceURI, simpleType.^list.itemType.localPart, package))) : null ->
			
			traceMeDebug("<= createPrimitiveType 2 for simpleType: "+getSimpleName(data, simpleType)) ->
						
			newPrim)
		);

// creates a primitive type for an anonymous simple type and applies its stereotype values along with creating any generalisations it may have		
cached uml::Type createPrimitiveType(ImportTransformationData data, Element parentElement, uml::Type primitiveType, SimpleType simpleType, SchemaType schemaType, uml::Model model, uml::Package package):
	traceMeDebug("=> createPrimitiveType 3 for parentElement: "+getElementName(data, parentElement)) ->
	primitiveType != null ? 
	(
		traceMeDebug("<= createPrimitiveType 3 for parentElement: "+getElementName(data, parentElement)) ->
		primitiveType 
	) : (
		getElementName(data, parentElement) == null ? null : 
			(
			let newPrim = createPrimitiveType() :			
			newPrim.setPackage(package) ->		
			newPrim.setName(getElementName(data, parentElement)+"Type") ->
			setUniqueId(data, newPrim) ->			
			setAnonStereotypeValue(newPrim, false) ->
			simpleType.restriction == null ? null : (
				let generalisation = getGeneralization(data, simpleType, schemaType, model, 1, newPrim, package) : 
				generalisation.general != null ? newPrim.generalization.add(generalisation) : null
			) ->
			simpleType.list == null ? null : (let generalisation = getGeneralization(data, simpleType, schemaType, model, 2, newPrim, package) : generalisation.general != null ? newPrim.generalization.add(generalisation) : null) ->
			simpleType.union == null ? null : (
				let anonSimpleTypeNames = {} :
				applyPrimitiveStereotypeValues(newPrim, parentElement.name, simpleType.id, getFinalListValue(simpleType.final), simpleType.union.id, null) ->
				simpleType.union.memberTypes.collect(e | parseUnion(data, schemaType, model, newPrim, e, package)) ->
				simpleType.union.simpleType.collect(e | parseUnionSimples(data, schemaType, model, newPrim, e, anonSimpleTypeNames)) ->
				applyXSDUnionMembers(data, newPrim, simpleType.union.memberTypes.toString(), anonSimpleTypeNames, schemaType.targetNamespace)				
			) ->
			
			parseAnnotations(model, schemaType, simpleType.annotation, newPrim, package) ->			
			
			isRootDocumentObject(data, schemaType, getElementName(data, parentElement)) && getSimpleTypeBasePart(data, simpleType.eContainer, simpleType) != null && getBOMPrimitiveType(data, getSimpleTypeBasePart(data, simpleType.eContainer, simpleType)) == null ? (createGeneralization(model,newPrim,getCreateClassByName(data, schemaType, model, simpleType.^restriction.base.prefix,simpleType.^restriction.base.namespaceURI, getSimpleTypeBasePart(data, simpleType.eContainer, simpleType), package))) : null ->
			isRootDocumentObject(data, schemaType, getElementName(data, parentElement)) && simpleType.^list.itemType.localPart != null && getBOMPrimitiveType(data, simpleType.^list.itemType.localPart) == null ? (createGeneralization(model,newPrim,getCreateClassByName(data, schemaType, model, simpleType.^list.itemType.prefix, simpleType.^list.itemType.namespaceURI, simpleType.^list.itemType.localPart, package))) : null ->
			
			traceMeDebug("<= createPrimitiveType 3 for parentElement: "+getElementName(data, parentElement)) ->
			
			newPrim)
		);		

// creates a primitive type for an anonymous simple type and applies its stereotype values along with creating any generalisations it may have		
cached uml::Type createPrimitiveType(ImportTransformationData data, Attribute parentAttribute, uml::Type primitiveType, SimpleType simpleType, SchemaType schemaType, uml::Model model, uml::Package package):
	traceMeDebug("=> createPrimitiveType 3 for parentAttribute: "+getAttributeName(data, parentAttribute)) ->

	primitiveType != null ? 
	(
		traceMeDebug("<= createPrimitiveType 3 for parentAttribute: "+getAttributeName(data, parentAttribute)) ->
	 	primitiveType 
	) :(
		getAttributeName(data, parentAttribute) == null ? null : 
			(
			let newPrim = createPrimitiveType() :			
			newPrim.setPackage(package) ->		
			newPrim.setName(getAttributeName(data, parentAttribute)+"Type") ->
			setUniqueId(data, newPrim) ->			
			setAnonStereotypeValue(newPrim, false) ->
			simpleType.restriction == null ? null : (
				let generalisation = getGeneralization(data, simpleType, schemaType, model, 1, newPrim, package) : 
				generalisation.general != null ? newPrim.generalization.add(generalisation) : null
			) ->
			simpleType.list == null ? null : (let generalisation = getGeneralization(data, simpleType, schemaType, model, 2, newPrim, package) : generalisation.general != null ? newPrim.generalization.add(generalisation) : null) ->
			simpleType.union == null ? null : (
				let anonSimpleTypeNames = {} :
				applyPrimitiveStereotypeValues(newPrim, parentAttribute.name, simpleType.id, getFinalListValue(simpleType.final), simpleType.union.id, null) ->
				simpleType.union.memberTypes.collect(e | parseUnion(data, schemaType, model, newPrim, e, package)) ->
				simpleType.union.simpleType.collect(e | parseUnionSimples(data, schemaType, model, newPrim, e, anonSimpleTypeNames)) ->
				applyXSDUnionMembers(data, newPrim, simpleType.union.memberTypes.toString(), anonSimpleTypeNames, schemaType.targetNamespace)				
			) ->
			
			parseAnnotations(model, schemaType, simpleType.annotation, newPrim, package) ->			
			
			isRootDocumentObject(data, schemaType, getAttributeName(data, parentAttribute)) && getSimpleTypeBasePart(data, simpleType.eContainer, simpleType) != null && getBOMPrimitiveType(data, getSimpleTypeBasePart(data, simpleType.eContainer, simpleType)) == null ? (createGeneralization(model,newPrim,getCreateClassByName(data, schemaType, model, simpleType.^restriction.base.prefix,simpleType.^restriction.base.namespaceURI, getSimpleTypeBasePart(data, simpleType.eContainer, simpleType), package))) : null ->
			isRootDocumentObject(data, schemaType, getAttributeName(data, parentAttribute)) && simpleType.^list.itemType.localPart != null && getBOMPrimitiveType(data, simpleType.^list.itemType.localPart) == null ? (createGeneralization(model,newPrim,getCreateClassByName(data, schemaType, model, simpleType.^list.itemType.prefix, simpleType.^list.itemType.namespaceURI, simpleType.^list.itemType.localPart, package))) : null ->
			
			traceMeDebug("<= createPrimitiveType 3 for parentAttribute: "+getAttributeName(data, parentAttribute)) ->
			
			newPrim)
		);			

// creates a generalisation from a restriction or list	
cached uml::Generalization getGeneralization(ImportTransformationData data, SimpleType simpleType, xmlSchema::SchemaType schemaType, uml::Model model, Integer simpleContentType, uml::Type primitiveType, Object package):
	traceMe("=>getGeneralization(): simpleContentType=" + simpleContentType) ->
	(
		let r = new uml::Generalization :
		
		simpleContentType == 1 ?
			(
				let gen1 = createRestriction(data, model, schemaType, r, simpleType, simpleType.restriction, primitiveType, (uml::Package)package):
				traceMe("<=getGeneralization(): Returning after createRestriction()") ->
				gen1
			) :
			(
				simpleContentType ==  2 ?
				(
					createList(data, model, r, simpleType)
				):
				(
					r
				)			
			)
					
		//switch(simpleContentType){
			//case 1: createRestriction(data, model, schemaType, r, simpleType, simpleType.restriction, primitiveType, (uml::Package)package) 
			//case 2: createList(data, model, r, simpleType)			
			//default: r		
		//}
		//traceMe("<=getGeneralization()")
	);

// looks at the memberTypes of each simple type union construct and creates a primitive type or fetches existing one and applies the appropriate stereotype
// indicating it is defined in a union member type.
cached parseUnion(ImportTransformationData data, SchemaType schemaType, uml::Model model, uml::Type dataType, QName unionQName, uml::Package package) :	
	let namespacePackage = getNamespacePackageFromURI(data, schemaType, model, unionQName.namespaceURI) :
	let simpleTypeName = unionQName.localPart :
	let schemaTypeWithSimple = getSchemaTypeForNamespaceURI(data, schemaType, unionQName.namespaceURI) :
	let unionDataType = (
		isKnownNamespace(unionQName.namespaceURI) == false ? (
			let simpleType = schemaTypeWithSimple.simpleType.select(e|e.name == simpleTypeName).first() :
			let newPrim = (			
				simpleType.restriction == null || (simpleType.restriction != null && (simpleType.restriction.enumeration == null || simpleType.restriction.enumeration.size == 0)) ? toPrimitiveType(data, simpleType, schemaType, model, namespacePackage) : (
					simpleType.restriction.enumeration != null && simpleType.restriction.enumeration.size > 0 ? toEnumeration(data, simpleType, schemaType, model, namespacePackage, simpleType.restriction.enumeration.id, simpleType.restriction.enumeration.value) : null
				)			
			) :
			newPrim		
		) : (
			let newPrim = createPrimitiveType() :
			let uniqueName = generateUniqueStandardUnionBaseTypeName(data, "UnionStandardBaseType", schemaType, {}) :
			newPrim.setPackage(package) ->		
			newPrim.setName(uniqueName) ->
			setUniqueId(data, newPrim) ->		
			(
				let generalisation = (
					let tmpGeneralization = new uml::Generalization :	
					let type = getBOMPrimitiveType(data, simpleTypeName) :					
					tmpGeneralization.setGeneral(type) ->
					tmpGeneralization			
				) :		
				generalisation.general != null ? newPrim.generalization.add(generalisation) : null ->
				applyPrimitiveStereotypeValues(newPrim, uniqueName, "", {}, "", unionQName.prefix + ":" + unionQName.localPart) ->		
				applyIsStandardUnionSimpleType(newPrim)		
			) ->
			newPrim						
		)
	) :
	let tmpProperty = new Property :
	tmpProperty.setName("memberType" + (dataType.ownedAttribute.size+1)) ->
	tmpProperty.setType(unionDataType) ->
	setUniqueId(data, tmpProperty) ->	
	dataType.ownedAttribute.add(tmpProperty);

// gives a unique name for a union base primitive type 	
generateUniqueStandardUnionBaseTypeName(ImportTransformationData data, String prefix, SchemaType schemaType, List prefixCountList) :
	prefixCountList.add(" ") ->
	// XPD-4034: identified here that an inappropriate list (parsedTopLevelElementSchemas because it was a list of string) was being used. 
	data.anonUnionSimpleTypeNames.contains(prefix+prefixCountList.size) || schemaType.simpleType.name.contains(prefix+prefixCountList.size) || schemaType.complexType.name.contains(prefix+prefixCountList.size) || schemaType.element.name.contains(prefix+prefixCountList.size) ? generateUniqueStandardUnionBaseTypeName(data, prefix, schemaType, prefixCountList) : (
		data.anonUnionSimpleTypeNames.add(prefix+prefixCountList.size) ->
		prefix+prefixCountList.size
	);	

// gives a unique name for a primtiive type representing an anonymous simple type in a union
generateUniqueUnionSimpleTypeName(ImportTransformationData data, String prefix, SchemaType schemaType, List prefixCountList) :	
	prefixCountList.add(" ") ->
	// XPD-4034: identified here that an inappropriate list (parsedTopLevelElementSchemas because it was a list of string) was being used. 
	data.anonUnionSimpleTypeNames.contains(prefix+prefixCountList.size) || schemaType.simpleType.name.contains(prefix+prefixCountList.size) || schemaType.complexType.name.contains(prefix+prefixCountList.size) || schemaType.element.name.contains(prefix+prefixCountList.size) ? generateUniqueUnionSimpleTypeName(data, prefix, schemaType, prefixCountList) : (
		data.anonUnionSimpleTypeNames.add(prefix+prefixCountList.size) ->
		prefix+prefixCountList.size
	);	

// parses all anonymous simple types in a union and creates stereotyped valued primitive types	
cached parseUnionSimples(ImportTransformationData data, SchemaType schemaType, uml::Model model, uml::Type dataType, LocalSimpleType simpleType, List anonSimpleTypeNames) :
	data.parsedAnonUnionSimpleTypeKeys.contains(simpleType) ? anonSimpleTypeNames.add(data.getParsedAnonUnionSimpleTypeValue(simpleType)) : (
		let uniqueSimpleTypeName = generateUniqueUnionSimpleTypeName(data, "UnionSimpleType", schemaType, {}) :
		let tmpPackage = getNamespacePackageFromURI(data, schemaType, model, schemaType.targetNamespace) :	
		let newPrim = (		
			simpleType.restriction == null || (simpleType.restriction != null && (simpleType.restriction.enumeration == null || simpleType.restriction.enumeration.size == 0)) ? toPrimitiveType(data, uniqueSimpleTypeName, simpleType, schemaType, model, tmpPackage) : (
				simpleType.restriction.enumeration != null && simpleType.restriction.enumeration.size > 0 ? toEnumeration(data, uniqueSimpleTypeName, simpleType, schemaType, model, tmpPackage, simpleType.restriction.enumeration.id, simpleType.restriction.enumeration.value) : null
			)			
		) :
		anonSimpleTypeNames.add(uniqueSimpleTypeName) ->
		newPrim != null ? (			
			let tmpProperty = new Property :
			tmpProperty.setName("memberType" + (dataType.ownedAttribute.size+1)) ->
			tmpProperty.setType(newPrim) ->
			setUniqueId(data, tmpProperty) ->	
			dataType.ownedAttribute.add(tmpProperty) ->
			applyIsAnonUnionSimpleType(newPrim)		
		) : null ->
		data.addParsedAnonUnionSimpleType(simpleType, uniqueSimpleTypeName)
	);
	
// applies the xsd stereotype values on a given generalisation and sets the uml type also
uml::Generalization createRestriction(ImportTransformationData data, uml::Model model, SchemaType schemaType, uml::Generalization generalization, SimpleType simpleType, RestrictionType1 restriction, uml::DataType primitiveType, uml::Package package):	
	traceMe("=>createRestriction(): primitiveType=" + primitiveType.name) ->
	(
		let baseType = getSimpleTypeBasePart(data, simpleType.eContainer, simpleType):
		let type = getBOMPrimitiveType(data, baseType) :
		let maxLengthFromRestriction = (
			restriction.maxLength.first().value != null ? restriction.maxLength.first().value : restriction.length.first().value
		) :
		let maxValue = _getActualLengthFromRestrictionForSimpleType(data, baseType, maxLengthFromRestriction) :
		type == null ? (
			let tmpType = getPrimitiveTypeByName(data, model, getNamespacePackageFromURI(data, schemaType, package, simpleType.restriction.base.namespaceURI), getSimpleTypeBasePart(data, simpleType.eContainer, simpleType), true) :			
			tmpType != null ? generalization.setGeneral(tmpType) : null ->
			createRestriction(data, package, tmpType, primitiveType, restriction.id, restriction.enumeration.value, restriction.whiteSpace.value, restriction.length.value, restriction.maxExclusive.value, restriction.maxInclusive.value, restriction.maxLength.value, restriction.minExclusive.value, restriction.minInclusive.value, restriction.minLength.value, restriction.pattern.value, restriction.base.localPart, isSimpleType(data, restriction)) ->			
			
			setOtherMaxLengthValues(primitiveType, restriction.maxLength.first().id, restriction.maxLength.first().fixed, maxValue, tmpType) ->		
			setOtherFractionDigitsValues(primitiveType, restriction.fractionDigits.first().id, restriction.fractionDigits.first().fixed, restriction.fractionDigits.first().value, tmpType) ->		
			setOtherLengthValues(primitiveType, restriction.length.first().id, restriction.length.first().fixed, restriction.length.first().value, tmpType) -> 		
			setOtherMaxExclusiveValues(primitiveType, restriction.maxExclusive.first().id, restriction.maxExclusive.first().fixed, restriction.maxExclusive.first().value, tmpType) -> 
			setOtherMaxInclusiveValues(primitiveType, restriction.maxInclusive.first().id, restriction.maxInclusive.first().fixed, restriction.maxInclusive.first().value, tmpType) -> 
			setOtherMinExclusiveValues(primitiveType, restriction.minExclusive.first().id, restriction.minExclusive.first().fixed, restriction.minExclusive.first().value, tmpType) -> 
			setOtherMinInclusiveValues(primitiveType, restriction.minInclusive.first().id, restriction.minInclusive.first().fixed, restriction.minInclusive.first().value, tmpType) -> 
			setOtherMinLengthValues(primitiveType, restriction.minLength.first().id, restriction.minLength.first().fixed, restriction.minLength.first().value, tmpType) -> 
			setOtherPatternValues(primitiveType, restriction.pattern.first().id, restriction.pattern.first().fixed, restriction.pattern.first().value, tmpType) -> 
			setOtherTotalDigitsValues(primitiveType, restriction.totalDigits.first().id, restriction.totalDigits.first().fixed, restriction.totalDigits.first().value, tmpType) -> 
			setOtherWhitespaceValues(primitiveType, restriction.whiteSpace.first().id, restriction.whiteSpace.first().fixed, restriction.whiteSpace.first().value, tmpType) ->
			
			traceMe("<==createRestriction(): when type is NULL") ->
			generalization 
		) : (
				generalization.setGeneral(type) -> 
				createRestriction(data, package, type, primitiveType, restriction.id, restriction.enumeration.value, restriction.whiteSpace.value, restriction.length.value, restriction.maxExclusive.value, restriction.maxInclusive.value, restriction.maxLength.value, restriction.minExclusive.value, restriction.minInclusive.value, restriction.minLength.value, restriction.pattern.value, restriction.base.localPart, isSimpleType(data, restriction)) ->
				
				setOtherMaxLengthValues(primitiveType, restriction.maxLength.first().id, restriction.maxLength.first().fixed, maxValue, type) ->		
				setOtherFractionDigitsValues(primitiveType, restriction.fractionDigits.first().id, restriction.fractionDigits.first().fixed, restriction.fractionDigits.first().value, type) ->		
				setOtherLengthValues(primitiveType, restriction.length.first().id, restriction.length.first().fixed, restriction.length.first().value, type) -> 		
				setOtherMaxExclusiveValues(primitiveType, restriction.maxExclusive.first().id, restriction.maxExclusive.first().fixed, restriction.maxExclusive.first().value, type) -> 
				setOtherMaxInclusiveValues(primitiveType, restriction.maxInclusive.first().id, restriction.maxInclusive.first().fixed, restriction.maxInclusive.first().value, type) -> 
				setOtherMinExclusiveValues(primitiveType, restriction.minExclusive.first().id, restriction.minExclusive.first().fixed, restriction.minExclusive.first().value, type) -> 
				setOtherMinInclusiveValues(primitiveType, restriction.minInclusive.first().id, restriction.minInclusive.first().fixed, restriction.minInclusive.first().value, type) -> 
				setOtherMinLengthValues(primitiveType, restriction.minLength.first().id, restriction.minLength.first().fixed, restriction.minLength.first().value, type) -> 
				setOtherPatternValues(primitiveType, restriction.pattern.first().id, restriction.pattern.first().fixed, restriction.pattern.first().value, type) -> 
				setOtherTotalDigitsValues(primitiveType, restriction.totalDigits.first().id, restriction.totalDigits.first().fixed, restriction.totalDigits.first().value, type) -> 
				setOtherWhitespaceValues(primitiveType, restriction.whiteSpace.first().id, restriction.whiteSpace.first().fixed, restriction.whiteSpace.first().value, type) -> 
			
				traceMe("<==createRestriction(): when type is NOT NULL") ->
				generalization
			)
	);
	
// applies the uml type of a list on the primitive type	
uml::Generalization createList(ImportTransformationData data, uml::Model model, uml::Generalization generalization, SimpleType simpleType):
	traceMe("=> createList") ->
	(
		let type = getBOMPrimitiveType(data, simpleType.list.itemType.localPart) :	
		type == null ? generalization : 
			(generalization.setGeneral(type) ->
			generalization)
	);	

// returns true if namespace is a standard w3 url	
Boolean isKnownNamespace(String namespace) :
	traceMe("=> isKnownNamespace") ->	
	(
		let isKnown = (
						namespace == "http://www.w3.org/XML/1998/namespace" || 
						namespace == "http://www.w3.org/2001/XMLSchema" ||
						namespace.contains("www.w3.org") //||
						//namespace.contains("www.wfmc.org")
						) :
		isKnown == true ? (
			traceMe("<= isKnownNamespace: true") ->
			isKnown
		) : (
			traceMe("<= isKnownNamespace: false") ->
			isKnown
		)						
	);

// returns a package with the name matched to the resolved prefix parameter ie tns might be package1
uml::Package getNamespacePackage(ImportTransformationData data, SchemaType schemaType, uml::Package package, String prefix) :
	traceMe("=> getNamespacePackage") ->
	(
		let isXmlSchemaDocRootType = XmlSchemaDocumentRoot.isInstance(schemaType.eContainer) :
		isXmlSchemaDocRootType == true ? ( 
			let xmlSchemaDocumentRoot = (XmlSchemaDocumentRoot)schemaType.eContainer : 
			let mappedNamespaceFromPrefix = xmlSchemaDocumentRoot.xMLNSPrefixMap.get(prefix) : 
			let resolvedPackageNamespace = data.getResolvedPackageNamespace(mappedNamespaceFromPrefix) :	
			(prefix == null || prefix.trim().length == 0 || isKnownNamespace(mappedNamespaceFromPrefix)) ? (
				let resolvedPackageNamespace = data.getResolvedPackageNamespace(schemaType.targetNamespace) :				
				resolvedPackageNamespace == null ? package : findPackage(data, package, resolvedPackageNamespace)				
			) : findPackage(data, package, resolvedPackageNamespace)
		) : (		 
			let mappedNamespaceFromPrefix = data.parentPrefixMap.get(prefix) :
			let resolvedPackageNamespace = data.getResolvedPackageNamespace(mappedNamespaceFromPrefix) :	
			resolvedPackageNamespace != null ? (
			(prefix == null || prefix.trim().length == 0 || isKnownNamespace(mappedNamespaceFromPrefix)) ? (
					let resolvedPackageNamespace = data.getResolvedPackageNamespace(schemaType.targetNamespace) :
					resolvedPackageNamespace == null ? package : findPackage(data, package, resolvedPackageNamespace)		
				) : findPackage(data, package, resolvedPackageNamespace)		
			) : (
				let tmpMappedNamespaceFromPrefix = data.innerWSDLSchemaPrefixMap.get(prefix) :
				let tmpResolvedPackageNamespace = data.getResolvedPackageNamespace(tmpMappedNamespaceFromPrefix) :
				(prefix == null || prefix.trim().length == 0 || isKnownNamespace(tmpMappedNamespaceFromPrefix)) ? (
					let resolvedPackageNamespace = data.getResolvedPackageNamespace(schemaType.targetNamespace) :
					resolvedPackageNamespace == null ? package : findPackage(data, package, resolvedPackageNamespace)	
				) : findPackage(data, package, tmpResolvedPackageNamespace)
			)		
		)
	);

// gets a package from the namespace uri provided
uml::Package getNamespacePackageFromURI(ImportTransformationData data, SchemaType schemaType, uml::Package package, String namespaceURI) :
	traceMe("=> getNamespacePackageFromURI") ->
	(
		let packageName = data.getResolvedPackageNamespace(namespaceURI) :
		let existingModel = data.otherResultModels.selectFirst(e|e.name==packageName) :
		existingModel != null ? existingModel : (
			let tmpPackage = (			
				let existingPackage = findPackage(data, package, packageName) :		
				existingPackage
			) :
			tmpPackage
		)
	);	

// looks at all nested packages to see if package exists with the packageNS provided	
cached uml::Package findNestedPackage(List nestedPackages, String packageNS, List foundPackages) : 
	traceMe("=> findNestedPackage" + packageNS) ->
	(
		let foundPackage = nestedPackages.typeSelect(uml::Package).select(e|e.name == packageNS).first() :
		foundPackage != null ? (
			foundPackages.add(foundPackage) ->
			foundPackage
		) : 
		(
			let tmpFoundPackage = nestedPackages.typeSelect(uml::Package).select(e|findNestedPackage(e.nestedPackage, packageNS, foundPackages)).select(e|e != null).first() :
			tmpFoundPackage != null ? foundPackages.add(tmpFoundPackage) : null ->
			traceMe("tmpFoundPackage "+tmpFoundPackage) ->
			tmpFoundPackage  
		)
	);	

// looks at all parent packages to see if package exists with the packageNS provided
uml::Package findInParentPackage(uml::Package parentPackage, String packageNS) : 
	traceMe("=>findInParentPackage(): packageNS=" + packageNS) ->
	parentPackage != null ? 
		(
			parentPackage.name == packageNS ? parentPackage : findInParentPackage(parentPackage.nestingPackage, packageNS)			
		)
		:
		(
			traceMe("<=findInParentPackage(): packageNS=" + packageNS + " NOT FOUND") ->
			null
		);		

// looks at both nested and parent packages to find the package that relates to the packageNS given
uml::Package findPackage(ImportTransformationData data, uml::Package package, String packageNS) : 
	traceMe("=> findPackage for "+ packageNS) ->
	traceMe("starting package " + package.name) ->
	(
		// XPD-4041: find the package in the map (I think in case of xsd2bom transformation there cant exist any nested packages
		// so the whole thing that was being done here might be incorrect. So ideally there should never be a situation
		// when it can't find a package in the map!
		let existingModel = data.otherResultModels.selectFirst(e|e.name==packageNS) :
		traceMe("existingModel = " + existingModel)->
		existingModel != null ? existingModel : (
				
			traceMeDebug("findPackage(pkgName='"+package.name+"', pkgNS='"+packageNS+ "') :: not found in existing model cache")->
			(
				let tempPackage = findInParentPackage(package.nestingPackage, packageNS) :
				traceMe("111 found " + tempPackage) ->
				tempPackage != null ? tempPackage : 
				(
					let tempPackages = {} :
					findNestedPackage(package.nestedPackage, packageNS, tempPackages) ->
					traceMe("222 found " + tempPackages) ->
					tempPackages.first() != null ? tempPackages.first() : package
				)
			)		
		)// end of existingModel != null
	);

// creates a class of type another class
cached uml::Class toClassWithType(ImportTransformationData data, Element element, SchemaType schemaType, uml::Model model, uml::Class ownerClass, uml::Package package):	
	traceMe("=> toClassWithType " +getElementName(data, element)) ->
	(
		// XPD-3939: when class name and element name in the class are same then 
		// find the class by local part of the element rather than element name
		ownerClass.name == element.name ? (
			let clsNameToSearch = getClassByName(data, package, getElementLocalPart(data, element), null, true) :
			let tempClass = createClassWithType(data, clsNameToSearch, element, schemaType, model, ownerClass, package) :
			tempClass
		) : (
			let clsNameToSearch = getClassByName(data, package, getElementName(data, element), null, true) :
			let tempClass = createClassWithType(data, clsNameToSearch, element, schemaType, model, ownerClass, package) :
			tempClass
		)		
	);

// creates a class for an anonymous complex type 
cached uml::Class toClass(ImportTransformationData data, ComplexType complexType, SchemaType schemaType, uml::Model model, String anonymousComplexTypeName, uml::Package package):
	traceMe("=>toClass(): 1 ") ->
	getComplexName(data, complexType) == null && anonymousComplexTypeName == null ? null :
	(	
		let tempClass = getClassByName(data, package, getComplexName(data, complexType), anonymousComplexTypeName, false) :
		( 
			let tempClass = createClass(data, tempClass, complexType, schemaType, model, anonymousComplexTypeName, package) :
			tempClass
		)
	);
	
// creates a class for an anonymous complex type
cached uml::Class toClass(ImportTransformationData data, Element parentElement, ComplexType complexType, SchemaType schemaType, uml::Model model, uml::Package package): 
	traceMe("=> toClass 2 "+ getElementName(data, parentElement)) ->
	(
		let tempClass = null : //getClassByName(data, package, getElementName(data, parentElement), null, true) : 
		let tempClass = createClass(data, parentElement, tempClass, complexType, schemaType, model, package) :	
		tempClass
	);

// creates a class for and a type this is assocaited with an element 
cached uml::Class toClass(ImportTransformationData data, Element element, SchemaType schemaType, uml::Model model, uml::Package package):	
	traceMe("=> toClass 3") ->
	(
		let typeClass = (
			element.type == null ? null : getClassByName(data, package, getElementLocalPart(data, element), null, true) 
		) :
		typeClass
	);
	
// creates a class with a type defined from element constuct
cached uml::Class createClassWithType(ImportTransformationData data, uml::Class tempClass, Element element, SchemaType schemaType, uml::Model model, uml::Class ownerClass, uml::Package package):		
	traceMeDebug("=> createClassWithType tempClass = " + tempClass) ->
	tempClass != null ? (		
		createComposition(data, package, ownerClass, tempClass, ownerClass.name, getElementName(data, element), element.minOccurs.toString(), element.maxOccurs.toString(),element.name, element.form.toString(), element.^default, element.id, element.fixed, element.nillable.toString(), getBlockListValue(element.block)) -> //REMOVE
		traceMeDebug("<= createClassWithType tempClass = " + tempClass) ->
		tempClass 
	) : 
	(	
		//let r = new uml::Class :
		let schemaTypeForPrefix = getSchemaTypeForNamespaceURI(data, schemaType,element.type.namespaceURI) :		
		let namespacePackage = (			
			let packageName = data.getResolvedPackageNamespace(element.type.namespaceURI) :
			let existingModel = data.otherResultModels.selectFirst(e|e.name==packageName) :
			existingModel != null ? existingModel : (
				let existingPackage = findPackage(data, model, packageName) :		
				existingPackage != null ? existingPackage : package
			)
		) :		
		let containedClass = (
			let tmpContainedCls = getCreateClassByName(data, schemaTypeForPrefix, model, element.type.prefix,element.type.namespaceURI, getElementLocalPart(data, element), namespacePackage) :  ////REMOVE		
			tmpContainedCls != null ? tmpContainedCls : (
				let tmpContainedCls2 = getCreateClassByName(data, schemaTypeForPrefix, model, element.type.prefix, element.type.namespaceURI, element.type.localPart, namespacePackage) :
				//XPD-5138: XSD-BOM unable to cope when the attribute in a complex type refers to a Simple Type in a different package that has same name as the complex type
				tmpContainedCls2 != null ? tmpContainedCls2 : _getClassByNameExt(data, namespacePackage, getElementLocalPart(data, element), true) 
			)
		) :
		
		parseAnnotations(model, schemaType, element.annotation, containedClass, package) ->
		createComposition(data, package, ownerClass, containedClass, ownerClass.name, getElementName(data, element), element.minOccurs.toString(), element.maxOccurs.toString(), element.name, element.form.toString(), element.^default, element.id, element.fixed, element.nillable.toString(), getBlockListValue(element.block)) -> //REMOVE
		
		traceMeDebug("<= createClassWithType tempClass=" + tempClass + " containedClass="+containedClass) ->
		
		containedClass); /// REMOVE
	
// works out tree order structure for all, sequence and choice constructs and applies them to the attribute and top level container
cached calculateExplicitGroupTrees(ImportTransformationData data, uml::Class tempClass, ComplexType complexType, SchemaType schemaType, uml::Model model, uml::Package package) :
	complexType.group == null ? 
		(
			// XPD-3647: group is not directly under complex type but under complex type restriction. 
			// So to add sequence details (xsdSequenceList) stereotype information for a group under complex type restriction; 
			// extracting the group ref from restriction and creating the required info.
			// ideally i would imagine to do this in a more generic way by refactoring the code, but to avoid any regressions at this point 
			// i have repeated some bits of code for groups under complex type restriction 
		
			let comResType = complexType.complexContent.^restriction :
			comResType.eContents.collect(e |
				(GroupRef.isInstance(e) == true) ? (
						let typeList = {} :
						let tmpExplicitGroup  = extractGroupExplicitGroup(data, e, typeList) :
						typeList.contains("S") ? (
							parseSequence(data, model, schemaType, tmpExplicitGroup, tempClass, package, 1, 1) ->
							(
								let explicitGroupTree = createString(data, schemaType, tempClass, complexType, tmpExplicitGroup, {"S,|"}).toString().replaceAll("\\[", "").replaceAll("\\]","").replaceAll(" ","").trim() :
								let tmpCount = {""} : 
								tmpExplicitGroup.eContents.collect(e | (				
											parseElementOrGroupInExplicitGroup(data, schemaType, tempClass, complexType, e, {"S"}, tmpCount.size) ->
											tmpCount.add("")
										)
								) 	
							)
						) : (
							typeList.contains("C") ? (
								parseChoice(data, model, schemaType, tmpExplicitGroup, tempClass, package, 1, 1) ->
								(
									let explicitGroupTree = createString(data, schemaType, tempClass, complexType, tmpExplicitGroup, {"C,|"}).toString().replaceAll("\\[", "").replaceAll("\\]","").replaceAll(" ","").trim() :
									let tmpCount = {""} : 
									tmpExplicitGroup.eContents.collect(e | (				
												parseElementOrGroupInExplicitGroup(data, schemaType, tempClass, complexType, e, {"C"}, tmpCount.size) ->
												tmpCount.add("")
											)
									)
								)							
							) : null
						)
					) : ( // if e is not an instanceof group ref return null
						null
					)
			) // close of comResType contents
		) : // complexType.group is not null
		(
			let typeList = {} :
			let tmpExplicitGroup  = extractGroupExplicitGroup(data, complexType.group, typeList) :	
			
			typeList.contains("A") ? (				
				parseAll(data, model, schemaType, tmpExplicitGroup, tempClass, package, 1, 1) ->
				(
					let explicitGroupTree = createString(data, schemaType, tempClass, complexType, tmpExplicitGroup, {"A,|"}).toString().replaceAll("\\[", "").replaceAll("\\]","").replaceAll(" ","").trim() :
					let tmpCount = {""} : 
					tmpExplicitGroup.eContents.collect(e | (				
								parseElementOrGroupInExplicitGroup(data, schemaType, tempClass, complexType, e, {"A"}, tmpCount.size) ->
								tmpCount.add("")
							)
					)	
				)
			) : (
				typeList.contains("S") ? (				
					parseSequence(data, model, schemaType, tmpExplicitGroup, tempClass, package, 1, 1) ->
					(
						let explicitGroupTree = createString(data, schemaType, tempClass, complexType, tmpExplicitGroup, {"S,|"}).toString().replaceAll("\\[", "").replaceAll("\\]","").replaceAll(" ","").trim() :
						let tmpCount = {""} : 
						tmpExplicitGroup.eContents.collect(e | (				
									parseElementOrGroupInExplicitGroup(data, schemaType, tempClass, complexType, e, {"S"}, tmpCount.size) ->
									tmpCount.add("")
								)
						) 	
					)
				) : (
					typeList.contains("C") ? (					
						parseChoice(data, model, schemaType, tmpExplicitGroup, tempClass, package, 1, 1) ->
						(
							let explicitGroupTree = createString(data, schemaType, tempClass, complexType, tmpExplicitGroup, {"C,|"}).toString().replaceAll("\\[", "").replaceAll("\\]","").replaceAll(" ","").trim() :
							let tmpCount = {""} : 
							tmpExplicitGroup.eContents.collect(e | (				
										parseElementOrGroupInExplicitGroup(data, schemaType, tempClass, complexType, e, {"C"}, tmpCount.size) ->
										tmpCount.add("")
									)
							)
						)
					) : null
				)	
			)
		) ->			
		complexType.sequence != null ? (
			let explicitGroupTree = createString(data, schemaType, tempClass, complexType, complexType.sequence, {"S,|"}).toString().replaceAll("\\[", "").replaceAll("\\]","").replaceAll(" ","").trim() :
			let tmpCount = {""} : 
			complexType.sequence.eContents.collect(e | (				
						parseElementOrGroupInExplicitGroup(data, schemaType, tempClass, complexType, e, {"S"}, tmpCount.size) ->
						tmpCount.add("")
					)
			) 		
		) : null ->
		complexType.complexContent.^extension.sequence != null || complexType.complexContent.^restriction.sequence != null ? (
			let tmpExplicitGroup = (
				complexType.complexContent.^extension.sequence != null ? complexType.complexContent.^extension.sequence : complexType.complexContent.^restriction.sequence
			) :
			let explicitGroupTree = createString(data, schemaType, tempClass, complexType, tmpExplicitGroup, {"S,|"}).toString().replaceAll("\\[", "").replaceAll("\\]","").replaceAll(" ","").trim() :
			let tmpCount = {""} : 
			tmpExplicitGroup.eContents.collect(e | (				
						parseElementOrGroupInExplicitGroup(data, schemaType, tempClass, complexType, e, {"S"}, tmpCount.size) ->
						tmpCount.add("")
					)
			)  		
		) : null ->
		complexType.choice != null ? (
			let explicitGroupTree = createString(data, schemaType, tempClass, complexType, complexType.choice, {"C,|"}).toString().replaceAll("\\[", "").replaceAll("\\]","").replaceAll(" ","").trim() :
			let tmpCount = {""} : 
			complexType.choice.eContents.collect(e | (				
						parseElementOrGroupInExplicitGroup(data, schemaType, tempClass, complexType, e, {"C"}, tmpCount.size) ->
						tmpCount.add("")
					)
			)			
		) : null ->		
		complexType.complexContent.^extension.choice != null || complexType.complexContent.^restriction.choice != null ? (
			let tmpExplicitGroup = (
				complexType.complexContent.^extension.choice != null ? complexType.complexContent.^extension.choice : complexType.complexContent.^restriction.choice
			) :
			let explicitGroupTree = createString(data, schemaType, tempClass, complexType, tmpExplicitGroup, {"C,|"}).toString().replaceAll("\\[", "").replaceAll("\\]","").replaceAll(" ","").trim() :
			let tmpCount = {""} : 
			tmpExplicitGroup.eContents.collect(e | (				
						parseElementOrGroupInExplicitGroup(data, schemaType, tempClass, complexType, e, {"C"}, tmpCount.size) ->
						tmpCount.add("")
					)
			)			
		) : null ->
		complexType.all != null ? (
			let explicitGroupTree = createString(data, schemaType, tempClass, complexType, complexType.all, {"A,|"}).toString().replaceAll("\\[", "").replaceAll("\\]","").replaceAll(" ","").trim() :
			let tmpCount = {""} : 
			complexType.all.eContents.collect(e | (				
						parseElementOrGroupInExplicitGroup(data, schemaType, tempClass, complexType, e, {"A"}, tmpCount.size) ->
						tmpCount.add("")
					)
			)			
		) : null ->		
		complexType.complexContent.^extension.all != null || complexType.complexContent.^restriction.all != null ? (
			let tmpAll = (
				complexType.complexContent.^extension.all != null ? complexType.complexContent.^extension.all : complexType.complexContent.^restriction.all
			) :
			let explicitGroupTree = createString(data, schemaType, tempClass, complexType, tmpAll, {"A,|"}).toString().replaceAll("\\[", "").replaceAll("\\]","").replaceAll(" ","").trim() :
			let tmpCount = {""} : 
			tmpAll.eContents.collect(e | (				
						parseElementOrGroupInExplicitGroup(data, schemaType, tempClass, complexType, e, {"A"}, tmpCount.size) ->
						tmpCount.add("")
					)
			)			
		) : null;

// creates a class to represent a complexType and then parses all its explicit group elements and attributes and adds to the class container as a property
cached uml::Class createClass(ImportTransformationData data, uml::Class tempClass, ComplexType complexType, SchemaType schemaType, uml::Model model, String anonymousComplexTypeName, uml::Package package):
	traceMeDebug("=> createClass "+ tempClass + " for complex " + complexType.name + " anonymousComplexTypeName = "+anonymousComplexTypeName) ->	
	tempClass != null ? 
		( 	
			traceMeDebug("<= createClass "+ tempClass + " for complex " + complexType.name + " anonymousComplexTypeName = "+anonymousComplexTypeName) ->	
			tempClass 
		 ) : (
		let r = (
			getComplexName(data, complexType) != null ? createClass(getComplexName(data, complexType), package) : 
				(anonymousComplexTypeName != null ? createAnonymousClass(anonymousComplexTypeName, package) : createClass("", package))						
		) :		
		
		// XPD-4386: modified this method in TransformHelper to support mixed construct
		applyClassStereotypeValues(r, complexType, complexType.complexContent, complexType.name, complexType.id, complexType.mixed.toString(), complexType.complexContent.mixed.toString(), getBlockListValue(complexType.block), getFinalListValue(complexType.final), complexType.abstract.toString(), true, false, false) ->

		setUniqueId(data, r) ->
		
		r.ownedAttribute.size == 0 ? (
			parseAttributeOrAttributeGroups(data, model, schemaType, complexType, r, package) ->		
			parseAll(data, model, schemaType, complexType.all, r, package, 1, 1) ->
			parseAll(data, model, schemaType, complexType.complexContent.^extension.all, r, package, 1, 1) ->		
			parseAll(data, model, schemaType, complexType.complexContent.^restriction.all, r, package, 1, 1) ->
			parseSequence(data, model, schemaType, complexType.sequence, r, package, 1, 1) ->		
			parseSequence(data, model, schemaType, complexType.complexContent.^extension.sequence, r, package, 1, 1) ->
			parseSequence(data, model, schemaType, complexType.complexContent.^restriction.sequence, r, package, 1, 1) ->
			parseChoice(data, model, schemaType, complexType.choice, r, package, 1, 1) ->		
			parseChoice(data, model, schemaType, complexType.complexContent.^extension.choice, r, package, 1, 1) ->
			parseChoice(data, model, schemaType, complexType.complexContent.^restriction.choice, r, package, 1, 1) ->
			
			calculateExplicitGroupTrees(data, r, complexType, schemaType, model, package)
		) : null ->
		
		parseAnnotations(model, schemaType, complexType.annotation, r, package) ->
		
		r.generalization.size == 0 ? (
			complexType.complexContent.^extension.base.localPart != null || complexType.complexContent.^restriction.base.localPart != null ? (
				let tmpExtensionOrRestriction = (
					complexType.complexContent.^extension != null ? complexType.complexContent.^extension : (
						setClassRestriction(r) ->
						complexType.complexContent.^restriction
					)
				) :
				let complexContentPart = getElementComplexContentPart(data, complexType) :
				let tmpCls = (
					complexType.name != null || anonymousComplexTypeName == null ? ( 
						let tmpyCls = getCreateClassByName(data, schemaType, model, tmpExtensionOrRestriction.base.prefix, tmpExtensionOrRestriction.base.namespaceURI, complexContentPart, package) :						
						tmpyCls != null ? tmpyCls : getCreateClassByName(data, schemaType, model, tmpExtensionOrRestriction.base.prefix,tmpExtensionOrRestriction.base.namespaceURI, tmpExtensionOrRestriction.base.localPart, package)
					) : (
						let schemaTypeWithComplex = getSchemaTypeForNamespaceURI(data, schemaType, tmpExtensionOrRestriction.base.namespaceURI) :
						let targetComplex = schemaTypeWithComplex.complexType.select(e|e.name == complexContentPart).first()  :			
						let tmpPackage = (			
							let packageName = data.getResolvedPackageNamespace(tmpExtensionOrRestriction.base.namespaceURI) :
							let existingModel = data.otherResultModels.selectFirst(e|e.name==packageName) :
							existingModel != null ? existingModel : (
								let existingPackage = findPackage(data, model, packageName) :		
								existingPackage != null ? existingPackage : package
							)
						) :
						// XPD-3229 - in this scenario the complex type being used in generalisation is not yet created, 
						// and we are setting the flag lookInOtherPackages to true. 
						// other package also has a complex type with the same name so it is setting the reference to an incorrect class from the other package 
						
						// XPD-3229 - fix by passing false for lookInOtherPackages. 
						// (Ideally I would think to find the tmpCls based on the package and namespace uri and prefix; 
						// instead of relying on the boolean whether to lookInOtherPackages or not) i think Sid expressed the same opinion when reviewed my changes. but leaving this fix for now!
						
						let tmpCls = getClassByName(data, tmpPackage, complexContentPart, null, false) :
													
						tmpCls != null ? tmpCls : (
							// XPD-3229 - fix by passing false for lookInOtherPackages	
							let tmpCls2 = getClassByName(data, tmpPackage, tmpExtensionOrRestriction.base.localPart, null, false) :						
							tmpCls2 != null ? tmpCls2 : createClass(data, null, targetComplex, schemaTypeWithComplex, model, null, tmpPackage)
						)
					)
				) :			
				createGeneralization(model,r,tmpCls)
			) : null ->
			complexType.group.ref.localPart != null ? createGeneralization(model,r,getCreateClassByName(data, schemaType, model, complexType.group.ref.prefix,complexType.group.ref.namespaceURI, complexType.group.ref.localPart, package)) : null ->
					
			complexType.simpleContent.^extension.base.localPart != null ? (		
				getBOMPrimitiveType(data, complexType.simpleContent.^extension.base.localPart) != null ? (let temp = toProperty(data, model, r, null, "_contents_ext_", toType(data, model, complexType.simpleContent.^extension.base.prefix, getElementSimpleContentPart(data,complexType), schemaType, package), null, null, null, null, null, null, complexType.simpleContent.^extension.base.prefix + ":" + complexType.simpleContent.^extension.base.localPart, getSimpleMinSize(schemaType,complexType.simpleContent), getSimpleMaxSize(schemaType,complexType.simpleContent), schemaType, complexType.simpleContent.annotation, null, null, null, null) : temp != null ? (r.ownedAttribute.add(temp)) : null ) : null ->
				getReferencedSimpleType(schemaType,complexType.simpleContent.^extension.base.prefix, complexType.simpleContent.^extension.base.localPart) != null ? (let temp = toProperty(data, model, r, null, "_contents_ext_", toType(data, model, complexType.simpleContent.^extension.base.prefix, getElementSimpleContentPart(data,complexType), schemaType, package), null, null, null, null, null, null, complexType.simpleContent.^extension.base.prefix + ":" + complexType.simpleContent.^extension.base.localPart, getSimpleMinSize(schemaType,complexType.simpleContent), getSimpleMaxSize(schemaType,complexType.simpleContent), schemaType, complexType.simpleContent.annotation, null, null, null, null) : temp != null ? (r.ownedAttribute.add(temp)) : null ) : null ->
				getReferencedComplexTypeContainingSimpleType(data, schemaType,complexType.simpleContent.^extension.base.prefix, complexType.simpleContent.^extension.base.localPart) != null ? (let temp = toClass(data, getReferencedComplexTypeContainingSimpleType(data, schemaType,complexType.simpleContent.^extension.base.prefix, getElementSimpleContentPart(data,complexType)),schemaType, model, null, package) : (temp != null && temp.name != null) ? (let tempProperty = toProperty(data, model, r, null, "_contents_ext_", temp, null, null, null, null, null, null, complexType.simpleContent.^extension.base.prefix + ":" + complexType.simpleContent.^extension.base.localPart, getSimpleMinSize(schemaType,complexType.simpleContent), getSimpleMaxSize(schemaType,complexType.simpleContent), schemaType, complexType.simpleContent.annotation, null, null, null, null) : r.ownedAttribute.add(tempProperty)) : null ) : null
			) : null ->	
			
			complexType.simpleContent.^restriction.base.localPart != null ? (
				getBOMPrimitiveType(data, complexType.simpleContent.^restriction.base.localPart) != null ? (let temp = toProperty(data, model, r, null, "_contents_res_", complexType.simpleContent.^restriction.enumeration.value.toString(), toType(data, model, complexType.simpleContent.^restriction.base.prefix, getElementSimpleContentPart(data,complexType), schemaType, package), null, null, null, null, null, null, complexType.simpleContent.^restriction.base.prefix + ":" + complexType.simpleContent.^restriction.base.localPart, getSimpleMinSize(schemaType,complexType.simpleContent), getSimpleMaxSize(schemaType,complexType.simpleContent), schemaType, complexType.simpleContent.annotation, null, null, null, null) : temp != null ? (r.ownedAttribute.add(temp)) : null ) : null ->
				getReferencedSimpleType(schemaType,complexType.simpleContent.^restriction.base.prefix, complexType.simpleContent.^restriction.base.localPart) != null ? (let temp = toProperty(data, model, r, null, "_contents_res_", complexType.simpleContent.^restriction.enumeration.value.toString(), toType(data, model, complexType.simpleContent.^restriction.base.prefix, getElementSimpleContentPart(data,complexType), schemaType, package), null, null, null, null, null, null, complexType.simpleContent.^restriction.base.prefix + ":" + complexType.simpleContent.^restriction.base.localPart, getSimpleMinSize(schemaType,complexType.simpleContent), getSimpleMaxSize(schemaType,complexType.simpleContent), schemaType, complexType.simpleContent.annotation, null, null, null, null) : temp != null ? (r.ownedAttribute.add(temp)) : null ) : null ->		
				getReferencedComplexTypeContainingSimpleType(data, schemaType,complexType.simpleContent.^restriction.base.prefix, complexType.simpleContent.^restriction.base.localPart) != null ? (let temp = toClass(data, getReferencedComplexTypeContainingSimpleType(data, schemaType,complexType.simpleContent.^restriction.base.prefix, getElementSimpleContentPart(data,complexType)),schemaType, model, null, package) : (temp != null && temp.name != null) ? (let tempProperty = toProperty(data, model, r, null, "_contents_res_", complexType.simpleContent.^restriction.enumeration.value.toString(), temp, null, null, null, null, null, null, complexType.simpleContent.^restriction.base.prefix + ":" + complexType.simpleContent.^restriction.base.localPart, getSimpleMinSize(schemaType,complexType.simpleContent), getSimpleMaxSize(schemaType,complexType.simpleContent), schemaType, complexType.simpleContent.annotation, null, null, null, null) : r.ownedAttribute.add(tempProperty)) : null ) : null
			) : null
		) : null ->
		
		traceMeDebug("<= createClass "+ tempClass + " for complex " + complexType.name + " anonymousComplexTypeName = "+anonymousComplexTypeName) ->	
		r
	);
		
// drills down all the explicit groups and constructs a hierarchy string to be applied on the container class so the export transform code knows how to recreate the order and depth
// | means drill down and - means next explicit group but on same level 		
String createString2(ImportTransformationData data, SchemaType schemaType, uml::Class tempClass, ComplexType complexType, List[ExplicitGroup] explicitGroups, List strTreeLayout, ExplicitGroup parentExplicitGroup) :
	traceMe("=> createString2 " + strTreeLayout + " parent id= "+parentExplicitGroup.id) ->
	explicitGroups.collect(e | (	
			let tmpCount = {} : 
			tmpCount.add("") ->			
			strTreeLayout.add(getExplicitGroupType(data, parentExplicitGroup, e)) ->				
			e.eContents.collect(e | (
					parseElementOrGroupInExplicitGroup(data, schemaType, tempClass, complexType, e, strTreeLayout, tmpCount.size) ->
					tmpCount.add("")
				)
			) ->
			(e.sequence.size > 0 || e.choice.size > 0 || e.group.size > 0) ? (
				strTreeLayout.add("|") ->
				createString(data, schemaType, tempClass, complexType, e, strTreeLayout)
			) : null ->
			strTreeLayout.add("-")
		)		
	) ->	
	explicitGroups != null && explicitGroups.size > 0 ? removeLast(strTreeLayout) : null;

cached String getExplicitGroupType(ImportTransformationData data, ExplicitGroup parentExplicitGroup, ExplicitGroup childExplicitGroup) :
	traceMe("=> getExplicitGroupType") ->
	parentExplicitGroup.all.contains(childExplicitGroup) == true ? "A" :
	(
		parentExplicitGroup.sequence.contains(childExplicitGroup) == true ? "S" : 
		(
			parentExplicitGroup.choice.contains(childExplicitGroup) == true ? "C" : (
				parentExplicitGroup.group.size > 0 ? (
					let choiceOrSequence = (										
						let groupWithChildExplicitGroup = parentExplicitGroup.group.collect(e | (
								let typeList = {} :
								let tmpExplicitGroup2  = extractGroupExplicitGroup(data, e, typeList) :
								tmpExplicitGroup2 == childExplicitGroup ? e : null						
							)
						).selectFirst(e | e != null) :
						let typeList = {} :
						let tmpExplicitGroup2  = extractGroupExplicitGroup(data, groupWithChildExplicitGroup, typeList) :
						typeList.first()
					) :
					choiceOrSequence
				) : ""
			) 
		)
	);

String createString(ImportTransformationData data, SchemaType schemaType, uml::Class tempClass, ComplexType complexType, ExplicitGroup rootExplicitGroup, List strTreeLayout) :
	((ComplexType)rootExplicitGroup.eContainer).sequence == rootExplicitGroup ? (
		addSequenceDetails(data,rootExplicitGroup,"MS1_1_1",tempClass,false,false,rootExplicitGroup.minOccurs.toString(), rootExplicitGroup.maxOccurs.toString(),null, null)	  
	) : (
		((ComplexType)rootExplicitGroup.eContainer).choice == rootExplicitGroup ? (
			addSequenceDetails(data,rootExplicitGroup,"MS1_1_1",tempClass,true,false,rootExplicitGroup.minOccurs.toString(), rootExplicitGroup.maxOccurs.toString(),null, null)	  
		) : (
			((ComplexType)rootExplicitGroup.eContainer).all == rootExplicitGroup ? (
				addSequenceDetails(data,rootExplicitGroup,"MS1_1_1",tempClass,false,true,rootExplicitGroup.minOccurs.toString(), rootExplicitGroup.maxOccurs.toString(),null, null)	
			) : null
		)
	) ->
	
	rootExplicitGroup.eContents.collect(e | (
			ExplicitGroup.isInstance(e) == true || GroupRef.isInstance(e) == true ? (
				let tmpCount = {} : 
				let tmpExplicitGroup = (
					GroupRef.isInstance(e) == true ? (
						let typeList = {} :
						let tmpExplicitGroup2  = extractGroupExplicitGroup(data, e, typeList) :
						strTreeLayout.addAll(typeList) ->
						tmpExplicitGroup2
					) : (
						strTreeLayout.add(getExplicitGroupType(data, rootExplicitGroup, e)) ->
						e
					)
				) : 
				
				tmpCount.add("") ->								
				tmpExplicitGroup.eContents.collect(e | (
						parseElementOrGroupInExplicitGroup(data, schemaType, tempClass, complexType, e, strTreeLayout, tmpCount.size) ->
						tmpCount.add("")
					)
				) ->
				traceMe("child groups " +  tmpExplicitGroup.group) ->
				(tmpExplicitGroup.sequence.size > 0 || tmpExplicitGroup.choice.size > 0 || tmpExplicitGroup.group.size > 0) ? (
					let explicitGroups = {} :
					tmpExplicitGroup.eContents.collect(e | (
						 GroupRef.isInstance(e) == true ? (
						 	let typeList = {} :
						 	let tmpExplicitGroup2  = extractGroupExplicitGroup(data, e, typeList) :
						 	explicitGroups.add(tmpExplicitGroup2)
						 ) : (
						 	ExplicitGroup.isInstance(e) == true ? (
						 		explicitGroups.add(e)
						 	) : null
						 )
						)
					) ->
					strTreeLayout.add("|") ->
					createString2(data, schemaType, tempClass, complexType, explicitGroups, strTreeLayout, tmpExplicitGroup) ->
					strTreeLayout.add("~")
				) : null ->
				strTreeLayout.add("-")	
			) : null			
		)
	) ->
	removeLast(strTreeLayout) ->  
	strTreeLayout.add("~");
	
Object getGroupOrComplexContainer(Object obj) :	
	ComplexType.isInstance(obj) == true || (Group.isInstance(obj) == true && !(ExplicitGroup.isInstance(obj))) ? (		
		obj
	) : (
		SchemaType.isInstance(obj) ? null : getGroupOrComplexContainer(obj.eContainer)
	);

	
Object getGroupContainer(Object obj) :
	Group.isInstance(obj) == true && !(ExplicitGroup.isInstance(obj)) ? (
		obj
	) : (
		SchemaType.isInstance(obj) ? null : getGroupContainer(obj.eContainer)
	);

Integer getDepth(Object obj, Integer counter) :
	xmlSchema::All.isInstance(obj) == false && xmlSchema::ExplicitGroup.isInstance(obj) == false ? (		
		counter
	) : (
		let tmpCounter = counter + 1 :
		getDepth(obj.eContainer, tmpCounter)		
	);
		
Integer getGroupRefDepth(ImportTransformationData data, Object obj, List groupRefExplicitGroups, uml::Class tempClass, ComplexType complexType) :
	let parentGroup = getGroupContainer(obj.eContainer) :
	parentGroup == null ? (
		groupRefExplicitGroups.size == 0 ? 0 : (
			complexType.sequence == null && complexType.choice == null && complexType.all == null ? groupRefExplicitGroups.size : (groupRefExplicitGroups.size + 1)
		)
	) : (
		let groupExplicitGroup = (
			parentGroup.sequence.first() != null ? (
				parentGroup.sequence.first()
			) : (
				parentGroup.choice.first() != null ? (
					parentGroup.choice.first()
				) : (
					parentGroup.all.first() != null ? (
						parentGroup.all.first()
					) : (
						null
					)
				)
			)
		) :		
		let groupRefExplicitGroup = data.getGroupRefParent(groupExplicitGroup) :
		groupRefExplicitGroup == null ? 0 : (
			let tmpGarentGroup = getGroupContainer(groupRefExplicitGroup) :			
			tmpGarentGroup == null ? (
				let depth = (
					complexType.sequence == null && complexType.choice == null && complexType.all == null ? {} : {""}					 
				):
				data.reverse(groupRefExplicitGroups) ->
				groupRefExplicitGroups.collect(e | (
						
						let currentExplicitGroup = e :
						let parentExplicitGroup = currentExplicitGroup.eContainer :
						let currentSequence = getSequenceForExplicitGroup(data,currentExplicitGroup,tempClass) :
						currentSequence != null ? null : (
							let parentSequence = getSequenceForExplicitGroup(data,parentExplicitGroup,tempClass) :
							parentExplicitGroup.sequence.contains(currentExplicitGroup) ? (
								addSequenceDetails(data,currentExplicitGroup,"MS"+(getDepth(currentExplicitGroup.eContainer, 1)+(depth.size))+"_"+(getExplicitGroupPosition(currentExplicitGroup.eContainer, currentExplicitGroup)+getGroupRefExplicitGroupPosition(data,currentExplicitGroup.eContents.first()))+"_"+getElementPosition(currentExplicitGroup.eContainer, currentExplicitGroup, data, currentExplicitGroup.eContents.first()),tempClass,false,false,currentExplicitGroup.minOccurs.toString(), currentExplicitGroup.maxOccurs.toString(),parentSequence, null)	  
							) : (
								parentExplicitGroup.choice.contains(currentExplicitGroup) ? (
									addSequenceDetails(data,currentExplicitGroup,"MS"+(getDepth(currentExplicitGroup.eContainer, 1)+(depth.size))+"_"+(getExplicitGroupPosition(currentExplicitGroup.eContainer, currentExplicitGroup)+getGroupRefExplicitGroupPosition(data,currentExplicitGroup.eContents.first()))+"_"+getElementPosition(currentExplicitGroup.eContainer, currentExplicitGroup, data, currentExplicitGroup.eContents.first()),tempClass,true,false,currentExplicitGroup.minOccurs.toString(), currentExplicitGroup.maxOccurs.toString(),parentSequence, null)	  
								) : (
									parentExplicitGroup.all.contains(currentExplicitGroup) ? (
										addSequenceDetails(data,currentExplicitGroup,"MS"+(getDepth(currentExplicitGroup.eContainer, 1)+(depth.size))+"_"+(getExplicitGroupPosition(currentExplicitGroup.eContainer, currentExplicitGroup)+getGroupRefExplicitGroupPosition(data,currentExplicitGroup.eContents.first()))+"_"+getElementPosition(currentExplicitGroup.eContainer, currentExplicitGroup, data, currentExplicitGroup.eContents.first()),tempClass,false,true,currentExplicitGroup.minOccurs.toString(), currentExplicitGroup.maxOccurs.toString(),parentSequence, null)
									) : null
								)
							)	
						) ->
						depth.add("")
					)
				) ->
				complexType.sequence == null && complexType.choice == null && complexType.all == null ? getDepth(groupRefExplicitGroup.eContainer, groupRefExplicitGroups.size) : getDepth(groupRefExplicitGroup.eContainer, (groupRefExplicitGroups.size+1))				
			) : (								
				groupRefExplicitGroups.add(groupRefExplicitGroup) ->
				getGroupRefDepth(data, groupRefExplicitGroup, groupRefExplicitGroups, tempClass,complexType)
			)
		)
	);
	
Integer getExplicitGroupPosition(Object obj, Object targetExplicitGroup) :	
	xmlSchema::All.isInstance(obj) == false && xmlSchema::ExplicitGroup.isInstance(obj) == false ? 1 : (
		let posList = {} :
		let foundList = {} :
		obj.eContents.collect(e | (
				foundList.size == 0 && (xmlSchema::All.isInstance(e) || xmlSchema::ExplicitGroup.isInstance(e)) ? posList.add("") : null ->
				foundList.size == 0 ? (
					e == targetExplicitGroup ? foundList.add("") : null
				) : null
			)
		) ->		 	
		posList.size == 0 ? 1 : posList.size	
	);
	
Integer getGroupRefExplicitGroupPosition(ImportTransformationData data, Object obj) :
	let parentGroup = getGroupContainer(obj.eContainer) :
	parentGroup == null ? 0 : (
		let groupExplicitGroup = (
			parentGroup.sequence.first() != null ? (
				parentGroup.sequence.first()
			) : (
				parentGroup.choice.first() != null ? (
					parentGroup.choice.first()
				) : (
					parentGroup.all.first() != null ? (
						parentGroup.all.first()
					) : (
						null
					)
				)
			)
		) :
		let groupRefExplicitGroup = data.getGroupRefParent(groupExplicitGroup) :
		let posList = {} :
		let foundList = {} :
		groupRefExplicitGroup.eContents.collect(e | (
			foundList.size == 0 && (xmlSchema::All.isInstance(e) || xmlSchema::ExplicitGroup.isInstance(e) || GroupRef.isInstance(e)) ? posList.add("") : null ->
				foundList.size == 0 ? (
					GroupRef.isInstance(e) ? (
						e.ref.localPart == parentGroup.name ? foundList.add("") : null
					) : null					
				) : null
			)
		) ->
		posList.size == 0 ? 0 : (posList.size -1)
	);
	
Integer getElementPosition(Object container, Object targetExplicitGroup, ImportTransformationData data, Object obj) :
	let parentGroup = getGroupContainer(obj.eContainer) :
	parentGroup == null ? (
		let posList = {} :
		let foundList = {} :
		container.eContents.collect(e | (
				foundList.size == 0 ? posList.add("") : null ->
				foundList.size == 0 ? (
					e == targetExplicitGroup ? foundList.add("") : null
				) : null
			)
		) ->		 	
		posList.size == 0 ? 1 : posList.size
	) : (
		let groupExplicitGroup = (
			parentGroup.sequence.first() != null ? (
				parentGroup.sequence.first()
			) : (
				parentGroup.choice.first() != null ? (
					parentGroup.choice.first()
				) : (
					parentGroup.all.first() != null ? (
						parentGroup.all.first()
					) : (
						null
					)
				)
			)
		) :
		let groupRefExplicitGroup = data.getGroupRefParent(groupExplicitGroup) :
		let posList = {} :
		let foundList = {} :		
		groupRefExplicitGroup.eContents.collect(e | (
				foundList.size == 0 ? posList.add("") : null ->
				foundList.size == 0 ? (
					GroupRef.isInstance(e) && e.ref.localPart == parentGroup.name ? foundList.add("") : null
				) : null
			)
		) ->		 	
		posList.size == 0 ? 1 : posList.size
	);
	
cached parseElementOrGroupInExplicitGroup(ImportTransformationData data, SchemaType schemaType, uml::Class tempClass, ComplexType complexType, Object obj, List strTreeLayout, Integer objectPosition) :
	(
		let explicitGroupTree = strTreeLayout.toString()./*replaceAll(",", "").*/replaceAll("\\[", "").replaceAll("\\]","").replaceAll(" ","").trim() :
		(Element.isInstance(obj) == true || AnyType.isInstance(obj) == true || ExplicitGroup.isInstance(obj) == true) ? (
			let currentExplicitGroup = obj.eContainer :
			let parentExplicitGroup = currentExplicitGroup.eContainer :
			let currentSequence = getSequenceForExplicitGroup(data,currentExplicitGroup,tempClass) :
			currentSequence != null ? null : (
				let parentSequence = getSequenceForExplicitGroup(data,parentExplicitGroup,tempClass) :
				let groupRefDepth = getGroupRefDepth(data,obj,{},tempClass,complexType) :					
				parentExplicitGroup.sequence.contains(currentExplicitGroup) ? (
					addSequenceDetails(data,currentExplicitGroup,"MS"+(getDepth(currentExplicitGroup.eContainer, 1)+groupRefDepth)+"_"+(getExplicitGroupPosition(currentExplicitGroup.eContainer, currentExplicitGroup)+getGroupRefExplicitGroupPosition(data,obj))+"_"+getElementPosition(currentExplicitGroup.eContainer, currentExplicitGroup, data, obj),tempClass,false,false,currentExplicitGroup.minOccurs.toString(), currentExplicitGroup.maxOccurs.toString(),parentSequence, explicitGroupTree)	  
				) : (
					parentExplicitGroup.choice.contains(currentExplicitGroup) ? (
						addSequenceDetails(data,currentExplicitGroup,"MS"+(getDepth(currentExplicitGroup.eContainer, 1)+groupRefDepth)+"_"+(getExplicitGroupPosition(currentExplicitGroup.eContainer, currentExplicitGroup)+getGroupRefExplicitGroupPosition(data,obj))+"_"+getElementPosition(currentExplicitGroup.eContainer, currentExplicitGroup, data, obj),tempClass,true,false,currentExplicitGroup.minOccurs.toString(), currentExplicitGroup.maxOccurs.toString(),parentSequence, explicitGroupTree)	  
					) : (
						parentExplicitGroup.all.contains(currentExplicitGroup) ? (
							addSequenceDetails(data,currentExplicitGroup,"MS"+(getDepth(currentExplicitGroup.eContainer, 1)+groupRefDepth)+"_"+(getExplicitGroupPosition(currentExplicitGroup.eContainer, currentExplicitGroup)+getGroupRefExplicitGroupPosition(data,obj))+"_"+getElementPosition(currentExplicitGroup.eContainer, currentExplicitGroup, data, obj),tempClass,false,true,currentExplicitGroup.minOccurs.toString(), currentExplicitGroup.maxOccurs.toString(),parentSequence, explicitGroupTree)
						) : null
					)
				)	
			) 
		) : null ->		
		Element.isInstance(obj) == true ? (	
			getElementRefLocalPart(data, (Element)obj) == null ? (			
				setExplicitGroupTree(getElementName(data, (Element)obj), tempClass, explicitGroupTree, objectPosition.toString(), getSequenceForExplicitGroup(data,obj.eContainer,tempClass))
			) : (
				let refElement = (
					let tmpRefElem = getReferencedElement(data, schemaType, tempClass, ((Element)obj).ref.prefix ,((Element)obj).ref.localPart,((Element)obj).ref.namespaceURI) :
					tmpRefElem != null ? tmpRefElem : getReferencedElement(data, schemaType, tempClass, ((Element)obj).ref.prefix ,((Element)obj).ref.localPart,null)				
				) :
				
				setExplicitGroupTree(getElementName(data, refElement), tempClass, explicitGroupTree, objectPosition.toString(), getSequenceForExplicitGroup(data,obj.eContainer,tempClass))
			)
		) : (
			AnyType.isInstance(obj) == true ? (	
				setExplicitGroupTree(getAnyTypeName(data, (AnyType)obj), tempClass, explicitGroupTree, objectPosition.toString(), getSequenceForExplicitGroup(data,obj.eContainer,tempClass))
			) : null
		) ->	
		GroupRef.isInstance(obj) == true ? data.removeGroupRefParent(obj.eContainer) : null
	);

// create a class representing an anonymous complex type and give it the parentElement's name concatenated with Type on the end
cached uml::Class createClass(ImportTransformationData data, Element parentElement, uml::Class tempClass, ComplexType complexType, SchemaType schemaType, uml::Model model, uml::Package package):
	traceMeDebug("=> createClass 1: "+getElementName(data, parentElement)) ->
	tempClass != null ? 
	    (
	    	traceMeDebug("<= createClass 1: "+getElementName(data, parentElement)) ->
	    	tempClass 
	    ) :	(			
			let anonymousClass = toClass(data, complexType, schemaType, model, getElementName(data, parentElement) + "Type", package):					 
		 	anonymousClass != null ? (		 		
		 		//setAnonStereotypeValue(anonymousClass, true) ->
		 		setAnonStereotypeValue(anonymousClass, false) ->	
		 		// XPD-4386: modified this method in TransformHelper to support mixed construct
		 		applyClassStereotypeValues(anonymousClass, complexType, complexType.complexContent, parentElement.name, complexType.id, complexType.mixed.toString(), complexType.complexContent.mixed.toString(), getBlockListValue(complexType.block), getFinalListValue(complexType.final), complexType.abstract.toString(), true, false, false) ->
 				calculateExplicitGroupTrees(data, anonymousClass, complexType, schemaType, model, package) ->
 				// XPD-5171: pass in the anonymous class name to find if it's a root document obj.
 				// also moved this into not null clause to avoid getting any NPE
 				isRootDocumentObject(data, schemaType,  anonymousClass.name) ? (			
					applyDocumentRoot(anonymousClass)
				) : null
				
		 	) : null ->
		 	traceMeDebug("<= createClass 1: "+getElementName(data, parentElement)) ->
		 	anonymousClass
		);
		
// add an annotation to the uml class
cached addEAnnotation(uml::Class tempClass, String source) :
	traceMe("=> addEAnnotation") ->
	(
		let annotation = new ecore::EAnnotation:	 
		annotation.setSource(source) ->
		tempClass.eAnnotations.add(annotation)
	);

// create a simple uml class with a name applied in a specific package
cached uml::Class createClass(String name, uml::Package package) :
	traceMeDebug("=>createClass():9 " + name) ->
	(
		let r = new uml::Class :		 
		r.setPackage(package) ->
		r.setName(name) ->
		traceMeDebug("<=createClass():9 " + name) ->
		r
	);
	
// create a simple uml class with a name applied in a specific package representing an anonymous complex type
uml::Class createAnonymousClass(String name, uml::Package package) :
	traceMeDebug("=> ::: createAnonymousClass :::createClass 10 "+ name) ->
	(
		let tmpCls = package.eAllContents.typeSelect(uml::Class).select(e|e.name == name+"__tibRef" && isAnonClass(e) == true).first() :
		tmpCls != null ? (
			tmpCls.setName(name) ->
			setAnonStereotypeValue(tmpCls, false) ->	
			traceMeDebug("<= ::: createAnonymousClass :::createClass 10 "+ name) ->
			tmpCls 
		) : (
			let r = new uml::Class :		 
			r.setPackage(package) ->
			r.setName(name) ->
			setAnonStereotypeValue(r, false) ->
			traceMeDebug("<= ::: createAnonymousClass :::createClass 10 "+ name) ->
			r
		)
	);

// works out the target namespace associated with the prefix and then fetches the corresponding schema			
SchemaType getSchemaTypeForPrefix(ImportTransformationData data, SchemaType schemaType, String prefix) :
	traceMe("=> getSchemaTypeForPrefix " + prefix) ->
	(
		let schemaTypeList = (			
			let tempList = {} :			
			data.schemaTypes == null ? null : tempList.addAll(data.schemaTypes) ->
			data.wsdlSchemaTypes == null ? null : tempList.addAll(data.wsdlSchemaTypes) ->
			tempList
		) :
		let isXmlSchemaDocRootType = XmlSchemaDocumentRoot.isInstance(schemaType.eContainer) :	
		isXmlSchemaDocRootType == true ? (
			let xmlSchemaDocumentRoot = (XmlSchemaDocumentRoot)schemaType.eContainer : 
			let mappedNamespaceFromPrefix = xmlSchemaDocumentRoot.xMLNSPrefixMap.get(prefix) : 
			let schemaWithReferencedElement = schemaTypeList.typeSelect(xmlSchema::SchemaType).select(e|e.targetNamespace == mappedNamespaceFromPrefix).first() :
			(prefix == null || prefix.trim().length == 0 || isKnownNamespace(mappedNamespaceFromPrefix)) || schemaWithReferencedElement == null ? schemaType : schemaWithReferencedElement
		) : (
			let mappedNamespaceFromPrefix = data.parentPrefixMap.get(prefix) : 
			let schemaWithReferencedElement = schemaTypeList.typeSelect(xmlSchema::SchemaType).select(e|e.targetNamespace == mappedNamespaceFromPrefix).first() :
			schemaWithReferencedElement != null ? (
			(prefix == null || prefix.trim().length == 0 || isKnownNamespace(mappedNamespaceFromPrefix)) || schemaWithReferencedElement == null ? schemaType : schemaWithReferencedElement
			) : (
				let tmpMappedNamespaceFromPrefix = data.innerWSDLSchemaPrefixMap.get(prefix) : 
				let tmpSchemaWithReferencedElement = schemaTypeList.typeSelect(xmlSchema::SchemaType).select(e|e.targetNamespace == tmpMappedNamespaceFromPrefix).first() :
				(prefix == null || prefix.trim().length == 0 || isKnownNamespace(tmpMappedNamespaceFromPrefix)) || tmpSchemaWithReferencedElement == null ? schemaType : tmpSchemaWithReferencedElement					
			)
		)
	);

// fetches the corresponding schema associated with namespaceURI			
SchemaType getSchemaTypeForNamespaceURI(ImportTransformationData data, SchemaType schemaType, String namespaceURI) :
	traceMe("=>getSchemaTypeForNamespaceURI(): namespaceURI=" + namespaceURI) ->
	(
		let schemaTypeList = (			
			let tempList = {} :			
			data.schemaTypes == null ? null : tempList.addAll(data.schemaTypes) ->
			data.wsdlSchemaTypes == null ? null : tempList.addAll(data.wsdlSchemaTypes) ->
			tempList.size == 0 ? tempList.add(schemaType) : null ->
			tempList
		) :
		
		
		traceMe("<=getSchemaTypeForNamespaceURI(): namespaceURI=" + namespaceURI) ->
		schemaTypeList.typeSelect(xmlSchema::SchemaType).select(e|e.targetNamespace == namespaceURI).first()
				
	);

// gets the original name of the attributes localPart value before being renamed from the duplicate code check code at start of transformer
String getAttributeLocalPart(ImportTransformationData data, xmlSchema::Attribute attribute) :
	traceMe("=> getAttributeLocalPart") ->
	(		
		attribute.type == null && attribute.ref == null && attribute.simpleType == null ? "anyType" : attribute.type.localPart		
	);
		
// gets the original name of the elements localPart value before being renamed from the duplicate code check code at start of transformer
String getElementLocalPart(ImportTransformationData data, xmlSchema::Element element) :
	traceMe("=> getElementLocalPart") ->
	(	
		element.type == null && element.ref == null && element.simpleType == null && element.complexType == null ? "anyType" : element.type.localPart		
	);

// gets the original name of the element complex content extension or restriction localPart value before being renamed from the duplicate code check code at start of transformer
String getElementComplexContentPart(ImportTransformationData data, ComplexType complexType) :
	traceMe("=> getElementComplexContentPart") ->
	(		
		complexType.complexContent.^extension.base.localPart != null ? complexType.complexContent.^extension.base.localPart : (
			complexType.complexContent.^restriction.base.localPart != null ? complexType.complexContent.^restriction.base.localPart : null  	
		)		
	);

// gets the original name of the element simple content extension or restriction localPart value before being renamed from the duplicate code check code at start of transformer
String getElementSimpleContentPart(ImportTransformationData data, ComplexType complexType) :
	traceMe("=> getElementSimpleContentPart for " + complexType.name) ->
	(	
		complexType.simpleContent.^extension.base.localPart != null ? complexType.simpleContent.^extension.base.localPart : (
			complexType.simpleContent.^restriction.base.localPart != null ? complexType.simpleContent.^restriction.base.localPart : null  	
		)	
	);

// gets the original name of the element or attribute with the anonymous simple type content extension or restriction localPart value before being renamed from the duplicate code check code at start of transformer	
String getSimpleTypeBasePart(ImportTransformationData data, Object elementOrAttr, Object simpleType) :
	traceMe("=>getSimpleTypeBasePart(): " + elementOrAttr) ->
	//data.ctx.inspectObject("getSimpleTypeBasePart()", elementOrAttr, simpleType) ->	
	xmlSchema::Element.isInstance(elementOrAttr) ?
	(	
		let name = (
			elementOrAttr.simpleType.restriction.base.localPart != null ? 
			(	
				elementOrAttr.simpleType.restriction.base.localPart
			):
			(
				null
			)		
		):
		traceMe("<=getSimpleTypeBasePart(): Element name=" + name) ->
		name
				
	) : (		
		xmlSchema::Attribute.isInstance(elementOrAttr) ?
		(			
			elementOrAttr.simpleType.^restriction.base.localPart != null ? 
			(
				traceMe("<=getSimpleTypeBasePart(): Attribute name=" + elementOrAttr.simpleType.^restriction.base.localPart) ->
				elementOrAttr.simpleType.^restriction.base.localPart
			) :
			(
				traceMe("<=getSimpleTypeBasePart(): Attribute name=NULL") ->
				null
			)		
		) : 
		(			
			simpleType.^restriction.base.localPart != null ? 
			(
				traceMe("<=getSimpleTypeBasePart(): NOT TLE or TLA name=" + simpleType.^restriction.base.localPart) ->
				simpleType.^restriction.base.localPart
			) :
			(
				traceMe("<=getSimpleTypeBasePart(): NOT TLE or TLA name=NULL") ->
				null
			)
		)
	) 
	;

// gets the original name of the attribute reference localPart value before being renamed from the duplicate code check code at start of transformer	
String getAttributeRefLocalPart(ImportTransformationData data, xmlSchema::Attribute attribute) :
	attribute.ref.localPart;

// gets the original name of the element reference localPart value before being renamed from the duplicate code check code at start of transformer	
String getElementRefLocalPart(ImportTransformationData data, xmlSchema::Element element) :
	element.ref.localPart;

// fetches the anyType name we have assigned to the current anyType	
String getAnyTypeName(ImportTransformationData data, xmlSchema::AnyType anyType) :	
	(
		let tmpName = data.anyTypeNamesMap.get(anyType) :	
		tmpName == null ? "any" : tmpName
	);

// fetches the anyAttribute name we have assigned to the current anyAttribute
String getAnyAttributeName(ImportTransformationData data, xmlSchema::Wildcard anyAttribute) :	
	(
		let tmpName = data.anyAttributeNamesMap.get(anyAttribute) :	
		tmpName == null ? "anyAttribute" : tmpName
	);
	
// fetches the original element name before it has been altered by the renaming code at start of transformation 	
cached String getElementName(ImportTransformationData data, xmlSchema::Element element) :	
	element.name;
	

// fetches the original attribute name before it has been altered by the renaming code at start of transformation 	
cached String getAttributeName(ImportTransformationData data, xmlSchema::Attribute attribute) :
	attribute.name;

// fetches the original complex type name before it has been altered by the renaming code at start of transformation	
cached String getComplexName(ImportTransformationData data, ComplexType complexType) :	
	complexType.name;	

// fetches the original simple type name before it has been altered by the renaming code at start of transformation
cached String getSimpleName(ImportTransformationData data, SimpleType simpleType) :
	simpleType.name;

// returns whether or not a construct with name localPart inside schema matching namespaceURI is indeed a complex type or not
cached Boolean isComplexType(ImportTransformationData data, SchemaType schemaType, String namespaceURI, String localPart) : 
	traceMe("=> isComplexType "+ localPart) ->
	(
		let childSchema = getSchemaTypeForNamespaceURI(data, schemaType, namespaceURI) :
		let complexType = childSchema.complexType.select(e|getComplexName(data, e) == localPart).first() :			
		// if complex type is not found also check against schemas in wsdls if we are coming in through this path
		complexType != null ? true : (
			let schemaTypeList = (			
				let tempList = {} :				
				data.schemaTypes == null ? null : tempList.addAll(data.schemaTypes) ->				
				data.wsdlSchemaTypes == null ? null : tempList.addAll(data.wsdlSchemaTypes) ->				
				tempList
			) :
			let tmpComplexType = schemaTypeList.complexType.select(e|(getComplexName(data, e) == localPart || e.name == localPart)).first() :
			tmpComplexType != null ? true : false
		)
	);

// returns whether or not a construct with name as defined in the restrictionType localPart inside schema matching restrictionType namespaceURI is indeed a simple type or not
cached Boolean isSimpleType(ImportTransformationData data, RestrictionType1 restrictionType) :
	restrictionType == null ? false : (	
		let schemaTypeList = (			
			let tempList = {} :			
			data.schemaTypes == null ? null : tempList.addAll(data.schemaTypes) ->			
			data.wsdlSchemaTypes == null ? null : tempList.addAll(data.wsdlSchemaTypes) ->			
			tempList
		) :		
		let superSimpleType = schemaTypeList.select(e|e.targetNamespace == restrictionType.base.namespaceURI).eAllContents.typeSelect(SimpleType).select(e|e.name != null && e.name == restrictionType.base.localPart).first() :
		superSimpleType != null ? true : false
	);

// keep going up the stack until the Object is of type Schema	
cached xmlSchema::SchemaType getParentSchemaType(Object obj) :	
	xmlSchema::SchemaType.isInstance(obj) ? obj : getParentSchemaType(obj.eContainer);

// parses the anyType and its anyType children if any returning a list of converted properties representing them	
cached List[uml::Property] parseAnyType(ImportTransformationData data, AnyType anyType, uml::Model model, SchemaType schemaType, uml::Class createClass, uml::Package package) :
	let newAnyTypeName = data.addNewAnyTypeName(anyType, getAnyTypeName(data, anyType), "*") :	
	let tmpNamespaceList = (
		List.isInstance(anyType.namespace) ? anyType.namespace : {anyType.namespace}
	) :
	{toProperty(data, model, createClass, null, newAnyTypeName, getBOMObjectPrimitiveType(data), null, null, anyType.id, null, null, null, null, anyType.minOccurs.toString(), anyType.maxOccurs, schemaType, anyType.annotation, null, tmpNamespaceList, anyType.processContents.toString(), null)};
	
// parses each element in a loop outside this method - either returns a property or a composition property depending on what we are looking at. Note we encapsulate it in a list but only ever 1 property in here ever made.
cached List[uml::Property] parseElement(ImportTransformationData data, Element element, uml::Model model, SchemaType schemaType, uml::Class createClass, uml::Package package) :
	traceMe("=> parseElement " + element.name + " id= "+ element.id + " ref= "+ element.ref.localPart) ->
	(getElementRefLocalPart(data, element) == null && getElementLocalPart(data, element) == null && element.simpleType == null && element.complexType == null) ? (
		{
			traceMe("toProperty 1") ->		
			toProperty(data, model, createClass, null, element.name, null, element.form.toString(), element.^default, element.id, element.fixed, element.ref.namespaceURI + ":" + getElementRefLocalPart(data, element), null,element.type.prefix + ":" + element.type.localPart, element.minOccurs.toString(), element.maxOccurs, schemaType, element.annotation, element.nillable.toString(), null, null, getBlockListValue(element.block))
		}
	) : (
		(getElementRefLocalPart(data, element) == null && getElementLocalPart(data, element) != null && !isComplexType(data, schemaType, element.type.namespaceURI, getElementLocalPart(data, element))) ? (
			{
				traceMe("toProperty 2") ->
				toProperty(data, model, createClass, null, element.name, toType(data, model, element.type.prefix, getElementLocalPart(data, element), schemaType, package), element.form.toString(), element.^default, element.id, element.fixed, element.ref.namespaceURI + ":" + getElementRefLocalPart(data, element), null, element.type.prefix + ":" + element.type.localPart, element.minOccurs.toString(), element.maxOccurs, schemaType, element.annotation, element.nillable.toString(), null, null, getBlockListValue(element.block))
			}		
		) : (
			getElementRefLocalPart(data, element) == null && getElementLocalPart(data, element) != null && isComplexType(data, schemaType, element.type.namespaceURI, getElementLocalPart(data, element)) ? (				
				traceMe("toClassWithType") ->
				toClassWithType(data, element, schemaType, model, createClass, package) ->
				{}
			) : (
				getElementRefLocalPart(data, element) != null ? (					
					{
						traceMe("toPropertyWithRef") ->
						toPropertyWithRef(data, schemaType, model, createClass, element.name, getElementLocalPart(data, element), element.minOccurs.toString(), element.maxOccurs, element.ref.prefix, element.ref.namespaceURI,getElementRefLocalPart(data, element), element, package)
					}
				) : (
					element.complexType != null ? (
						let tmpClass = toClass(data, element, element.complexType, schemaType, model, package) :						
						createComposition(data, package,createClass,tmpClass,createClass.name,tmpClass.name,element.minOccurs.toString(),element.maxOccurs.toString(),element.name,getFormForElementName(data, schemaType,tmpClass), getDefaultForElementName(data, schemaType,tmpClass), getIDForElementName(data, schemaType,tmpClass), getFixedForElementName(data, schemaType,tmpClass), getNillableForElementName(data, schemaType,tmpClass), getBlockForElementName(data, schemaType,tmpClass)) ->
						{}
					) : (
						element.simpleType != null && element.simpleType.restriction != null ? (
							{toProperty(data, model, createClass, element.simpleType, element.name, toType(data, model, element.simpleType.restriction.base.prefix, getSimpleTypeBasePart(data, element, element.simpleType), schemaType, package), element.form.toString(), element.^default, element.id, element.fixed, element.ref.namespaceURI + ":" + getElementRefLocalPart(data, element), null, element.simpleType.restriction.base.prefix + ":" + element.simpleType.restriction.base.localPart, element.minOccurs.toString(), element.maxOccurs, schemaType, element.simpleType.restriction.annotation, element.nillable.toString(), null, null, getBlockListValue(element.block))}
						) : ( 
							element.simpleType != null && element.simpleType.union != null ? (
								let tmpType = (								
										element.simpleType.restriction == null || (element.simpleType.restriction != null && (element.simpleType.restriction.enumeration == null || element.simpleType.restriction.enumeration.size == 0)) ? toPrimitiveType(data, element, element.simpleType, schemaType, model, package) : (
											element.simpleType.restriction.enumeration != null && element.simpleType.restriction.enumeration.size > 0 ? toEnumeration(data, element, element.simpleType, schemaType, model, package, element.simpleType.restriction.enumeration.id, element.simpleType.restriction.enumeration.value) : null
										)			
								) :
								{toProperty(data, model, createClass, element.simpleType, element.name, tmpType, element.form.toString(), element.^default, element.id, element.fixed, element.ref.namespaceURI + ":" + getElementRefLocalPart(data, element), null, null, element.minOccurs.toString(), element.maxOccurs, schemaType, element.simpleType.union.annotation, element.nillable.toString(), null, null, getBlockListValue(element.block))}
							) : (
								element.simpleType != null && element.simpleType.list != null ? (
									{toProperty(data, model, createClass, element.simpleType, element.name, toType(data, model, element.simpleType.list.itemType.prefix, element.simpleType.list.itemType.localPart, schemaType, package), element.form.toString(), element.^default, element.id, element.fixed, element.ref.namespaceURI + ":" + getElementRefLocalPart(data, element), null, element.simpleType.list.itemType.prefix + ":" + element.simpleType.list.itemType.localPart, element.minOccurs.toString(), element.maxOccurs, schemaType, element.simpleType.list.annotation, element.nillable.toString(), null, null, getBlockListValue(element.block))}							
								) : (
									{}
								)
							)
						)
					)
				)
			)
		)
	);	

// parse the explicit group all and go through each anytype, element or group ref. Note we drill down all levels here for other explicit groups found.	
cached Boolean parseAll(ImportTransformationData data, uml::Model model, SchemaType schemaType, ExplicitGroup all, uml::Class createClass, uml::Package package, Integer depth, Integer explicitGroupPosition) :
	traceMe("=> parseAll elem position =" + explicitGroupPosition) ->
	(
		let tmpSeqDepth = depth + 1 :
		let tmpSeqPos = {} :
		let tmpChoiceDepth = depth + 1 :
		let tmpChoicePos = {} :
		let tmpAllDepth = depth + 1 :
		let tmpAllPos = {} :
		traceMe("all "+all) ->
		all != null ? (	
			setIsAllMultiplicity(createClass, all.minOccurs.toString(), all.maxOccurs.toString()) ->		
			all.eContents.collect(e |
				Element.isInstance(e) || AnyType.isInstance(e) ? (
					let attributes = {} :
					Element.isInstance(e) ? attributes.addAll(parseElement(data, e, model, schemaType, createClass, package)) : attributes.addAll(parseAnyType(data, e, model, schemaType, createClass, package)) ->
					createClass.ownedAttribute.addAll(attributes.select(e|e != null))			
				) : (
					(GroupRef.isInstance(e) == true) ? (
						let typeList = {} :
						let tmpExplicitGroup  = extractGroupExplicitGroup(data, e, typeList) :
						traceMe("tmpExplicitGroup = "+ tmpExplicitGroup) ->
						typeList.contains("A") ? (
							traceMe("about to parse all = "+ typeList.contains("A")) ->	
							tmpAllPos.add("") ->
							parseAll(data, model, schemaType, tmpExplicitGroup, createClass, package, tmpAllDepth, tmpAllPos.size)
						) : (												
							typeList.contains("S") ? (
								traceMe("about to parse sequence = "+ typeList.contains("S")) ->	
								tmpSeqPos.add("") ->
								parseSequence(data, model, schemaType, tmpExplicitGroup, createClass, package, tmpSeqDepth, tmpSeqPos.size)
							) : (
								typeList.contains("C") ? (
									traceMe("about to parse choice = "+ typeList.contains("C")) ->	
									tmpChoicePos.add("") ->
									parseChoice(data, model, schemaType, tmpExplicitGroup, createClass, package, tmpChoiceDepth, tmpChoicePos.size)
								) : null
							)
						)
					) : (
						ExplicitGroup.isInstance(e) && all.choice.contains(e) ? (
							tmpChoicePos.add("") ->
							parseChoice(data, model, schemaType, e, createClass, package, tmpChoiceDepth, tmpChoicePos.size)
						) : (
							ExplicitGroup.isInstance(e) && all.sequence.contains(e) ? (
								tmpSeqPos.add("") ->
								parseSequence(data, model, schemaType, e, createClass, package, tmpSeqDepth, tmpSeqPos.size)								
							) : null
						)
					)	
				)
			)		
		) : null
	);

// parse the explicit group sequence and go through each anytype, element or group ref. Note we drill down all levels here for other explicit groups found.
cached Boolean parseSequence(ImportTransformationData data, uml::Model model, SchemaType schemaType, ExplicitGroup sequence, uml::Class createClass, uml::Package package, Integer depth, Integer explicitGroupPosition) :
	traceMe("=> parseSequence elem position =" + explicitGroupPosition) ->
	(
		let tmpSeqDepth = depth + 1 :
		let tmpSeqPos = {} :
		let tmpChoiceDepth = depth + 1 :
		let tmpChoicePos = {} :
		
		sequence != null ? (		
			sequence.eContents.collect(e |
				traceMe("looking at " + e) ->
				Element.isInstance(e) || AnyType.isInstance(e) ? (
					let attributes = {} :
					Element.isInstance(e) ? attributes.addAll(parseElement(data, e, model, schemaType, createClass, package)) : attributes.addAll(parseAnyType(data, e, model, schemaType, createClass, package)) ->
					createClass.ownedAttribute.addAll(attributes.select(e|e != null))
				) : (
					(GroupRef.isInstance(e) == true) ? (
						let typeList = {} :
						let tmpExplicitGroup  = extractGroupExplicitGroup(data, e, typeList) :
						traceMe("tmpExplicitGroup = "+ tmpExplicitGroup) ->						
						typeList.contains("S") ? (
							traceMe("about to parse sequence = "+ typeList.contains("S")) ->	
							tmpSeqPos.add("") ->
							parseSequence(data, model, schemaType, tmpExplicitGroup, createClass, package, tmpSeqDepth, tmpSeqPos.size)
						) : (
							typeList.contains("C") ? (
								traceMe("about to parse choice = "+ typeList.contains("C")) ->	
								tmpChoicePos.add("") ->
								parseChoice(data, model, schemaType, tmpExplicitGroup, createClass, package, tmpChoiceDepth, tmpChoicePos.size)
							) : null
						)
					) : (
						ExplicitGroup.isInstance(e) && sequence.sequence.contains(e) ? (
							tmpSeqPos.add("") ->
							parseSequence(data, model, schemaType, e, createClass, package, tmpSeqDepth, tmpSeqPos.size)
						) : (
							ExplicitGroup.isInstance(e) && sequence.choice.contains(e) ? (
								tmpChoicePos.add("") ->
								parseChoice(data, model, schemaType, e, createClass, package, tmpChoiceDepth, tmpChoicePos.size)
							) : null
						)
					)	
				)
			)		
		) : null
	);

// parse the explicit group choice and go through each anytype, element or group ref. Note we drill down all levels here for other explicit groups found.
cached Boolean parseChoice(ImportTransformationData data, uml::Model model, SchemaType schemaType, ExplicitGroup choice, uml::Class createClass, uml::Package package, Integer depth, Integer explicitGroupPosition) :
	traceMe("=> parseChoice elem position =" + explicitGroupPosition) ->
	(
		let tmpSeqDepth = depth + 1 :
		let tmpSeqPos = {} :
		let tmpChoiceDepth = depth + 1 :
		let tmpChoicePos = {} :
		traceMe("choice "+choice) ->
		choice != null ? (		
			choice.eContents.collect(e |
				Element.isInstance(e) || AnyType.isInstance(e) ? (
					let attributes = {} :
					Element.isInstance(e) ? attributes.addAll(parseElement(data, e, model, schemaType, createClass, package)) : attributes.addAll(parseAnyType(data, e, model, schemaType, createClass, package)) ->
					createClass.ownedAttribute.addAll(attributes.select(e|e != null))			
				) : (
					(GroupRef.isInstance(e) == true) ? (
						let typeList = {} :
						let tmpExplicitGroup  = extractGroupExplicitGroup(data, e, typeList) :
						traceMe("tmpExplicitGroup = "+ tmpExplicitGroup) ->						
						typeList.contains("S") ? (
							traceMe("about to parse sequence = "+ typeList.contains("S")) ->	
							tmpSeqPos.add("") ->
							parseSequence(data, model, schemaType, tmpExplicitGroup, createClass, package, tmpSeqDepth, tmpSeqPos.size)
						) : (
							typeList.contains("C") ? (
								traceMe("about to parse choice = "+ typeList.contains("C")) ->	
								tmpChoicePos.add("") ->
								parseChoice(data, model, schemaType, tmpExplicitGroup, createClass, package, tmpChoiceDepth, tmpChoicePos.size)
							) : null
						)
					) : (
						ExplicitGroup.isInstance(e) && choice.choice.contains(e) ? (
							tmpChoicePos.add("") ->
							parseChoice(data, model, schemaType, e, createClass, package, tmpChoiceDepth, tmpChoicePos.size)
						) : (
							ExplicitGroup.isInstance(e) && choice.sequence.contains(e) ? (
								tmpSeqPos.add("") ->
								parseSequence(data, model, schemaType, e, createClass, package, tmpSeqDepth, tmpSeqPos.size)								
							) : null
						)
					)	
				)
			)		
		) : null
	);		

// called from method "parseAttributeOrAttrGroupContents" and just processes attributes inside an attribute group
cached parseAttributeOrAttributeGroups(ImportTransformationData data, uml::Model model, SchemaType schemaType, ComplexType complexType, uml::Class createClass, uml::Package package):	
	(complexType.attribute != null && complexType.attribute.size > 0) || (complexType.attributeGroup != null && complexType.attributeGroup.size > 0) || (complexType.anyAttribute1 != null) ? parseAttributeOrAttrGroupContents(data, model, schemaType, createClass, package, complexType) : null ->
	(complexType.simpleContent.^extension.attribute != null && complexType.simpleContent.^extension.attribute.size > 0) || (complexType.simpleContent.^extension.attributeGroup != null && complexType.simpleContent.^extension.attributeGroup.size > 0) || (complexType.simpleContent.^extension.anyAttribute1 != null) || (complexType.simpleContent.^extension.anyAttribute1 != null) ? parseAttributeOrAttrGroupContents(data, model, schemaType, createClass, package, complexType.simpleContent.^extension) : null ->
	(complexType.simpleContent.^restriction.attribute != null && complexType.simpleContent.^restriction.attribute.size > 0) || (complexType.simpleContent.^restriction.attributeGroup != null && complexType.simpleContent.^restriction.attributeGroup.size > 0) || (complexType.simpleContent.^restriction.anyAttribute1 != null) || (complexType.simpleContent.^restriction.anyAttribute1 != null) ? parseAttributeOrAttrGroupContents(data, model, schemaType, createClass, package, complexType.simpleContent.^restriction) : null ->
	(complexType.complexContent.^extension.attribute != null && complexType.complexContent.^extension.attribute.size > 0) || (complexType.complexContent.^extension.attributeGroup != null && complexType.complexContent.^extension.attributeGroup.size > 0) || (complexType.complexContent.^extension.anyAttribute1 != null) || (complexType.complexContent.^extension.anyAttribute1 != null) ? parseAttributeOrAttrGroupContents(data, model, schemaType, createClass, package, complexType.complexContent.^extension) : null ->
	(complexType.complexContent.^restriction.attribute != null && complexType.complexContent.^restriction.attribute.size > 0) || (complexType.complexContent.^restriction.attributeGroup != null && complexType.complexContent.^restriction.attributeGroup.size > 0) || (complexType.complexContent.^restriction.anyAttribute1 != null) || (complexType.complexContent.^restriction.anyAttribute1 != null) ? parseAttributeOrAttrGroupContents(data, model, schemaType, createClass, package, complexType.complexContent.^restriction) : null;

// parses all attributes in turn and if it encounters an attrbute group we extract all the values from this and treat them as though they are self contained attributes in their own right thus avoiding the need for export code to recreate an attribute group.
cached parseAttributeOrAttrGroupContents(ImportTransformationData data, uml::Model model, SchemaType schemaType, uml::Class createClass, uml::Package package, Object contentsContainer) :
	contentsContainer != null ? (		
		contentsContainer.eContents.collect(e |
				traceMe("attr type = "+e) ->
				Attribute.isInstance(e) && (e.use != UseType::prohibited) ? (
					parseAttributes(data, model, schemaType, {e}, createClass, package)
				) : (
					Wildcard.isInstance(e) == true ? (
						parseAnyAttribute(data, model, schemaType, e, createClass, package)
					) : (
						AttributeGroupRef.isInstance(e) == true ? (
							let attrGroup  = extractAttributeGroup(data, e) :
							parseAttributeOrAttrGroupContents(data, model, schemaType, createClass, package, attrGroup)
						) : (
							null
						)
					)
				)
			)
	) : null;	
					
// processes all attributes and adds them as properties to the UML container
cached parseAttributes(ImportTransformationData data, uml::Model model, SchemaType schemaType, List[Attribute] attributeList, uml::Class createClass, uml::Package package):	
	traceMe("=> parseAttributes") ->
	(
		let attributeProperties = {} :
		attributeList != null ? attributeProperties.addAll(attributeList.select(e|getAttributeLocalPart(data, e) != null).collect(e|toProperty(data, model, createClass, e.simpleType, e.name, toType(data, model, e.type.prefix, getAttributeLocalPart(data, e), schemaType, package), e.form.toString(), e.^default, e.id, e.fixed, e.ref.prefix + ":" + e.ref.localPart, e.use.toString(),e.type.prefix + ":" + e.type.localPart, getAttMinSize(e), getAttMaxSize(e), schemaType, e.annotation, null, null, null, null)).select(e|e != null)) : null ->
		attributeList != null ? attributeProperties.addAll(attributeList.select(e|e.ref.localPart != null).collect(e|toPropertyWithRef(data, schemaType, model, createClass, e.name, getAttributeLocalPart(data, e), "1", "1", e.ref.prefix, e.ref.namespaceURI, getAttributeRefLocalPart(data, e), e, package)).select(e|e != null)) : null ->
		attributeList != null ? attributeProperties.addAll(attributeList.select(e|e.simpleType != null && e.simpleType.restriction != null).collect(e|toProperty(data, model, createClass, e.simpleType,e.name, toType(data, model, e.simpleType.restriction.base.prefix, getSimpleTypeBasePart(data, e.simpleType.eContainer, e.simpleType), schemaType, package), e.form.toString(), e.^default, e.id, e.fixed, e.ref.prefix + ":" + e.ref.localPart, e.use.toString(), e.type.prefix + ":" + e.type.localPart, getAttMinSize(e), getAttMaxSize(e), schemaType, e.simpleType.restriction.annotation, null, null, null, null)).select(e|e != null)) : null ->
		attributeList != null ? attributeProperties.addAll(attributeList.select(e|e.simpleType != null && e.simpleType.union != null).collect(e|
			let tmpType = (								
				e.simpleType.restriction == null || (e.simpleType.restriction != null && (e.simpleType.restriction.enumeration == null || e.simpleType.restriction.enumeration.size == 0)) ? toPrimitiveType(data, e, e.simpleType, schemaType, model, package) : (
						e.simpleType.restriction.enumeration != null && e.simpleType.restriction.enumeration.size > 0 ? toEnumeration(data, e, e.simpleType, schemaType, model, package, e.simpleType.restriction.enumeration.id, e.simpleType.restriction.enumeration.value) : null
					)			
			) :
			toProperty(data, model, createClass, e.simpleType,e.name, tmpType, e.form.toString(), e.^default, e.id, e.fixed, e.ref.prefix + ":" + e.ref.localPart, e.use.toString(), null, getAttMinSize(e), getAttMaxSize(e), schemaType, e.simpleType.restriction.annotation, null, null, null, null)
		).select(e|e != null)) : null ->
		attributeList != null ? attributeProperties.addAll(attributeList.select(e|e.simpleType != null && e.simpleType.list != null).collect(e|toProperty(data, model, createClass,e.simpleType,e.name, toType(data, model, e.simpleType.list.itemType.prefix, e.simpleType.list.itemType.localPart, schemaType, package), e.form.toString(), e.^default, e.id, e.fixed, e.ref.prefix + ":" + e.ref.localPart, e.use.toString(), e.type.prefix + ":" + e.type.localPart, getAttMinSize(e), getAttMaxSize(e), schemaType, e.simpleType.list.annotation, null, null, null, null)).select(e|e != null)) : null ->	
		attributeProperties.collect(e | setAttributeStereotype(e)) ->	
		createClass.ownedAttribute.addAll(attributeProperties)	
		//COME BACK ON 11TH we need to add enumeration for attributes with simple types restrictuons enums (restriction.enumeration.value != null ? package.packagedElement.add(toEnumeration(model, schemaType, primitiveType, restriction.enumeration.value, package)) : null) ->	
		// do union here too attributeList != null ? createClass.ownedAttribute.addAll(complexType.attribute.select(e|e.simpleType != null && e.simpleType.restriction != null).collect(e|toProperty(model, r,e.name, toType(model, e.simpleType.restriction.base.localPart, schemaType))).select(e|e != null)) : null ->
	);

// processes anyAttribute constructs and creates a unique name for the property before adding	
cached parseAnyAttribute(ImportTransformationData data, uml::Model model, SchemaType schemaType, Wildcard anyAttribute, uml::Class createClass, uml::Package package):	
	traceMe("=> parseAnyAttribute") ->
	(
		let type = getBOMObjectPrimitiveType(data) : 
		let newAnyAttributeName = data.addNewAnyAttributeName(anyAttribute, getAnyAttributeName(data, anyAttribute), "*") :	
		let tmpNamespaceList = (
			List.isInstance(anyAttribute.namespace) ? anyAttribute.namespace : {anyAttribute.namespace}
		) :
		let tmpProperty = toProperty(data, model, createClass, null, newAnyAttributeName, type, null, null, anyAttribute.id, null, null, null, null, null, null, schemaType, anyAttribute.annotation, null, tmpNamespaceList, anyAttribute.processContents.toString(), null) :
		createClass.ownedAttribute.add(tmpProperty)		
	);

// given an attribute group ref it extracts the referenced attribute group and returns it	
cached AttributeGroup extractAttributeGroup(ImportTransformationData data, AttributeGroupRef attributeGroupRef) :
	let refName = attributeGroupRef.ref.localPart :
	let refPrefix = attributeGroupRef.ref.prefix :
	let schemaWithAttrGroup = (
		refPrefix == null ? getParentSchemaType(attributeGroupRef.eContainer) : (			
			let schemaTypeList = (			
				let tempList = {} :			
				data.schemaTypes == null ? null : tempList.addAll(data.schemaTypes) ->			
				data.wsdlSchemaTypes == null ? null : tempList.addAll(data.wsdlSchemaTypes) ->			
				tempList
			) :						
			schemaTypeList.selectFirst(e | e.targetNamespace == attributeGroupRef.ref.namespaceURI) 
		)
	) :
	let topLevelAttrGroup = schemaWithAttrGroup.attributeGroup.selectFirst(e | e.name == refName) :	
	topLevelAttrGroup;

// given a group ref it extracts the referenced group and returns it	
cached ExplicitGroup extractGroupExplicitGroup(ImportTransformationData data, GroupRef groupRef, List[String] typeList) :
	let refGroupName = groupRef.ref.localPart :
	let refGroupPrefix = groupRef.ref.prefix :
	let schemaWithGroup = (
		refGroupPrefix == null ? getParentSchemaType(groupRef.eContainer) : (			
			let schemaTypeList = (			
				let tempList = {} :			
				data.schemaTypes == null ? null : tempList.addAll(data.schemaTypes) ->			
				data.wsdlSchemaTypes == null ? null : tempList.addAll(data.wsdlSchemaTypes) ->			
				tempList
			) :									
			schemaTypeList.selectFirst(e | e.targetNamespace == groupRef.ref.namespaceURI) 
		)
	) :
	let topLevelGroup = schemaWithGroup.group2.selectFirst(e | e.name == refGroupName) :	
	let parentGroupRefExplicitGroup = groupRef.eContainer :
	topLevelGroup.sequence.first() != null ? (
		let topGroupSequence = topLevelGroup.sequence.first() :
		topGroupSequence.setMinOccurs(groupRef.minOccurs) ->
		topGroupSequence.setMaxOccurs(groupRef.maxOccurs) ->
		typeList.add("S") ->
		data.addGroupRefParent(parentGroupRefExplicitGroup,topGroupSequence) ->
		topGroupSequence
	) : (
		topLevelGroup.choice.first() != null ? (
			let topGroupChoice = topLevelGroup.choice.first() :
			topGroupChoice.setMinOccurs(groupRef.minOccurs) ->
			topGroupChoice.setMaxOccurs(groupRef.maxOccurs) ->
			typeList.add("C") ->
			data.addGroupRefParent(parentGroupRefExplicitGroup,topGroupChoice) ->
			topGroupChoice
		) : (
			topLevelGroup.all.first() != null ? (
				let topGroupChoice = topLevelGroup.all.first() :
				topGroupChoice.setMinOccurs(groupRef.minOccurs) ->
				topGroupChoice.setMaxOccurs(groupRef.maxOccurs) ->
				typeList.add("A") ->
				data.addGroupRefParent(parentGroupRefExplicitGroup,topGroupChoice) ->
				topGroupChoice
			) : null
		)
	);

// parse annotations of a construct and add it as a comment on a classifier	
cached parseAnnotations(uml::Model model, SchemaType schemaType, AnnotationType annotation, uml::Classifier classifier, uml::Package package) :
	traceMe("=> parseAnnotations") ->
	(	
		let comment = createComment(annotation.documentation, annotation.appinfo) :
		comment != null && comment.body != null ? classifier.ownedComment.add(comment) : null  
	);

// parse annotations of a construct and add it as a comment on a property	
cached parseAnnotationsProp(uml::Model model, SchemaType schemaType, AnnotationType annotation, uml::Property property) :
	traceMe("=> parseAnnotationsProp") ->
	(	
		let comment = createComment(annotation.documentation, annotation.appinfo) :
		property != null && comment != null && comment.body != null ? property.ownedComment.add(comment) : null  
	);

// parse annotations of a construct and add it as a comment on a package
cached parseAnnotations(uml::Model model, SchemaType schemaType, AnnotationType annotation, uml::Package package) : 
	traceMe("=> parseAnnotations") ->	
	(	
		let comment = createComment(annotation.documentation, annotation.appinfo) :
		comment != null && comment.body != null ?  
		( 
			null			 
		) : null
	);	

// creates the actual uml comment
uml::Comment createComment(Collection docList, Collection appList) : let comment = new uml::Comment:	
	traceMe("=> createComment") ->
	docList.typeSelect(DocumentationType).collect(e|addCommentInfo(e, comment)) ->
	appList.typeSelect(AppinfoType).collect(e|addCommentInfo(e, comment)) ->
	comment;

// creates the actual uml comment info from doc type
addCommentInfo(DocumentationType docType, uml::Comment comment):	
	traceMe("=> addCommentInfo") ->
	docType.mixed.text.collect(e|addCommentInfo(e, comment));	

// creates the actual uml comment info from app info type	
addCommentInfo(AppinfoType appInfoType, uml::Comment comment):
	traceMe("=> addCommentInfo") ->	
	appInfoType.mixed.text.collect(e|addCommentInfo(e, comment));		

// sets the string  value against the new uml comment	
addCommentInfo(String strInfo, uml::Comment comment) :
	traceMe("=> addCommentInfo " + comment.body) ->
	comment.body == null ? comment.setBody(strInfo + " ") : comment.setBody(comment.body + strInfo + " ");

// get the min size for an attribute construct - ie o or 1 depending if use is set
cached String getAttMinSize(Attribute attribute) :	
	traceMe("=> getAttMinSize") ->
	attribute.use.toString() == 'required' ? '1' : '0';

// get the max size for an attribute construct - ie * or 1 depending if list is set	
cached String getAttMaxSize(Attribute attribute) :
	traceMe("=> getAttMaxSize") ->	
	attribute.simpleType.list != null ? 'unbounded' : '1';

// returns 0 for a min size for simple type	
cached String getSimpleMinSize(SimpleType simpleType) :
	traceMe("=> getSimpleMinSize") ->	
	'0';

// returns * or 1 for a max size for simple type depending on if it has a list set or not		
cached String getSimpleMaxSize(SimpleType simpleType) :
	traceMe("=> getSimpleMaxSize") ->	
	simpleType.list != null ? 'unbounded' : '1';
	
// returns 0 for a min size for simple content type	
cached String getSimpleMinSize(SchemaType schemaType, SimpleContentType simpleContentType) :
	traceMe("=> getSimpleMinSize") ->	
	'0';

// returns max size for a simple content type	
cached String getSimpleMaxSize(SchemaType schemaType, SimpleContentType simpleContentType) :
	traceMe("=> getSimpleMaxSize") ->
	simpleContentType.restriction == null && simpleContentType.^extension == null ? '1' : 
		(
			simpleContentType.restriction != null ? 
			(let simpleTypeName = simpleContentType.restriction.base.localPart : simpleTypeName != null ? getSimpleMaxSize(getSimpleTypeInSchema(schemaType, simpleTypeName))  : '1') 
			: 
			(let simpleTypeName = simpleContentType.^extension.base.localPart : simpleTypeName != null ? getSimpleMaxSize(getSimpleTypeInSchema(schemaType, simpleTypeName))  : '1')
		);  

// fetches a simple type corresponding to the localPart value in the schema
cached SimpleType getSimpleTypeInSchema(SchemaType schemaType, String localPart) :
	traceMe("=> getSimpleTypeInSchema") ->
	schemaType.eAllContents.typeSelect(xmlSchema::SimpleType).select(e|e.name == localPart).first();

// gets class with a particular name and creates it if not found
uml::Class getCreateClassByName(ImportTransformationData data, SchemaType schemaType, uml::Model model, String prefix, String namespaceURI, String localPart, uml::Package package) :
	traceMe("=>getCreateClassByName(): localPart="+localPart + " namespaceURI=" + namespaceURI + " prefix=" + prefix + " model=" + model.name + " package=" + package.name) ->	
	(
		
		
		let schemaTypeList = (			
			let tempList = {} :			
			data.schemaTypes == null ? null : tempList.addAll(data.schemaTypes) ->			
			data.wsdlSchemaTypes == null ? null : tempList.addAll(data.wsdlSchemaTypes) ->			
			tempList
		) :
				
		// XPD-3202: There may be more than one schemaType with this namespace. 
		// So we have to make sure we get the one with the type in it!!
		let schemaTypeForNamespace = 
		(
			let tempNs = _FindSchemaTypeForNamespaceContainingThisType(data, schemaType, prefix, namespaceURI, localPart, schemaTypeList):			
			tempNs == null ? 
				(
					traceMe("getCreateClassByName(): schemaTypeForNamespace is NULL" )
				):
				(
					traceMe("getCreateClassByName(): schemaTypeForNamespace is NOT NULL")
				) ->
			tempNs		
		):
		
		let tmpPackage = (			
			let packageName = data.getResolvedPackageNamespace(namespaceURI) :
			let existingModel = data.otherResultModels.selectFirst(e|e.name==packageName) :
			existingModel != null ? existingModel : (
				let existingPackage = findPackage(data, model, packageName) :		
				existingPackage != null ? existingPackage : package
			)
		) :		
		let tempClass = createReferencedClass(data, schemaTypeForNamespace, model, prefix, namespaceURI, localPart, tmpPackage) :		
		
		(tempClass == null && (prefix == null || prefix.trim().length == 0) ) ? createReferencedClass(data, schemaTypeForNamespace, model, localPart, tmpPackage) : tempClass
				
	);

// return whether the class represents an anonymous complex type
cached Boolean isAnonTypeClass(Class cls): 
	traceMe("=> isAnonTypeClass") ->	
	(
		let xsdBasedModelStereotype = getXSDNotationStereotype(cls, "XsdBasedClass") :
		let xsdIsAnonTypeValue = getXSDNotationProperty(cls, xsdBasedModelStereotype, "xsdIsAnonType") :	
		xsdIsAnonTypeValue == null || xsdIsAnonTypeValue.toString().trim().length == 0 ? false : (
			xsdIsAnonTypeValue == true || xsdIsAnonTypeValue.toString().toLowerCase().trim() == "true" ? true : false
		)
	);

// returns the substituation group namespaceURI:localPart string for use as a stereotype value for export code later on	
cached String getSubstitutionGroupString(xmlSchema::TopLevelElement topLevelElement) :
	topLevelElement == null ? "" : (
		topLevelElement.substitutionGroup == null ? "" : (
			topLevelElement.substitutionGroup.namespaceURI + ":" + topLevelElement.substitutionGroup.localPart
		)
	);

cached Object getFormForElementName(ImportTransformationData data, SchemaType schemaType, uml::Class tempClass) :
	traceMe("=> getFormForElementName") ->	
	(
		let tmpClassName = (
			isAnonTypeClass(tempClass) == true ? ReplaceLast(tempClass.name, "Type", "") : tempClass.name		
		) :	
		(
			let form = schemaType.eAllContents.typeSelect(Element).select(e|e.name == tmpClassName).first().form :				
			form != null ? form.toString() : (			
				schemaType.eAllContents.typeSelect(Element).select(e|getElementName(data, e) == tmpClassName).first().form.toString()
			)
		)
	);
	
cached Object getDefaultForElementName(ImportTransformationData data, SchemaType schemaType, uml::Class tempClass) :
	traceMe("=> getDefaultForElementName") ->	
	(
		let tmpClassName = (
			isAnonTypeClass(tempClass) == true ? ReplaceLast(tempClass.name, "Type", "") : tempClass.name		
		) :	
		(
			let defaultVal = schemaType.eAllContents.typeSelect(Element).select(e|e.name == tmpClassName).first().^default :				
			defaultVal != null ? defaultVal : (			
				schemaType.eAllContents.typeSelect(Element).select(e|getElementName(data, e) == tmpClassName).first().^default
			)
		)
	);
	
cached Object getIDForElementName(ImportTransformationData data, SchemaType schemaType, uml::Class tempClass) :
	traceMe("=> getIDForElementName") ->	
	(
		let tmpClassName = (
			isAnonTypeClass(tempClass) == true ? ReplaceLast(tempClass.name, "Type", "") : tempClass.name		
		) :	
		(
			let idVal = schemaType.eAllContents.typeSelect(Element).select(e|e.name == tmpClassName).first().id :				
			idVal != null ? idVal : (			
				schemaType.eAllContents.typeSelect(Element).select(e|getElementName(data, e) == tmpClassName).first().id
			)
		)
	);
	
cached Object getFixedForElementName(ImportTransformationData data, SchemaType schemaType, uml::Class tempClass) :
	traceMe("=> getFixedForElementName") ->	
	(
		let tmpClassName = (
			isAnonTypeClass(tempClass) == true ? ReplaceLast(tempClass.name, "Type", "") : tempClass.name		
		) :	
		(
			let fixedVal = schemaType.eAllContents.typeSelect(Element).select(e|e.name == tmpClassName).first().fixed :				
			fixedVal != null ? fixedVal : (			
				schemaType.eAllContents.typeSelect(Element).select(e|getElementName(data, e) == tmpClassName).first().fixed
			)
		)
	);
	
cached Object getNillableForElementName(ImportTransformationData data, SchemaType schemaType, uml::Class tempClass) :
	traceMe("=> getNillableForElementName") ->	
	(
		let tmpClassName = (
			isAnonTypeClass(tempClass) == true ? ReplaceLast(tempClass.name, "Type", "") : tempClass.name		
		) :	
		(
			let nillableVal = schemaType.eAllContents.typeSelect(Element).select(e|e.name == tmpClassName).first().nillable :				
			nillableVal != null ? nillableVal.toString() : (			
				schemaType.eAllContents.typeSelect(Element).select(e|getElementName(data, e) == tmpClassName).first().nillable.toString()
			)
		)
	);
	
cached Object getBlockForElementName(ImportTransformationData data, SchemaType schemaType, uml::Class tempClass) :
	traceMe("=> getBlockForElementName") ->	
	(
		let tmpClassName = (
			isAnonTypeClass(tempClass) == true ? ReplaceLast(tempClass.name, "Type", "") : tempClass.name		
		) :	
		(
			let blockVal = schemaType.eAllContents.typeSelect(Element).select(e|e.name == tmpClassName).first().block :				
			blockVal != null ? getBlockListValue(blockVal) : (			
				getBlockListValue(schemaType.eAllContents.typeSelect(Element).select(e|getElementName(data, e) == tmpClassName).first().block)
			)
		)
	);
		
cached String getMinOccursForElementName(ImportTransformationData data, SchemaType schemaType, uml::Class tempClass) :
	traceMe("=> getMinOccursForElementName") ->	
	(
		let tmpClassName = (
			isAnonTypeClass(tempClass) == true ? ReplaceLast(tempClass.name, "Type", "") : tempClass.name		
		) :		
		(
			let minOccurs = schemaType.eAllContents.typeSelect(Element).select(e|e.name == tmpClassName).first().minOccurs :
			minOccurs != null ? minOccurs.toString() : (
				schemaType.eAllContents.typeSelect(Element).select(e|getElementName(data, e) == tmpClassName).first().minOccurs.toString()
			)
		)
	); 

cached Object getMaxOccursForElementName(ImportTransformationData data, SchemaType schemaType, uml::Class tempClass) :
	traceMe("=> getMaxOccursForElementName") ->	
	(
		let tmpClassName = (
			isAnonTypeClass(tempClass) == true ? ReplaceLast(tempClass.name, "Type", "") : tempClass.name		
		) :	
		(
			let maxOccurs = schemaType.eAllContents.typeSelect(Element).select(e|e.name == tmpClassName).first().maxOccurs :				
			maxOccurs != null ? maxOccurs.toString() : (			
				schemaType.eAllContents.typeSelect(Element).select(e|getElementName(data, e) == tmpClassName).first().maxOccurs.toString()
			)
		)
	);
	
cached String getMinOccursForElementName2(ImportTransformationData data, SchemaType schemaType, String name, String ownerName) :
	traceMe("=> getMinOccursForElementName2") ->
	(	
		let complexType = schemaType.eAllContents.typeSelect(ComplexType).select(e|e.name == ownerName && ownerName != null).first() :	
		complexType != null ? (
			complexType.eAllContents.typeSelect(Element).select(e|getElementName(data, e) == name).first().minOccurs.toString()
		) : (		
			let parentElementType = schemaType.eAllContents.typeSelect(xmlSchema::Element).select(e|getElementName(data, e) == ownerName && ownerName != null).first() :
			parentElementType != null ? (
				parentElementType.eAllContents.typeSelect(Element).select(e|getElementName(data, e) == name).first().minOccurs.toString()
			) : (
				let parentElement = schemaType.eAllContents.typeSelect(xmlSchema::Element).select(e|getElementName(data, e) == ownerName.replaceAll("Type", "") && ownerName != null).first() :
				parentElement != null ? (
					parentElement.eAllContents.typeSelect(Element).select(e|getElementName(data, e) == name).first().minOccurs.toString()				
				) : (
					schemaType.eAllContents.typeSelect(Element).select(e|getElementName(data, e) == name).first().minOccurs.toString()
				)
			)
		)
	); 

cached Object getMaxOccursForElementName2(ImportTransformationData data, SchemaType schemaType, String name, String ownerName) :
	traceMe("=> getMaxOccursForElementName2") ->
	(
		let complexType = schemaType.eAllContents.typeSelect(ComplexType).select(e|e.name == ownerName && ownerName != null).first() :	
		complexType != null ? (
			complexType.eAllContents.typeSelect(Element).select(e|getElementName(data, e) == name).first().maxOccurs.toString()
		) : (		
			let parentElementType = schemaType.eAllContents.typeSelect(xmlSchema::Element).select(e|getElementName(data, e) == ownerName && ownerName != null).first() :
			parentElementType != null ? (
				parentElementType.eAllContents.typeSelect(Element).select(e|getElementName(data, e) == name).first().maxOccurs.toString()
			) : (
				let parentElement = schemaType.eAllContents.typeSelect(xmlSchema::Element).select(e|getElementName(data, e) == ownerName.replaceAll("Type", "") && ownerName != null).first() :
				parentElement != null ? (
					parentElement.eAllContents.typeSelect(Element).select(e|getElementName(data, e) == name).first().maxOccurs.toString()				
				) : (
					schemaType.eAllContents.typeSelect(Element).select(e|getElementName(data, e) == name).first().maxOccurs.toString()
				)
			)
		)
	);
	
cached uml::Generalization createGeneralization(uml::Package package, uml::Classifier parentClass, uml::Classifier childClass):	
	traceMe("=>createGeneralization(): parentClass=" + parentClass.name + " childClass=" +childClass.name) ->
	(parentClass != null && childClass != null && parentClass != childClass) ?
	(		
		parentClass.generalization.first() == null ? (
			let r = new uml::Generalization :	
			r.setGeneral(childClass) ->
			parentClass.generalization.add(r) ->
			r
		) : parentClass.generalization.first()		
	) : 
	(
		traceMe("<=createGeneralization(): NULL") ->
		null
	);

// get primitive type by name and if not found in package then search the ref the packages/models
// XPD-5930: lookInOtherPackages is introduced to differentiate between creation of primitive type and finding it as a type	
uml::PrimitiveType getPrimitiveTypeByName(ImportTransformationData data, uml::Model model, uml::Package package, String name, boolean lookInOtherPackages):
	traceMe("=>getPrimitiveTypeByName(): " + name + " in package " + package.name) ->
	(
		let primType = (
			let tmpPrim = package.eAllContents.typeSelect(uml::PrimitiveType).select(e|e.name == name && Property.isInstance(e) == false).first() :
			traceMe("prim found = "+ tmpPrim) ->
			tmpPrim != null ? (			
				tmpPrim
			) : (			
				lookInOtherPackages ? (
					data.otherResultModels.eAllContents.typeSelect(uml::PrimitiveType).select(e|e.name == name && Property.isInstance(e) == false).first()
				) : null
			)
		) :
		traceMe("<=getPrimitiveTypeByName()") ->		
		primType
	);




// get enumeration by name and if not found in package then search the ref the packages/models		
// XPD-4041: lookInOtherPackages is introduced to differentiate between creation of enum and finding it as a type
uml::Enumeration getEnumTypeByName(ImportTransformationData data, uml::Package package, String name, boolean lookInOtherPackages):
	traceMe("=>getEnumTypeByName(): name = " + name + "package.name = " + package.name) ->
	(
		let enumType = (
			let tmpEnumType = package.eAllContents.typeSelect(uml::Enumeration).select(e|e.name == name && Property.isInstance(e) == false).first() :
			//let tmpEnumType = package.eAllContents.typeSelect(uml::Enumeration).select(e|e.name == name).first() :
			
			// XPD-4041: find the enumeration in the given package. 
			// If lookInOtherPackages is true only then search for in packages otherwise return null so it can create a new one 
			tmpEnumType != null ? (
				tmpEnumType 
			) : (
				lookInOtherPackages ? (
					data.otherResultModels.eAllContents.typeSelect(uml::Enumeration).select(e|e.name == name && Property.isInstance(e) == false).first()
				) : null
			) 			
		) :
		traceMe("=>getEnumTypeByName(): name = " + name + " enumType = " + enumType) ->
		enumType
	);

// get class by name and if not found in package then search the ref the packages/models	
uml::Class getClassByName(ImportTransformationData data, uml::Package package, String name, String anonymousComplexTypeName, boolean lookInOtherPackages):	
	traceMe("=> getClassByName " + name + " in package "+package) ->
	name != null ? (
		let clsName = (
			let tmpClsName = package.eAllContents.typeSelect(uml::Class).select(e|e.name == name && isAnonClass(e) == false).first() :
			tmpClsName != null ? tmpClsName : (
				lookInOtherPackages ? (
					let tmpClsName2 = data.otherResultModels.eAllContents.typeSelect(uml::Class).select(e|e.name == name && isAnonClass(e) == false).first() :
					tmpClsName2 != null ? tmpClsName2 : package.getModel().eAllContents.typeSelect(uml::Class).select(e|e.name == name && isAnonClass(e) == false).first()
				) : null
			)
		) :
		clsName
	) : null;	

cached String getClassStereotypeName(uml::Class cls) :
	traceMe("=> getClassStereotypeName") ->
	(
		let appliedStereotype = cls.getAppliedStereotypes().select(e|e.name == "XsdBasedClass").first() :
		let tempName = getStereotypeValue(cls, appliedStereotype, "xsdName") :
		tempName != null && tempName.trim().length > 0 ? tempName : cls.name
	);
	
cached List getBlockListValue(Object block) :
	List.isInstance(block) ? block : (
		block != null ? {block.toString()} : {}
	);
	
cached List getFinalListValue(Object finalVal) :
	traceMe("finalVal is " + finalVal) ->
	traceMe("finalVal metatype is " + finalVal.metaType.toString()) ->
	List.isInstance(finalVal) ? finalVal : (
		finalVal != null ? {finalVal.toString()} : {}
	);

uml::Property toProperty(ImportTransformationData data, uml::Model model, uml::Class class, SimpleType simpleType, String name, uml::Type type, String form, String ^default, String id, String fixed, String ref, String use, String xsdType, String minOccurs, Object maxOccurs, SchemaType schemaType, AnnotationType annotation, String nillable, List namespace, String processContents, List block):	 
	traceMe("=> toProperty 1" + type) ->
	(
		let schemaTypeList = (			
			let tempList = {} :								
			data.schemaTypes == null ? null : tempList.addAll(data.schemaTypes) ->
			data.wsdlSchemaTypes == null ? null : tempList.addAll(data.wsdlSchemaTypes) ->
			tempList
		) :		
		let createdProperty = (
			Property.isInstance(type) ? toProperty(data, model, class, name, type, form, ^default, id, fixed, ref, use, xsdType, minOccurs, maxOccurs, simpleType.restriction.enumeration.value.toString(), nillable, namespace, processContents) : toProperty(data, model, class, name, type, form, ^default, id, fixed, ref, use, xsdType, minOccurs, maxOccurs, simpleType.restriction.enumeration.value.toString(), nillable, namespace, processContents, block, isSimpleType(data, simpleType.restriction))
		) :	
		createdProperty != null && simpleType != null && simpleType.restriction != null ? (
			let maxLengthFromRestriction = (
				simpleType.restriction.maxLength.first().value != null ? simpleType.restriction.maxLength.first().value : simpleType.restriction.length.first().value
			) :
			let maxValue = _getActualLengthFromRestrictionForSimpleType(data, xsdType, maxLengthFromRestriction) :
			applyPrimitiveStereotypeValues(createdProperty, simpleType.name, simpleType.id, getFinalListValue(simpleType.final), simpleType.restriction.id, simpleType.restriction.base.prefix + ":" + simpleType.restriction.base.localPart) ->
			setOtherMaxLengthValues(createdProperty, simpleType.restriction.maxLength.first().id, simpleType.restriction.maxLength.first().fixed, maxValue, null) ->		
			setOtherFractionDigitsValues(createdProperty, simpleType.restriction.fractionDigits.first().id, simpleType.restriction.fractionDigits.first().fixed, simpleType.restriction.fractionDigits.first().value, null) ->		
			setOtherLengthValues(createdProperty, simpleType.restriction.length.first().id, simpleType.restriction.length.first().fixed, simpleType.restriction.length.first().value, null) -> 		
			setOtherMaxExclusiveValues(createdProperty, simpleType.restriction.maxExclusive.first().id, simpleType.restriction.maxExclusive.first().fixed, simpleType.restriction.maxExclusive.first().value, null) -> 
			setOtherMaxInclusiveValues(createdProperty, simpleType.restriction.maxInclusive.first().id, simpleType.restriction.maxInclusive.first().fixed, simpleType.restriction.maxInclusive.first().value, null) -> 
			setOtherMinExclusiveValues(createdProperty, simpleType.restriction.minExclusive.first().id, simpleType.restriction.minExclusive.first().fixed, simpleType.restriction.minExclusive.first().value, null) -> 
			setOtherMinInclusiveValues(createdProperty, simpleType.restriction.minInclusive.first().id, simpleType.restriction.minInclusive.first().fixed, simpleType.restriction.minInclusive.first().value, null) -> 
			setOtherMinLengthValues(createdProperty, simpleType.restriction.minLength.first().id, simpleType.restriction.minLength.first().fixed, simpleType.restriction.minLength.first().value, null) -> 
			setOtherPatternValues(createdProperty, simpleType.restriction.pattern.first().id, simpleType.restriction.pattern.first().fixed, simpleType.restriction.pattern.first().value, null) -> 
			setOtherTotalDigitsValues(createdProperty, simpleType.restriction.totalDigits.first().id, simpleType.restriction.totalDigits.first().fixed, simpleType.restriction.totalDigits.first().value, null) -> 
			setOtherWhitespaceValues(createdProperty, simpleType.restriction.whiteSpace.first().id, simpleType.restriction.whiteSpace.first().fixed, simpleType.restriction.whiteSpace.first().value, null) ->
			setOtherDefaultValues(createdProperty, ^default) 
		) : null ->
		
		parseAnnotationsProp(model, schemaType, annotation, createdProperty) ->
		createdProperty
	);
	
uml::Property toProperty(ImportTransformationData data, uml::Model model, uml::Class class, SimpleType simpleType, String name, String enumLiterals, uml::Type type, String form, String ^default, String id, String fixed, String ref, String use, String xsdType, String minOccurs, Object maxOccurs, SchemaType schemaType, AnnotationType annotation, String nillable, List namespace, String processContents, List block):	
	traceMe("=> toProperty 2") ->
	(
		let schemaTypeList = (			
			let tempList = {} :								
			data.schemaTypes == null ? null : tempList.addAll(data.schemaTypes) ->
			data.wsdlSchemaTypes == null ? null : tempList.addAll(data.wsdlSchemaTypes) ->
			tempList
		) :		
		let createdProperty = toProperty(data, model, class, name, type, form, ^default, id, fixed, ref, use, xsdType, minOccurs, maxOccurs, enumLiterals, nillable, namespace, processContents, block, isSimpleType(data, simpleType.restriction)) :	
		let maxLengthFromRestriction = (
			simpleType.restriction.maxLength.first().value != null ? simpleType.restriction.maxLength.first().value : simpleType.restriction.length.first().value
		) :
		let maxValue = _getActualLengthFromRestrictionForSimpleType(data, xsdType, maxLengthFromRestriction) :
		createdProperty != null && simpleType != null && simpleType.restriction != null ? (
			applyPrimitiveStereotypeValues(createdProperty, simpleType.name, simpleType.id, getFinalListValue(simpleType.final), simpleType.restriction.id, simpleType.restriction.base.prefix + ":" + simpleType.restriction.base.localPart) ->
			setOtherMaxLengthValues(createdProperty, simpleType.restriction.maxLength.first().id, simpleType.restriction.maxLength.first().fixed, maxValue, null) ->		
			setOtherFractionDigitsValues(createdProperty, simpleType.restriction.fractionDigits.first().id, simpleType.restriction.fractionDigits.first().fixed, simpleType.restriction.fractionDigits.first().value, null) ->		
			setOtherLengthValues(createdProperty, simpleType.restriction.length.first().id, simpleType.restriction.length.first().fixed, simpleType.restriction.length.first().value, null) -> 		
			setOtherMaxExclusiveValues(createdProperty, simpleType.restriction.maxExclusive.first().id, simpleType.restriction.maxExclusive.first().fixed, simpleType.restriction.maxExclusive.first().value, null) -> 
			setOtherMaxInclusiveValues(createdProperty, simpleType.restriction.maxInclusive.first().id, simpleType.restriction.maxInclusive.first().fixed, simpleType.restriction.maxInclusive.first().value, null) -> 
			setOtherMinExclusiveValues(createdProperty, simpleType.restriction.minExclusive.first().id, simpleType.restriction.minExclusive.first().fixed, simpleType.restriction.minExclusive.first().value, null) -> 
			setOtherMinInclusiveValues(createdProperty, simpleType.restriction.minInclusive.first().id, simpleType.restriction.minInclusive.first().fixed, simpleType.restriction.minInclusive.first().value, null) -> 
			setOtherMinLengthValues(createdProperty, simpleType.restriction.minLength.first().id, simpleType.restriction.minLength.first().fixed, simpleType.restriction.minLength.first().value, null) -> 
			setOtherPatternValues(createdProperty, simpleType.restriction.pattern.first().id, simpleType.restriction.pattern.first().fixed, simpleType.restriction.pattern.first().value, null) -> 
			setOtherTotalDigitsValues(createdProperty, simpleType.restriction.totalDigits.first().id, simpleType.restriction.totalDigits.first().fixed, simpleType.restriction.totalDigits.first().value, null) -> 
			setOtherWhitespaceValues(createdProperty, simpleType.restriction.whiteSpace.first().id, simpleType.restriction.whiteSpace.first().fixed, simpleType.restriction.whiteSpace.first().value, null) ->
			setOtherDefaultValues(createdProperty, ^default) 
		) : null ->
		
		parseAnnotationsProp(model, schemaType, annotation, createdProperty) ->
		createdProperty
	);
	
cached String getTopLevelElementOrAttributeName(Object obj) :
	SchemaType.isInstance(obj) ? null : (		
		TopLevelElement.isInstance(obj) || TopLevelAttribute.isInstance(obj) ? obj.name : getTopLevelElementOrAttributeName(obj.eContainer)
	);

cached uml::Property toPropertyWithRef(ImportTransformationData data, SchemaType schemaType, uml::Model model, uml::Class class, String name, String type, String minOccurs, Object maxOccurs, String refPrefix, String refNamespace, String refLocalPart, Object elementOrAttributeWithRef, uml::Package package):		
		let schemaTypeList = (			
			let tempList = {} :								
			data.schemaTypes == null ? null : tempList.addAll(data.schemaTypes) ->
			data.wsdlSchemaTypes == null ? null : tempList.addAll(data.wsdlSchemaTypes) ->
			tempList
		) :
		traceMe("toPropertyWithRef in class "+class.name) ->
		Element.isInstance(elementOrAttributeWithRef) ? (		
			let refElement = (
					let tmpRefElem = getReferencedElement(data, schemaType, class, refPrefix ,refLocalPart, refNamespace) :
					tmpRefElem != null ? tmpRefElem : getReferencedElement(data, schemaType, class, refPrefix ,refLocalPart, null)
			) :
			refElement != null ? (
				let refsToSelfTopContainer = (
					let topLevelContainerName = getTopLevelElementOrAttributeName(elementOrAttributeWithRef) :
					topLevelContainerName == null ? {} : (
						refElement.eAllContents.typeSelect(Element).select(e|e.ref.namespaceURI == schemaType.targetNamespace && e.ref.localPart == topLevelContainerName)
					)
				) :
				let tmpSchema = (						 		
					schemaTypeList.typeSelect(xmlSchema::SchemaType).select(e | e.element.contains(refElement)).first()
				) : 
				refsToSelfTopContainer.size == 0 ? (
					let elements = {}.add(refElement) :
					
					let topLevelClassiffierList = {} :
					
					elements.select(e|(e.complexType == null && e.type == null && e.ref == null && e.simpleType == null && xmlSchema::SchemaType.isInstance(e.eContainer) == true && isComplexType(data, tmpSchema, e.type.namespaceURI, getElementLocalPart(data,e)) == false)).collect(e|topLevelClassiffierList.add(createRootElementPrimitiveType(data, e, false, true, tmpSchema, model, getTopLevelPackage(data, model, e.eContainer)))).select(e| e!= null)->
						
					elements.select(e|(e.complexType == null && e.type != null && xmlSchema::SchemaType.isInstance(e.eContainer) == true && isComplexType(data, tmpSchema, e.type.namespaceURI, getElementLocalPart(data,e)) == false)).collect(e|topLevelClassiffierList.add(createRootElementPrimitiveType(data, e, false, isKnownNamespace(e.type.namespaceURI), tmpSchema, model, getTopLevelPackage(data, model, e.eContainer)))).select(e| e!= null)->
																																																													
					elements.select(e|(e.simpleType != null && e.simpleType.restriction != null && (e.simpleType.restriction.enumeration == null || e.simpleType.restriction.enumeration.size == 0) && e.type == null)).select(e|xmlSchema::SchemaType.isInstance(e.eContainer) == true).collect(e|topLevelClassiffierList.add(toAnonymousRootElementPrimitiveType(data, e, e.simpleType, tmpSchema, model, getTopLevelPackage(data, model, e.eContainer), isKnownNamespace(e.simpleType.restriction.base.namespaceURI)))).select(e| e!= null)->
					
					elements.select(e|(e.simpleType != null && e.simpleType.restriction != null && e.simpleType.restriction.enumeration.size > 0 && e.type == null)).select(e|xmlSchema::SchemaType.isInstance(e.eContainer) == true).collect(e|topLevelClassiffierList.add(toAnonymousRootElementEnumeration(data, e, e.simpleType, tmpSchema, model, getTopLevelPackage(data, model, e.eContainer), e.simpleType.restriction.enumeration.id, e.simpleType.restriction.enumeration.value, isKnownNamespace(e.simpleType.restriction.base.namespaceURI)))).select(e| e!= null)->
					
					elements.select(e|(e.simpleType != null && e.simpleType.union != null && e.type == null)).select(e|xmlSchema::SchemaType.isInstance(e.eContainer) == true).collect(e|topLevelClassiffierList.add(toAnonymousRootElementPrimitiveType(data, e, e.simpleType, tmpSchema, model, getTopLevelPackage(data, model, e.eContainer), false))).select(e| e!= null)->
					
					elements.select(e|(e.complexType == null && e.type != null && isComplexType(data, tmpSchema, e.type.namespaceURI, getElementLocalPart(data,e)))).select(e|xmlSchema::SchemaType.isInstance(e.eContainer) == true).collect(e| topLevelClassiffierList.add(toRootElementClass(data, e, tmpSchema, e.type.namespaceURI, getElementLocalPart(data, e),  model, getTopLevelPackage(data, model, e.eContainer)))) ->
					
					elements.select(e|(e.complexType == null && e.type == null && e.ref != null && isComplexType(data, tmpSchema, e.type.namespaceURI, getElementLocalPart(data,e)))).select(e|xmlSchema::SchemaType.isInstance(e.eContainer) == true).collect(e| topLevelClassiffierList.add(toRootElementClass(data, e, tmpSchema, e.ref.namespaceURI, e.ref.localPart,  model, getTopLevelPackage(data, model, e.eContainer)))) ->
						
					elements.select(e|(e.complexType != null && e.type == null)).select(e|xmlSchema::SchemaType.isInstance(e.eContainer) == true).collect(e| topLevelClassiffierList.add(toAnonymousRootElementClass(data, e,e.complexType, tmpSchema, model, getTopLevelPackage(data, model, e.eContainer)))) ->
					
					topLevelClassiffierList.size > 0 ? createRefCompositionProperty(data, package, class, topLevelClassiffierList.first(), refNamespace + ":" + refElement.name, getElementName(data, refElement), getElementLocalPart(data, refElement), minOccurs, maxOccurs) : null
				) : (
					let tmpPackage = (			
						let packageName = data.getResolvedPackageNamespace(tmpSchema.targetNamespace) :
						let existingModel = data.otherResultModels.selectFirst(e|e.name==packageName) :
						existingModel != null ? existingModel : (
							let existingPackage = findPackage(data, model, packageName) :		
							existingPackage != null ? existingPackage : package
						)
					) : 
					let tmpRefClass =  (
						let tmpCls = tmpPackage.eAllContents.typeSelect(uml::Class).select(e|e.name == (refElement.name+"Type") && isAnonClass(e) == true).first() :
						tmpCls != null ? tmpCls : (							
							let cls = createAnonymousClass((refElement.name+"Type__tibRef"),tmpPackage) :
							traceMe("Created temporary cls for refElement: '"+cls.name+"' in package: "+package.name) ->
							setAnonStereotypeValue(cls, false) ->
							cls
						)
					) :
					traceMe("contents is is "+ tmpPackage.packagedElement) ->
					traceMe("tmpRefClass "+tmpRefClass) ->
					tmpRefClass != null ? createRefCompositionProperty(data, package, class, tmpRefClass, refNamespace + ":" + refElement.name, getElementName(data, refElement), getElementLocalPart(data, refElement), minOccurs, maxOccurs) : null
				)
			) : null
		) : (
			let refAttribute = (
				let tmpRefAttr = getReferencedAttribute(data, schemaType, class, refPrefix ,refLocalPart, refNamespace) :
				tmpRefAttr != null ? tmpRefAttr : getReferencedAttribute(data, schemaType, class, refPrefix ,refLocalPart, null)
			) :	
			refAttribute != null ? (
				let tmpSchema = (						 		
					schemaTypeList.typeSelect(xmlSchema::SchemaType).select(e | e.attribute.contains(refAttribute)).first()
				) : 
				let attributes = {}.add(refAttribute) :
				
				let topLevelClassiffierList = {} :
			
				attributes.select(e|(e.type == null && e.ref == null && e.simpleType == null && isComplexType(data, tmpSchema, e.type.namespaceURI, getAttributeLocalPart(data, e)) == false)).select(e|xmlSchema::SchemaType.isInstance(e.eContainer) == true).collect(e|topLevelClassiffierList.add(createRootAttributePrimitiveType(data, e, false, true, tmpSchema, model, getTopLevelPackage(data, model, e.eContainer)))).select(e| e!= null)->
		
				attributes.select(e|(e.type != null && isComplexType(data, tmpSchema, e.type.namespaceURI, getAttributeLocalPart(data, e)) == false)).select(e|xmlSchema::SchemaType.isInstance(e.eContainer) == true).collect(e|topLevelClassiffierList.add(createRootAttributePrimitiveType(data, e, false, isKnownNamespace(e.type.namespaceURI), tmpSchema, model, getTopLevelPackage(data, model, e.eContainer)))).select(e| e!= null)->
			
				attributes.select(e|(e.simpleType != null && e.simpleType.restriction != null && (e.simpleType.restriction.enumeration == null || e.simpleType.restriction.enumeration.size == 0) && e.type == null)).select(e|xmlSchema::SchemaType.isInstance(e.eContainer) == true).collect(e|topLevelClassiffierList.add(toAnonymousRootAttributePrimitiveType(data, e, e.simpleType, tmpSchema, model, getTopLevelPackage(data, model, e.eContainer), isKnownNamespace(e.simpleType.restriction.base.namespaceURI)))).select(e| e!= null)->
			
				attributes.select(e|(e.simpleType != null && e.simpleType.restriction != null && e.simpleType.restriction.enumeration.size > 0 && e.type == null)).select(e|xmlSchema::SchemaType.isInstance(e.eContainer) == true).collect(e|topLevelClassiffierList.add(toAnonymousRootAttributeEnumeration(data, e, e.simpleType, tmpSchema, model, getTopLevelPackage(data, model, e.eContainer), e.simpleType.restriction.enumeration.id, e.simpleType.restriction.enumeration.value, isKnownNamespace(e.simpleType.restriction.base.namespaceURI)))).select(e| e!= null)->
			
				attributes.select(e|(e.simpleType != null && e.simpleType.union != null && e.type == null)).select(e|xmlSchema::SchemaType.isInstance(e.eContainer) == true).collect(e|topLevelClassiffierList.add(toAnonymousRootAttributePrimitiveType(data, e, e.simpleType, tmpSchema, model, getTopLevelPackage(data, model, e.eContainer), false))).select(e| e!= null)->
				
				topLevelClassiffierList.size > 0 ? (
					let tmpProperty = createRefCompositionProperty(data, package, class, topLevelClassiffierList.first(), refNamespace + ":" + refAttribute.name, getAttributeName(data, refAttribute), getAttributeLocalPart(data, refAttribute), "0", maxOccurs) :
					setAttributeStereotype(tmpProperty) ->
					tmpProperty
				) : null
			) : null
		);
	
cached Element getReferencedElement(ImportTransformationData data, SchemaType schemaType, uml::Class class, String refPrefix, String refLocalPart, String mappedNamespaceFromPrefix) : 
	traceMe("=> getReferencedElement") ->
	(
		let schemaTypeList = (			
			let tempList = {} :			
			data.schemaTypes == null ? null : tempList.addAll(data.schemaTypes) ->			
			data.wsdlSchemaTypes == null ? null : tempList.addAll(data.wsdlSchemaTypes) ->			
			tempList
		) :	
		let schemaWithReferencedElement = schemaTypeList.typeSelect(xmlSchema::SchemaType).select(e|e.targetNamespace == mappedNamespaceFromPrefix).first() :	
		schemaWithReferencedElement != null ? (
			isKnownNamespace(mappedNamespaceFromPrefix) ? schemaType.eAllContents.typeSelect(xmlSchema::TopLevelElement).selectFirst(e|e.name == refLocalPart) : schemaWithReferencedElement.eAllContents.typeSelect(xmlSchema::TopLevelElement).selectFirst(e|e.name == refLocalPart)
		) : (
			mappedNamespaceFromPrefix != null ? null : (
				schemaTypeList.eAllContents.typeSelect(xmlSchema::TopLevelElement).selectFirst(e|e.name == refLocalPart)
			)
		)
	);
	
cached Attribute getReferencedAttribute(ImportTransformationData data, SchemaType schemaType, uml::Class class, String refPrefix, String refLocalPart, String mappedNamespaceFromPrefix) : 
	traceMe("=> getReferencedAttribute ") ->
	(
		let schemaTypeList = (			
			let tempList = {} :			
			data.schemaTypes == null ? null : tempList.addAll(data.schemaTypes) ->			
			data.wsdlSchemaTypes == null ? null : tempList.addAll(data.wsdlSchemaTypes) ->			
			tempList
		) :	
		let schemaWithReferencedAttribute = schemaTypeList.typeSelect(xmlSchema::SchemaType).select(e|e.targetNamespace == mappedNamespaceFromPrefix).first() :
		schemaWithReferencedAttribute != null ? (
			isKnownNamespace(mappedNamespaceFromPrefix) ? schemaType.eAllContents.typeSelect(xmlSchema::Attribute).selectFirst(e|e.name == refLocalPart) : schemaWithReferencedAttribute.eAllContents.typeSelect(xmlSchema::Attribute).selectFirst(e|e.name == refLocalPart)
		) : (
			mappedNamespaceFromPrefix != null ? null : (
				schemaTypeList.eAllContents.typeSelect(xmlSchema::Attribute).selectFirst(e|e.name == refLocalPart)
			)
		)
	);	
	
cached ComplexType getReferencedComplexTypeContainingSimpleType(ImportTransformationData data, SchemaType schemaType, String refPrefix, String refLocalPart) :
	traceMe("=> getReferencedComplexTypeContainingSimpleType") ->
	schemaType.eAllContents.typeSelect(xmlSchema::ComplexType).selectFirst(e|getComplexName(data, e) == refLocalPart && e.simpleContent != null);
	
cached SimpleType getReferencedSimpleType(SchemaType schemaType, String refPrefix, String refLocalPart) :
	traceMe("=> getReferencedSimpleType") ->
	schemaType.eAllContents.typeSelect(xmlSchema::SimpleType).selectFirst(e|e.name == refLocalPart);
	
cached uml::Classifier createReferencedClass(ImportTransformationData data, SchemaType schemaType,uml::Model model, Element refElement, String refPrefix, String refNamespace, String refLocalPart, uml::Package package) :	
	traceMeDebug("=> createReferencedClass 1 refElement = " + refLocalPart) ->
	(
		let schemaTypeList = (			
			let tempList = {} :			
			data.schemaTypes == null ? null : tempList.addAll(data.schemaTypes) ->			
			data.wsdlSchemaTypes == null ? null : tempList.addAll(data.wsdlSchemaTypes) ->			
			tempList
		) :
		let schemaWithReferencedElement = schemaTypeList.typeSelect(xmlSchema::SchemaType).select(e|e.targetNamespace == refNamespace).first() :		
		let classFromElement = (
			let tmpSchema = (
				isKnownNamespace(refNamespace) ? schemaType : schemaWithReferencedElement
			) :		
			let tmpPackage = (			
				let packageName = data.getResolvedPackageNamespace(tmpSchema.targetNamespace) :
				let existingModel = data.otherResultModels.selectFirst(e|e.name==packageName) :
				existingModel != null ? existingModel : (
					let existingPackage = findPackage(data, model, packageName) :		
					existingPackage != null ? existingPackage : package
				)
			) :		
			let topLevelElement = (
				let tmpTopLevelElement = tmpSchema.eAllContents.typeSelect(xmlSchema::TopLevelElement).select(e|e.name == refLocalPart).first() :
				tmpTopLevelElement != null ? tmpTopLevelElement : schemaTypeList.eAllContents.typeSelect(xmlSchema::TopLevelElement).select(e|e.name == refLocalPart).first()
			) :
			traceMe("schema with reference element " + schemaWithReferencedElement.targetNamespace) ->
			topLevelElement == null ? null : (
				let tmpSchema = (SchemaType)topLevelElement.eContainer :
				let tmpPackage = (			
					let packageName = data.getResolvedPackageNamespace(tmpSchema.targetNamespace) :
					let existingModel = data.otherResultModels.selectFirst(e|e.name==packageName) :
					existingModel != null ? existingModel : (
						let existingPackage = findPackage(data, model, packageName) :		
						existingPackage != null ? existingPackage : package
					)
				) :
				let topLevelLocalPart = (
					getElementLocalPart(data, topLevelElement) != null ? getElementLocalPart(data, topLevelElement) : (
						getSimpleTypeBasePart(data, topLevelElement, topLevelElement.simpleType) != null ? getSimpleTypeBasePart(data, topLevelElement, topLevelElement.simpleType) : null
					)
				) :
				traceMe("toppy") ->
				topLevelLocalPart == null && topLevelElement.simpleType.union == null ? (schemaWithReferencedElement.eAllContents.typeSelect(xmlSchema::TopLevelElement).select(e|e.name == topLevelLocalPart).collect(e|toClass(data, e, tmpSchema, model, tmpPackage)) -> null)  : (							
					topLevelElement.complexType == null && topLevelElement.type != null && isComplexType(data, tmpSchema, topLevelElement.type.namespaceURI, getElementLocalPart(data, topLevelElement)) == false ? (						
						createRootElementPrimitiveType(data, topLevelElement, false, isKnownNamespace(topLevelElement.type.namespaceURI), tmpSchema, model, tmpPackage)
					) : (
						topLevelElement.simpleType != null && topLevelElement.simpleType.restriction != null && (topLevelElement.simpleType.restriction.enumeration == null || topLevelElement.simpleType.restriction.enumeration.size == 0) && topLevelElement.type == null ? (				
							toAnonymousRootElementPrimitiveType(data, topLevelElement, topLevelElement.simpleType, tmpSchema, model, tmpPackage, isKnownNamespace(topLevelElement.simpleType.restriction.base.namespaceURI))							
						) : (
							topLevelElement.simpleType != null && topLevelElement.simpleType.restriction != null && topLevelElement.simpleType.restriction.enumeration.size > 0 && topLevelElement.type == null ? (
								toAnonymousRootElementEnumeration(data, topLevelElement, topLevelElement.simpleType, tmpSchema, model, tmpPackage, topLevelElement.simpleType.restriction.enumeration.id, topLevelElement.simpleType.restriction.enumeration.value, isKnownNamespace(topLevelElement.simpleType.restriction.base.namespaceURI))
							) : (
								topLevelElement.simpleType != null && topLevelElement.simpleType.union != null && topLevelElement.type == null ? (
									let temp = toAnonymousRootElementPrimitiveType(data, topLevelElement, topLevelElement.simpleType, tmpSchema, model, tmpPackage, false) :									
									temp
								) : (
									topLevelElement.complexType == null && topLevelElement.type != null && isComplexType(data, tmpSchema, topLevelElement.type.namespaceURI, getElementLocalPart(data, topLevelElement)) == true ? (
										traceMe("toRootElementClass") ->
										toRootElementClass(data, topLevelElement, tmpSchema, refNamespace, getElementLocalPart(data, topLevelElement),  model, tmpPackage)
									) : null
								)
							)	
						)
					)
				)						
			)
		) :
		traceMeDebug("=> createReferencedClass 1 refElement=" + refLocalPart + "Returning="+classFromElement) ->
		classFromElement
	);	
					
cached uml::Class createReferencedClass(ImportTransformationData data, SchemaType schemaType,uml::Model model, String prefix, String refNamespace, String localPart, uml::Package package) :
	traceMeDebug("**createReferencedClass()2: "+ localPart) ->
	(	
		let packageForPrefix = (			
			let packageName = data.getResolvedPackageNamespace(refNamespace) :
			let existingModel = data.otherResultModels.selectFirst(e|e.name==packageName) :
			existingModel != null ? existingModel : (
				let existingPackage = findPackage(data, model, packageName) :		
				existingPackage != null ? existingPackage : package
			)
		) :	
		(			
			packageForPrefix == package ? (			 
				let classFromElement = schemaType.eAllContents.typeSelect(xmlSchema::TopLevelElement).select(e|e.name == localPart).collect(e|toClass(data, e, schemaType, model, package)) :
				let classFromComplex = schemaType.eAllContents.typeSelect(xmlSchema::ComplexType).select(e|e.name == localPart).collect(e|toClass(data, e, schemaType, model, null, package)) :
				let classFromSimple = schemaType.eAllContents.typeSelect(xmlSchema::SimpleType).select(e|e.name == localPart && (e.restriction == null || (e.restriction != null && (e.restriction.enumeration == null || e.restriction.enumeration.size == 0)))).collect(e|toPrimitiveType(data, e, schemaType, model, package)) :
				let classFromSimpleWithEnum = schemaType.eAllContents.typeSelect(xmlSchema::SimpleType).select(e|e.name == localPart && e.restriction.enumeration != null && e.restriction.enumeration.size > 0).collect(e|toEnumeration(data, e, schemaType, model, package, e.restriction.enumeration.id, e.restriction.enumeration.value)) :				
				let classFromSimpleElement = schemaType.element.select(e|e.name == localPart && e.simpleType != null && (e.simpleType.restriction == null || (e.simpleType.restriction != null && (e.simpleType.restriction.enumeration == null || e.simpleType.restriction.enumeration.size == 0)))).collect(e|toPrimitiveType(data, e, e.simpleType, schemaType, model, package)).select(e|e!=null) :
				let classFromSimpleElementWithEnum = schemaType.element.select(e|e.name == localPart && e.simpleType != null && e.simpleType.restriction.enumeration != null && e.simpleType.restriction.enumeration.size > 0).collect(e|toEnumeration(data, e, e.simpleType, schemaType, model, package, e.simpleType.restriction.enumeration.id, e.simpleType.restriction.enumeration.value)).select(e|e!=null) :				
				let classFromComplexElement = schemaType.element.select(e|e.name == localPart && e.complexType != null).collect(e|toClass(data, e, e.complexType, schemaType, model, package)).select(e|e!=null) :							
				classFromElement.first() != null ? classFromElement.first() : (classFromComplex.first() != null ? classFromComplex.first() : (classFromSimple.first() != null ? classFromSimple.first() : (classFromSimpleElement.first() != null ? classFromSimpleElement.first() : (classFromComplexElement.first() != null ? classFromComplexElement.first() : (classFromSimpleWithEnum.first() != null ? classFromSimpleWithEnum.first() : classFromSimpleElementWithEnum.first())))))
			) : 
			(			
				let classFromComplexOrGroup = packageForPrefix.eAllContents.typeSelect(uml::Class).select(e|getOriginalXSDName(e) == localPart) :			
				let classFromSimple = packageForPrefix.eAllContents.typeSelect(uml::PrimitiveType).select(e|getOriginalXSDName(e) == localPart && Property.isInstance(e) == false) :		
				let classFromSimpleWithEnum = packageForPrefix.eAllContents.typeSelect(uml::Enumeration).select(e|getOriginalXSDName(e) == localPart && Property.isInstance(e) == false) :				
				(classFromComplexOrGroup.first() == null && classFromSimple.first() == null && classFromSimpleWithEnum.first() == null) ? 
					(
						let tempSchemaType = getSchemaTypeForNamespaceURI(data, schemaType,refNamespace) :
						let classFromElement = tempSchemaType.eAllContents.typeSelect(xmlSchema::Element).select(e|e.name == localPart).collect(e|toClass(data, e, tempSchemaType, model, packageForPrefix)) :
						let classFromComplex = tempSchemaType.eAllContents.typeSelect(xmlSchema::ComplexType).select(e|e.name == localPart).collect(e|toClass(data, e, tempSchemaType, model, null, packageForPrefix)) :										
						let classFromSimple = tempSchemaType.eAllContents.typeSelect(xmlSchema::SimpleType).select(e|e.name == localPart && (e.restriction == null || (e.restriction != null && (e.restriction.enumeration == null || e.restriction.enumeration.size == 0)))).collect(e|toPrimitiveType(data, e, tempSchemaType, model, packageForPrefix)) :
						let classFromSimpleWithEnum = tempSchemaType.eAllContents.typeSelect(xmlSchema::SimpleType).select(e|e.name == localPart && e.restriction.enumeration != null && e.restriction.enumeration.size > 0).collect(e|toEnumeration(data, e, schemaType, model, packageForPrefix, e.restriction.enumeration.id, e.restriction.enumeration.value)) :
						let classFromSimpleElement = tempSchemaType.element.select(e|e.name == localPart && e.simpleType != null && (e.simpleType.restriction == null || (e.simpleType.restriction != null && (e.simpleType.restriction.enumeration == null || e.simpleType.restriction.enumeration.size == 0)))).collect(e|toPrimitiveType(data, e, e.simpleType, schemaType, model, packageForPrefix)).select(e|e!=null) :
						let classFromSimpleElementWithEnum = tempSchemaType.element.select(e|e.name == localPart && e.simpleType != null && e.simpleType.restriction.enumeration != null && e.simpleType.restriction.enumeration.size > 0).collect(e|toEnumeration(data, e, e.simpleType, schemaType, model, packageForPrefix, e.simpleType.restriction.enumeration.id, e.simpleType.restriction.enumeration.value)).select(e|e!=null) :
						let classFromComplexElement = tempSchemaType.element.select(e|e.name == localPart && e.complexType != null).collect(e|toClass(data, e, e.complexType, schemaType, model, packageForPrefix)).select(e|e!=null) :												
						classFromElement.first() != null ? classFromElement.first() : (classFromComplex.first() != null ? classFromComplex.first() : (classFromSimple.first() != null ? classFromSimple.first() : (classFromSimpleElement.first() != null ? classFromSimpleElement.first() : (classFromComplexElement.first() != null ? classFromComplexElement.first() : (classFromSimpleWithEnum.first() != null ? classFromSimpleWithEnum.first() : classFromSimpleElementWithEnum.first())))))
					) 
				: 			
					(classFromComplexOrGroup.first() != null ? classFromComplexOrGroup.first() : (classFromSimple.first() != null ? classFromSimple.first() : classFromSimpleWithEnum.first()))			
			)
		)
	);
	
cached uml::Class createReferencedClass(ImportTransformationData data, SchemaType schemaType,uml::Model model, String localPart, uml::Package package) :
	traceMeDebug("** createReferencedClass 3") ->
	(
		let classFromElement = schemaType.eAllContents.typeSelect(xmlSchema::TopLevelElement).select(e|e.name == localPart).collect(e|toClass(data, e, schemaType, model, package)) :
		let classFromComplex = schemaType.eAllContents.typeSelect(xmlSchema::ComplexType).select(e|getComplexName(data, e) == localPart).collect(e|toClass(data, e, schemaType, model, null, package)) :
		let classFromSimple = schemaType.eAllContents.typeSelect(xmlSchema::SimpleType).select(e|e.name == localPart).collect(e|toPrimitiveType(data, e, schemaType, model, package)) :				
		classFromElement.first() != null ? classFromElement.first() : (classFromComplex.first() != null ? classFromComplex.first() : classFromSimple.first())
	);
