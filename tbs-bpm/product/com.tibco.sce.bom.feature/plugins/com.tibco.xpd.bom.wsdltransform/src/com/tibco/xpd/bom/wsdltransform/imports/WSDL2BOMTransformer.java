/*
 * Copyright (c) TIBCO Software Inc 2004, 2008. All rights reserved.
 */
package com.tibco.xpd.bom.wsdltransform.imports;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Path;
import org.eclipse.core.runtime.Status;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.workspace.util.WorkspaceSynchronizer;
import org.eclipse.wst.wsdl.Binding;
import org.eclipse.wst.wsdl.BindingOperation;
import org.eclipse.wst.wsdl.BindingOutput;
import org.eclipse.wst.wsdl.Definition;
import org.eclipse.wst.wsdl.Message;
import org.eclipse.wst.wsdl.Operation;
import org.eclipse.wst.wsdl.Output;
import org.eclipse.wst.wsdl.PortType;
import org.eclipse.wst.wsdl.util.WSDLResourceImpl;
import org.eclipse.xsd.XSDImport;
import org.eclipse.xsd.XSDSchema;
import org.eclipse.xsd.XSDSchemaContent;
import org.eclipse.xsd.XSDSchemaDirective;
import org.openarchitectureware.xtend.XtendFacade;

import com.tibco.xpd.bom.wsdltransform.Activator;
import com.tibco.xpd.bom.wsdltransform.api.WSDLTransformUtil;
import com.tibco.xpd.bom.wsdltransform.internal.Messages;
import com.tibco.xpd.bom.xsdtransform.api.XSDSchemaResolver;
import com.tibco.xpd.bom.xsdtransform.imports.template.ImportTransformationData;
import com.tibco.xpd.bom.xsdtransform.internal.AbstractXtendImportTransformer;
import com.tibco.xpd.bom.xsdtransform.utils.NamespaceURIToJavaPackageMapper;
import com.tibco.xpd.resources.util.DependencySorter;
import com.tibco.xpd.resources.util.DependencySorter.Arc;
import com.tibco.xpd.resources.util.WorkingCopyUtil;

/**
 * Transforms WSDL Model to BOM.
 * <p>
 * <i>Created: 24 July 2008</i>
 * </p>
 * 
 * @author Gary Lewis
 */
public class WSDL2BOMTransformer extends AbstractXtendImportTransformer {

    private static final String EXTENSION = "transformWsdlToBom"; //$NON-NLS-1$

    private static final String EXTENSION_FILE =
            "com::tibco::xpd::bom::wsdltransform::imports::template::Wsdl2Bom"; //$NON-NLS-1$

    private static XtendFacade xtendFacade;

    static {
        xtendFacade = XtendFacade.create(EXTENSION_FILE);
        configureFacade(xtendFacade);
    }

    public WSDL2BOMTransformer() {
    }

    public WSDL2BOMTransformer(boolean doMerge) {
        this.doMerge = doMerge;
    }

    public WSDL2BOMTransformer(boolean doMerge, boolean doOverwrite) {
        this.doMerge = doMerge;
        this.doOverwrite = doOverwrite;
    }

    /*
     * (non-Javadoc)
     * 
     * @see
     * com.tibco.xpd.bom.xsdtransform.XtendImportTransformer#getXtendFacade()
     */
    @Override
    protected XtendFacade getXtendFacade() {
        return xtendFacade;
    }

    @Override
    protected String getExtension() {
        return EXTENSION;
    }

    @Override
    protected List<IStatus> validateSource(ImportTransformationData data,
            Resource resource) {

        List<IStatus> result = null;

        if (resource instanceof WSDLResourceImpl) {
            WSDLResourceImpl wsdlResourceImpl = (WSDLResourceImpl) resource;

            if (wsdlResourceImpl != null
                    && wsdlResourceImpl.getDefinition() != null) {

                List<IStatus> statusArr = new ArrayList<IStatus>();
                /*
                 * Perform WSDL validation checks only for those WSDLs aren't
                 * generated by Studio.
                 */
                statusArr
                        .addAll(performValidationChecks((WSDLResourceImpl) resource));

                /*
                 * XPD-3732: check if there is any cyclic dependency between the
                 * schemas referenced from the wsdl
                 */
                List<IStatus> status = new ArrayList<IStatus>();
                status = checkForCyclicDependency((WSDLResourceImpl) resource);
                statusArr.addAll(status);

                /* Delegate call to validate any embedded or referenced XSDs */
                Map<String, IProject> namespacesSet =
                        new HashMap<String, IProject>();
                IProject project =
                        WorkingCopyUtil.getProjectFor(wsdlResourceImpl
                                .getDefinition(), true);
                namespacesSet.put(wsdlResourceImpl.getDefinition()
                        .getTargetNamespace(), project);
                Set<XSDSchema> schemasForWSDL =
                        getXSDSchemasForWSDL(resource, statusArr);

                for (XSDSchema schema : schemasForWSDL) {

                    HashMap<String, Boolean> parsedSchemas =
                            new HashMap<String, Boolean>();

                    /*
                     * XPD-4811: need to resolve the imported schemas and then
                     * the resolved schemas contents must be parsed
                     */
                    validateImportedSchemas(data,
                            statusArr,
                            namespacesSet,
                            schema,
                            parsedSchemas);

                    parsedSchemas.put(schema.getSchemaLocation(), Boolean.TRUE);
                    statusArr.addAll(validateSchemaContents(data,
                            schema,
                            parsedSchemas,
                            true,
                            namespacesSet));
                }
                ArrayList<String> resolvedNamespaces = new ArrayList<String>();
                for (String tmpTargetNamespace : namespacesSet.keySet()) {
                    if (tmpTargetNamespace != null
                            && tmpTargetNamespace.trim().length() > 0) {
                        IProject project2 = namespacesSet
                                        .get(tmpTargetNamespace);
                        String resolvedNamespace =
                                NamespaceURIToJavaPackageMapper
                                        .getJavaPackageNameFromNamespaceURI(project2,
                                                tmpTargetNamespace);
                        if (resolvedNamespaces.contains(resolvedNamespace)) {
                            statusArr
                                    .add(new Status(
                                            IStatus.ERROR,
                                            Activator.PLUGIN_ID,
                                            String.format(Messages.WSDL2BOMTransformer_duplicate_resolved_namespace_shortdesc,
                                                    tmpTargetNamespace,
                                                    (resolvedNamespace + ".bom")))); //$NON-NLS-1$
                        } else {
                            resolvedNamespaces.add(resolvedNamespace);
                        }
                    }
                }

                result = statusArr;
            }
        } else {
            result = new ArrayList<IStatus>(1);
            result.add(new Status(
                    IStatus.ERROR,
                    Activator.PLUGIN_ID,
                    String.format(Messages.WSDL2BOMTransformer_expectedWSDLResource_error_message,
                            resource.getURI().toString())));
        }
        return result != null ? result : new ArrayList<IStatus>(0);
    }

    /**
     * resolve the imported schemas and parse the contents to validate them
     * 
     * @param data
     * @param statusArr
     * @param namespacesSet
     * @param schema
     * @param parsedSchemas
     */
    private void validateImportedSchemas(ImportTransformationData data,
            List<IStatus> statusArr, Map<String, IProject> namespacesSet,
            XSDSchema schema, HashMap<String, Boolean> parsedSchemas) {

        EList<XSDSchemaContent> contents = schema.getContents();

        for (XSDSchemaContent xsdSchemaContent : contents) {

            XSDSchema resolvedSchema = null;

            if (xsdSchemaContent instanceof XSDImport) {

                XSDSchemaDirective directive =
                        (XSDSchemaDirective) xsdSchemaContent;

                XSDSchemaResolver schemaResolver =
                        XSDSchemaResolver.getInstance();
                resolvedSchema =
                        schemaResolver.getResolvedSchemaForDirective(directive);
            }
            if (null != resolvedSchema) {

                parsedSchemas.put(resolvedSchema.getSchemaLocation(),
                        Boolean.TRUE);
                statusArr.addAll(validateSchemaContents(data,
                        resolvedSchema,
                        parsedSchemas,
                        true,
                        namespacesSet));
            }
        }
    }

    /**
     * checks if there is any cyclic dependency between referenced schemas
     * 
     * @param wsdlResourceImpl
     * @return list of status object(s) with cyclic dependency error if there is
     *         any cyclic dependency found, empty list otherwise
     */
    private List<IStatus> checkForCyclicDependency(
            WSDLResourceImpl wsdlResourceImpl) {

        List<IStatus> status = new ArrayList<IStatus>();

        /*
         * 1. Iterate thru the referenced schemas and create dependency arcs to
         * create the relationship between the parent schema namespace and the
         * referenced schema namespace
         */
        List<DependencySorter.Arc<String>> arcs = new ArrayList<Arc<String>>();

        /*
         * XPD-4587: slightly changed the way we get schema dependency arcs to
         * avoid getting NPE
         */
        getSchemaDependencyArcs(wsdlResourceImpl.getDefinition(),
                wsdlResourceImpl.getDefinition().getTargetNamespace(),
                new HashSet<EObject>(),
                arcs);
        /*
         * 2. call getOrderedList on DependencySorter. if throws any exception
         * then that means it has got cyclic dependency
         */
        DependencySorter<String> dependencySorter =
                new DependencySorter<String>(arcs, null);
        try {

            dependencySorter.getOrderedList();
        } catch (IllegalArgumentException e) {

            status.add(new Status(
                    IStatus.ERROR,
                    Activator.PLUGIN_ID,
                    String.format(Messages.WSDL2BOMTransformer_cyclicDependency_error_message_1,
                            e.getCause().getMessage(),
                            WorkingCopyUtil
                                    .getFile(wsdlResourceImpl.getDefinition())
                                    .getFullPath().toString())));
            return status;
        }
        return status;
    }

    /**
     * Iterate thru the referenced schemas and create dependency arcs to create
     * the relationship between the parent schema namespace and the referenced
     * schema namespace
     * 
     * @param wsdlDefOrSchema
     * @param wsdlOrXsdNamespace
     * @param alreadyReferencedDefOrSchema
     * @param arcs
     */
    private void getSchemaDependencyArcs(EObject wsdlDefOrSchema,
            String wsdlOrXsdNamespace,
            Set<EObject> alreadyReferencedDefOrSchema,
            List<DependencySorter.Arc<String>> arcs) {

        Set<XSDSchema> referencedDefOrSchemas =
                WSDLTransformUtil.getReferencedSchemas(wsdlDefOrSchema);
        alreadyReferencedDefOrSchema.add(wsdlDefOrSchema);

        for (EObject eObject : referencedDefOrSchemas) {
            /*
             * resolve schema import to a URI i.e. Get resource URI to recurse
             * into.
             */
            String importedSchemaLocation = null;
            String importedNamespace = null;
            /* Create an arc between the referencing wsdl/xsd and the import. */
            if (eObject instanceof XSDSchema) {

                XSDSchema schema = (XSDSchema) eObject;
                importedNamespace = schema.getTargetNamespace();
                importedSchemaLocation = schema.getSchemaLocation();
                /*
                 * Ignore if imported namespace is same as this namespace
                 * (that's the equiv of include I think)
                 */
                if (null != importedNamespace
                        && !wsdlOrXsdNamespace.equals(importedNamespace)) {
                    arcs.add(new DependencySorter.Arc<String>(
                            wsdlOrXsdNamespace, importedNamespace));
                }

            }

            if (null != importedSchemaLocation && null != importedNamespace) {

                if (!alreadyReferencedDefOrSchema.contains(eObject)) {
                    getSchemaDependencyArcs(eObject,
                            importedNamespace,
                            alreadyReferencedDefOrSchema,
                            arcs);
                }
            }
        }

    }

    /**
     * Run validation on the given WSDL. This will run the WST validation on the
     * WSDL and also check for restrictions that need to be applied.
     * 
     * @param source
     *            the WSDL file
     * @param resource
     *            the WSDL resource loaded from the WSDL file.
     * @return
     */
    private List<IStatus> performValidationChecks(WSDLResourceImpl resource) {

        List<IStatus> statusArr = null;

        IProject project = getProject();
        URI uri = resource.getURI();

        /*
         * THis should prevent incorrect assertion that uri.isPlatformResource()
         * says that file is in workspace, it doesn't. It just says whatever the
         * original URI given to load the resource, SO if that was a FILE URI
         * (like it always is from transform build) then it will not come out
         * here as a platform URI.
         * 
         * Uses WorkspaceSynchroniser.getFile() instead for defiiteve answer.
         */
        IFile workspaceFile = WorkspaceSynchronizer.getFile(resource);

        if (workspaceFile == null && project != null) {
            IFile file = null;
            try {
                /*
                 * Create a temporary linked file so that the WST validator can
                 * validate the file
                 */
                String filePath = uri.toFileString();
                if (filePath != null) {
                    file = createTempLinkedFile(project, new Path(filePath));
                    statusArr = WSDLTransformUtil.validateWSDL(file);
                }
            } catch (CoreException e) {
                /* Do nothing */
            } finally {
                /* Remove temporary file */
                if (file != null) {
                    try {
                        file.delete(true, null);
                    } catch (CoreException e) {
                        /* Do nothing */
                    }
                }
            }
        }

        /*
         * If we failed to create temp file, or the resource is a workspace
         * resource, then try to validate resource
         */
        if (statusArr == null) {
            statusArr = WSDLTransformUtil.validateWSDL(resource);
        }

        if (resource instanceof WSDLResourceImpl) {
            WSDLResourceImpl wsdlResource = resource;
            Definition definition = wsdlResource.getDefinition();
            String targetNamespace = definition.getTargetNamespace();
            if (targetNamespace == null || targetNamespace.trim().length() == 0) {
                statusArr
                        .add(new Status(
                                IStatus.ERROR,
                                Activator.PLUGIN_ID,
                                Messages.TransformHelper_wsdl_does_not_support_schemas_without_targetnamespaces_message));
            }
            if (definition.getServices().size() > 0) {
                // Activator
                // .getDefault()
                // .getLogger()
                // .info(Messages.TransformHelper_wsdl_services_will_be_ignored_message);
                statusArr
                        .add(new Status(
                                IStatus.WARNING,
                                Activator.PLUGIN_ID,
                                Messages.TransformHelper_wsdl_services_will_be_ignored_message));
            }

            EList<?> bindings = definition.getEBindings();

            if (!bindings.isEmpty()) {
                for (Object binding : bindings) {
                    if (binding instanceof Binding) {
                        EList<?> bindingOperations =
                                ((Binding) binding).getEBindingOperations();
                        for (Object operation : bindingOperations) {
                            if (operation instanceof BindingOperation) {
                                if (((BindingOperation) operation)
                                        .getBindingFaults().size() > 0) {
                                    statusArr
                                            .add(new Status(
                                                    IStatus.WARNING,
                                                    Activator.PLUGIN_ID,
                                                    Messages.TransformHelper_wsdl_binding_faults_will_be_ignored_message));
                                } else {
                                    /**
                                     * SID XPD-4675 - Disable checking for
                                     * multiple output parts on WSDL, this was
                                     * only in place because you can't generate
                                     * BOM-class-operations with multiple return
                                     * types, but those operations aren't used
                                     * by anything anyway - we're only
                                     * interested in data types, so don't tell
                                     * user they can't transform when they
                                     * could.
                                     * 
                                     * Especially now that we validate against
                                     * multi output parts on reply activities.
                                     */
                                    /*
                                     * TODO In a couple of GA's from now this
                                     * can be removed altogether, leaving for
                                     * now in case we need to re-instate
                                     */
                                    boolean checkOutputMappings = false;

                                    if (checkOutputMappings) {
                                        BindingOutput bindingOutput =
                                                ((BindingOperation) operation)
                                                        .getEBindingOutput();
                                        if (bindingOutput != null) {
                                            Output output =
                                                    bindingOutput.getEOutput();
                                            if (output != null) {
                                                Message message =
                                                        output.getEMessage();
                                                if (message.getEParts().size() > 1) {
                                                    statusArr
                                                            .add(new Status(
                                                                    IStatus.ERROR,
                                                                    Activator.PLUGIN_ID,
                                                                    Messages.TransformHelper_wsdl_contains_multiple_output_parts_message));
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                /*
                 * If the binding operations are empty the WSDL is considered
                 * abstract, and needs to validate if the porttype has any
                 * operation that has more than one fault or has more than one
                 * output.
                 */
                List portTypes = definition.getEPortTypes();
                for (Object object : portTypes) {
                    if (object instanceof PortType) {
                        PortType portType = (PortType) object;
                        List operations = portType.getEOperations();
                        for (Object opObject : operations) {
                            if (opObject instanceof Operation) {
                                Operation op = (Operation) opObject;
                                if (op.getEFaults().size() > 0) {
                                    statusArr
                                            .add(new Status(
                                                    IStatus.WARNING,
                                                    Activator.PLUGIN_ID,
                                                    Messages.TransformHelper_wsdl_binding_faults_will_be_ignored_message));
                                } else {
                                    /**
                                     * SID XPD-4675 - Disable checking for
                                     * multiple output parts on WSDL, this was
                                     * only in place because you can't generate
                                     * BOM-class-operations with multiple return
                                     * types, but those operations aren't used
                                     * by anything anyway - we're only
                                     * interested in data types, so don't tell
                                     * user they can't transform when they
                                     * could.
                                     * 
                                     * Especially now that we validate against
                                     * multi output parts on reply activities.
                                     */
                                    /*
                                     * TODO In a couple of GA's from now this
                                     * can be removed altogether, leaving for
                                     * now in case we need to re-instate
                                     */
                                    boolean checkOutputMappings = false;

                                    if (checkOutputMappings) {
                                        Output opOutput = op.getEOutput();
                                        if (opOutput != null) {
                                            Message message =
                                                    opOutput.getEMessage();
                                            if (message.getEParts().size() > 1) {
                                                statusArr
                                                        .add(new Status(
                                                                IStatus.ERROR,
                                                                Activator.PLUGIN_ID,
                                                                Messages.TransformHelper_wsdl_contains_multiple_output_parts_message));
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            /*
             * Check the <wsdl:import> construct. Currently we don't support the
             * use of this construct to import .xsd. This should be done in the
             * <wsdl:types> construct. Therefore for now, only let through .wsdl
             * files.
             */
            // EList<?> eImports = definition.getEImports();
            // for (Object obj : eImports) {
            // if (obj instanceof Import) {
            // Import imp = (Import) obj;
            //                    if (!imp.getLocationURI().endsWith(".wsdl")) { //$NON-NLS-1$
            // statusArr
            // .add(new Status(
            // IStatus.ERROR,
            // Activator.PLUGIN_ID,
            // Messages.TransformHelper_wsdl_contains_wsdl_import_message));
            // }
            // }
            //
            // }

        }
        return statusArr;
    }

    /**
     * Get all XSDs used by the given WSDL.
     * 
     * @param resource
     * @param statusArr
     * @return
     */
    private Set<XSDSchema> getXSDSchemasForWSDL(Resource resource,
            List<IStatus> statusArr) {

        Set<XSDSchema> xsdSchemas = new HashSet<XSDSchema>();
        WSDLResourceImpl wsdlResource = (WSDLResourceImpl) resource;

        Definition definition = wsdlResource.getDefinition();

        Set<XSDSchema> referencedDefOrSchemas =
                WSDLTransformUtil.getReferencedSchemas(definition);

        for (EObject eObject : referencedDefOrSchemas) {

            if (eObject instanceof XSDSchema) {
                xsdSchemas.add((XSDSchema) eObject);
            }
        }

        return xsdSchemas;
    }

    /**
     * Validate the given WSDL file. This will validate the WSDLs itself and all
     * schemas it uses.
     * 
     * @param wsdlFile
     * @return
     */
    public static List<IStatus> validate(Resource resource) {
        WSDL2BOMTransformer transformer = new WSDL2BOMTransformer();
        ImportTransformationData data = new ImportTransformationData();
        try {
            return transformer.validateSource(data, resource);
        } finally {
            transformer.cleanEditingDomain(data.getEditingDomain());
        }
    }

}
