import xmlSchema;
import type;
import uml;
import com::tibco::xpd::bom::xsdtransform::exports::template;

extension org::openarchitectureware::xsd::lib::qname;
extension org::openarchitectureware::xsd::lib::map;
extension com::tibco::xpd::bom::xsdtransform::exports::template::Extensions reexport;
extension com::tibco::xpd::bom::xsdtransform::exports::template::GeneralisationFuncs reexport;
extension com::tibco::xpd::bom::xsdtransform::exports::template::CompositionFuncs reexport;
extension com::tibco::xpd::bom::xsdtransform::exports::template::RestrictionFuncs reexport;
extension com::tibco::xpd::bom::xsdtransform::exports::template::HelperFuncs reexport;
extension com::tibco::xpd::bom::xsdtransform::exports::template::Bom2Xsd reexport;
	
List[Object] incrementalPreserveTransform(ExportTransformationData data, Class umlClass, String bomFullPathUri) :
	let model = umlClass.getModel() :
	let docRootList = {} :
	let superclasses = {} :
	let primitives = {} :
	let enums = {} :
	let generalizations = {} :
	let associations = {} :		
	let topLevelElementOrAttributeNames = {} :
	let packages = {model}.addAll(getModelAndReferences(model, false)) :	
	let packages = packages.union(model.eAllContents.typeSelect(Package)) :
	
	parseSuperClass(data, umlClass, superclasses, primitives, enums, docRootList, bomFullPathUri) ->	
	
	docRootList.collect(e|createTypes(data, e.schema, superclasses, primitives, enums)) ->
	
	superclasses.select(e|e.generalization != null).collect(e|generalizations.addAll(e.generalization)) ->
	primitives.select(e|e.generalization != null).collect(e|generalizations.addAll(e.generalization)) ->
	enums.select(e|e.generalization != null).collect(e|generalizations.addAll(e.generalization)) ->
	
	superclasses.select(e|e.getAssociations() != null).collect(e|associations.addAll(e.getAssociations())) ->
	primitives.select(e|e.getAssociations() != null).collect(e|associations.addAll(e.getAssociations())) ->
	enums.select(e|e.getAssociations() != null).collect(e|associations.addAll(e.getAssociations())) ->
	
	generalizations.select(e|e.general != null && e.general.name != null && isDefaultPrimitiveType(e.general.name, _getNearestPackageName(e.general))).collect(e|parseGeneralisationDefaultPrimitives(data, docRootList.eAllContents.typeSelect(SchemaType), e)) ->
	generalizations.select(e|e.general != null && e.general.name != null && !isDefaultPrimitiveType(e.general.name, _getNearestPackageName(e.general))).collect(e|parseGeneralisation(data, docRootList.eAllContents.typeSelect(SchemaType), e)) ->
	
	parseAssociations(data, docRootList.eAllContents.typeSelect(SchemaType), associations, packages) ->
	
	superclasses.collect(e | parseClassProperties(data, docRootList.eAllContents.typeSelect(SchemaType), e, packages)) ->
	primitives.eAllContents.typeSelect(Property).select(e|e.association == null && isSimpleContentExtension(e) == false && isSimpleContentRestriction(e) == false && Class.isInstance(e.eContainer) == true).collect(e|parseProperty(data, docRootList.eAllContents.typeSelect(SchemaType), e, packages)) ->
	enums.eAllContents.typeSelect(Property).select(e|e.association == null && isSimpleContentExtension(e) == false && isSimpleContentRestriction(e) == false && Class.isInstance(e.eContainer) == true).collect(e|parseProperty(data, docRootList.eAllContents.typeSelect(SchemaType), e, packages)) ->
	
	(
			let filteredPackages = {} :
			
			filteredPackages.addAll(packages) ->
			filteredPackages.removeAll(data.ignoredPackages) ->
			
			filteredPackages.collect(e|addMissedImports(data, docRootList.eAllContents.typeSelect(SchemaType), e)) -> 
			filteredPackages.collect(e | isXSDNotationProfileApplied(e)) ->
			
			filteredPackages.packagedElement.typeSelect(Class).select(e | isAnonTypeClass(e) == true).collect(e | changeTopToLocalComplex(docRootList.eAllContents.typeSelect(SchemaType), e, topLevelElementOrAttributeNames)) ->	
			docRootList.removeAll(data.parsedOAWSchemas).eAllContents.typeSelect(xmlSchema::Element).select(e|e.simpleType != null && e.simpleType.restriction != null && e.simpleType.restriction.base.localPart.toLowerCase() == "xsd:anytype").collect(e | fixAnyTypes(e)) ->	
			docRootList.removeAll(data.parsedOAWSchemas).eAllContents.typeSelect(SchemaType).eAllContents.typeSelect(ExtensionType).collect(e|fixExtensionPrefixes(e, e.eRootContainer.schema, data, docRootList.eAllContents.typeSelect(SchemaType))) ->		
			docRootList.removeAll(data.parsedOAWSchemas).eAllContents.typeSelect(SchemaType).eAllContents.typeSelect(xmlSchema::Element).select(e | e.type != null).collect(e|fixElementTypePrefixes(data,e, e.eRootContainer.schema,docRootList.eAllContents.typeSelect(SchemaType))) ->
			
			fixOriginalNames(data, docRootList.removeAll(data.parsedOAWSchemas).eAllContents.typeSelect(SchemaType)) ->
			
			docRootList.removeAll(data.parsedOAWSchemas).eAllContents.typeSelect(xmlSchema::Element).select(e|e.type != null && e.complexType != null).sortBy(e | getContainerCount(e.eContainer, 1)).collect(e|fixAnonTypes(data, docRootList.eAllContents.typeSelect(SchemaType), e)) ->
			// XPD-4169: getting rid of the clean up method call that adds empty complexTypes in generated XSD
			//docRootList.removeAll(data.parsedOAWSchemas).eAllContents.typeSelect(xmlSchema::Element).select(e|e.type != null && e.complexType != null).sortBy(e | getContainerCount(e.eContainer, 1)).collect(e|cleanTopLevelElements(data, docRootList.eAllContents.typeSelect(SchemaType), e, topLevelElementOrAttributeNames)) ->	
			docRootList.removeAll(data.parsedOAWSchemas).eAllContents.typeSelect(xmlSchema::Element).select(e|e.type != null).sortBy(e | getContainerCount(e.eContainer, 1)).collect(e|fixBrokenReferences(docRootList.eAllContents.typeSelect(SchemaType), e, topLevelElementOrAttributeNames)) ->
							
			// clears up any temporary complex types with no contents - be nice later on to find why they are left floating on rare occasions 
			docRootList.removeAll(data.parsedOAWSchemas).eAllContents.typeSelect(SchemaType).eAllContents.typeSelect(LocalComplexType).select(e | e.name == null && e.sequence == null && e.all == null && e.choice == null && e.complexContent == null && e.simpleContent == null && (e.attribute == null || e.attribute.size == 0 )).collect(e | e.eContainer.setComplexType(null)) ->
		    docRootList.removeAll(data.parsedOAWSchemas).eAllContents.typeSelect(SchemaType).eAllContents.typeSelect(ComplexType).select(e | e.complexContent.^extension != null && e.sequence != null).collect(e | e.complexContent.^extension.setSequence(e.sequence)) ->
		    
			(
				let newSchemas = docRootList.removeAll(data.parsedOAWSchemas) :
				newSchemas.collect(e | data.addParsedOAWSchema(e)) ->
				newSchemas
			)
		);
	
	
	//docRootList;
	
parseClassProperties(ExportTransformationData data, Collection[xmlSchema::SchemaType] schemaTypeList, Class tmpCls, Collection[Package] packageList) :
	tmpCls.ownedAttribute.select(e|e.association == null && isSimpleContentExtension(e) == false && isSimpleContentRestriction(e) == false).collect(e|parseProperty(data, schemaTypeList, e, packageList));
	
cached createTypes(ExportTransformationData data, SchemaType schemaType, List superclasses, List primitiveList, List enumList) :
	let filteredSuperclasses = {} :
	let filteredPrimitives = {} :
	let filteredEnums = {} :
	let targetNamespace = schemaType.targetNamespace :	
	schemaType.simpleType.addAll(primitiveList.typeSelect(PrimitiveType).select(e | getNamespace(e.package,true) == targetNamespace).collect(e | createSimpleType(data, e, schemaType)).select(e|e != null)) ->
	schemaType.simpleType.addAll(enumList.typeSelect(Enumeration).select(e | getNamespace(e.package,true) == targetNamespace).collect(e | createSimpleType(data, e, schemaType)).select(e|e != null)) ->
	schemaType.complexType.addAll(superclasses.typeSelect(Class).select(e | isComplexType(e) && getNamespace(e.package,true) == targetNamespace).collect(e | createComplexType(data, e, schemaType)).select(e|e != null)) ->
	schemaType.group2.addAll(superclasses.typeSelect(Class).select(e | isGroup(e) && getNamespace(e.package,true) == targetNamespace).collect(e | createGroup(e, schemaType)).select(e|e != null)) ->
	schemaType.attributeGroup.addAll(superclasses.typeSelect(Class).select(e | isAttributeGroup(e) && getNamespace(e.package,true) == targetNamespace).collect(e | createAttributeGroup(e, schemaType)).select(e|e != null));
	
cached addSchemaToList(ExportTransformationData data, Collection[xmlSchema::XmlSchemaDocumentRoot] docRootList, Package package, String bomFullPathUri) :
	let docRoot = createIncrementalPreserveDocumentRoot(data, package, bomFullPathUri) :
	let alreadyContained = docRootList.contains(docRoot) :
	alreadyContained ? null : docRootList.add(docRoot);	
	
// create a DocumentRoot object and declare depending namespaces.
// EMF defines the XMLSchema namespace automatically, but this way we avoid using a prefix for it. 
cached xmlSchema::XmlSchemaDocumentRoot createIncrementalPreserveDocumentRoot(ExportTransformationData data, Package pkg, String bomFullPathUri):
	let docRoot = new xmlSchema::XmlSchemaDocumentRoot :
	let tempSchemaType = createSchema(data, pkg) :			
	docRoot.setSchema(tempSchemaType) ->
	docRoot.xMLNSPrefixMap.put("",getNamespace(pkg,true)) ->
	docRoot.xMLNSPrefixMap.put(getPrefix(data, pkg),getNamespace(pkg,true)) ->
	docRoot.xMLNSPrefixMap.put("xsd","http://www.w3.org/2001/XMLSchema") ->
	
	docRoot.schema.setAnnotation({createAnnotationType("BOMORIGIN::"+bomFullPathUri)}) ->
	docRoot;
	
cached parseSuperClass(ExportTransformationData data, Class umlClass, List superclasses, List primitiveList, List enumList, Collection[xmlSchema::XmlSchemaDocumentRoot] docRootList, String bomFullPathUri) :
      superclasses.contains(umlClass) ? null : (
            superclasses.add(umlClass) ->
            addSchemaToList(data, docRootList, umlClass.package, bomFullPathUri) ->
            parseClassContents(data, umlClass, superclasses, primitiveList, enumList, docRootList, bomFullPathUri) ->            
            umlClass.superClass.collect(e|parseSuperClass(data, e,superclasses, primitiveList, enumList, docRootList, bomFullPathUri)) ->              
            umlClass.getAssociations().memberEnd.type.typeSelect(Class).collect(e | parseSuperClass(data, e,superclasses, primitiveList, enumList, docRootList, bomFullPathUri))         
      );

	
cached parseSuperEnumeration(ExportTransformationData data, Enumeration enumeration, List primitiveList, List enumList, Collection[xmlSchema::XmlSchemaDocumentRoot] docRootList, String bomFullPathUri) :	
	enumList.contains(enumeration) ? null : (		
		enumList.add(enumeration) ->		
		addSchemaToList(data, docRootList, enumeration.package, bomFullPathUri) ->
		PrimitiveType.isInstance(enumeration.generalization.first().general) ? (		
			parseSuperPrimitive(data, (PrimitiveType)enumeration.generalization.first().general,primitiveList, docRootList, bomFullPathUri)			
		) : (
			Enumeration.isInstance(enumeration.generalization.first().general) ? (
				parseSuperEnumeration(data, (Enumeration)enumeration.generalization.first().general,primitiveList, enumList, docRootList, bomFullPathUri)
			) : null
		)
	);
	
cached parseSuperPrimitive(ExportTransformationData data, PrimitiveType umlPrimitive, List primitiveList, Collection[xmlSchema::XmlSchemaDocumentRoot] docRootList, String bomFullPathUri) :	
	let isDefaultPrimitiveType = isDefaultPrimitiveType(umlPrimitive.name, _getNearestPackageName(umlPrimitive)) :
	primitiveList.contains(umlPrimitive) || isDefaultPrimitiveType ? null : (		
		primitiveList.add(umlPrimitive) ->
		addSchemaToList(data, docRootList, umlPrimitive.package, bomFullPathUri) ->
		PrimitiveType.isInstance(umlPrimitive.generalization.first().general) ? (		
			parseSuperPrimitive(data, (PrimitiveType)umlPrimitive.generalization.first().general,primitiveList, docRootList, bomFullPathUri)			
		) : null
	);

cached parseClassContents(ExportTransformationData data, Class umlClass, List superclasses, List primitiveList, List enumList, Collection[xmlSchema::XmlSchemaDocumentRoot] docRootList, String bomFullPathUri) :
      umlClass.ownedAttribute.collect(e|parseEachProperty(data, e, superclasses, primitiveList, enumList, docRootList, bomFullPathUri)) ->
      umlClass.ownedOperation.type.typeSelect(PrimitiveType).collect(e|parseSuperPrimitive(data, e,primitiveList, docRootList, bomFullPathUri)) ->
      umlClass.ownedOperation.type.typeSelect(Enumeration).collect(e|parseSuperEnumeration(data, e,primitiveList,enumList, docRootList, bomFullPathUri)) ->
      umlClass.ownedOperation.type.typeSelect(Class).collect(e|parseSuperClass(data, e,superclasses,primitiveList,enumList, docRootList, bomFullPathUri)) ->
      umlClass.ownedOperation.ownedParameter.type.typeSelect(PrimitiveType).collect(e|parseSuperPrimitive(data, e,primitiveList, docRootList, bomFullPathUri)) ->
      umlClass.ownedOperation.ownedParameter.type.typeSelect(Enumeration).collect(e|parseSuperEnumeration(data, e,primitiveList,enumList, docRootList, bomFullPathUri)) ->
      umlClass.ownedOperation.ownedParameter.type.typeSelect(Class).collect(e|parseSuperClass(data, e,superclasses,primitiveList,enumList, docRootList, bomFullPathUri));

cached parseEachProperty(ExportTransformationData data, Property property, List superclasses, List primitiveList, List enumList, Collection[xmlSchema::XmlSchemaDocumentRoot] docRootList, String bomFullPathUri) :
	PrimitiveType.isInstance(property.type) == true ? parseSuperPrimitive(data, property.type,primitiveList, docRootList, bomFullPathUri) : null ->
	Enumeration.isInstance(property.type) == true ? parseSuperEnumeration(data, property.type,primitiveList,enumList, docRootList, bomFullPathUri) : null ->
	Class.isInstance(property.type) == true ? parseSuperClass(data, property.type,superclasses,primitiveList,enumList, docRootList, bomFullPathUri) : null;