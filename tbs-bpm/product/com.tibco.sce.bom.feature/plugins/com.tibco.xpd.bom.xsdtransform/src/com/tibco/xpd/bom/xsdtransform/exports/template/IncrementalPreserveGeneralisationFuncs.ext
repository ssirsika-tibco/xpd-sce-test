import xmlSchema;
import type;
import uml;
import xsd;
import com::tibco::xpd::bom::xsdtransform::exports::template;

extension org::openarchitectureware::xsd::lib::qname;
extension org::openarchitectureware::xsd::lib::map;
extension com::tibco::xpd::bom::xsdtransform::exports::template::Extensions reexport;
extension com::tibco::xpd::bom::xsdtransform::exports::template::HelperFuncs reexport;
extension com::tibco::xpd::bom::xsdtransform::exports::template::RestrictionFuncs reexport;

parseGeneralisations(ExportTransformationData data, Collection[SchemaType] schemaTypeList, Collection[Package] packageList) :	
	packageList.eAllContents.typeSelect(Generalization).select(e|e.general != null && e.general.name != null && isDefaultPrimitiveType(e.general.name, _getNearestPackageName(e.general))).collect(e|parseGeneralisationDefaultPrimitives(data, schemaTypeList, e)) ->
	packageList.eAllContents.typeSelect(Generalization).select(e|e.general != null && e.general.name != null && !isDefaultPrimitiveType(e.general.name, _getNearestPackageName(e.general))).collect(e|parseGeneralisation(data, schemaTypeList, e));
	
parseGeneralisationDefaultPrimitives(ExportTransformationData data, Collection[SchemaType] schemaTypeList, Generalization generalization) :
	let baseElement = (PackageableElement)generalization.eContainer :
	let baseElementSchema = schemaTypeList.typeSelect(SchemaType).select(e|e.targetNamespace == getNamespace(baseElement.package,true)).first() :
	let baseSimpleType = baseElementSchema.simpleType.select(e|e.name == baseElement.name).first() :
	let appliedPrimitiveStereotype = baseElement.getAppliedStereotypes().select(e|e.name == "XsdBasedPrimitiveType").first() :
	appliedPrimitiveStereotype == null ? (
		baseSimpleType.restriction.setBase(getQName(data, baseElement, generalization.general, null)) ->
		setRestrictionAttrs(data, baseElement, baseSimpleType.restriction)
	) : (
		let restrictionBase = getStereotypeValue(baseElement, appliedPrimitiveStereotype, "xsdRestrictionBase") :
		restrictionBase != null && restrictionBase.trim().length > 0 ? (					
			let qname = createQName(restrictionBase) :
			baseSimpleType.restriction.setBase(qname)
		) : baseSimpleType.restriction.setBase(getQName(data, baseElement, generalization.general, null)) ->
		setRestrictionAttrs(data, baseElement, baseSimpleType.restriction)
	);	
	
parseGeneralisation(ExportTransformationData data, Collection[SchemaType] schemaTypeList, Generalization generalization) :	
	let baseElement = generalization.general.package.packagedElement.select(e|e.name == generalization.general.name).first() :
	let superElement = (PackageableElement)generalization.eContainer :	
	parseGeneralisation(data, schemaTypeList, baseElement, superElement);
	
parseGeneralisation(ExportTransformationData data, Collection[SchemaType] schemaTypeList, Class baseElement, Class superElement) :
	let superElementSchema = schemaTypeList.typeSelect(SchemaType).select(e|e.targetNamespace == getNamespace(superElement.package,true)).first() :	
	let baseElementSchema = schemaTypeList.typeSelect(SchemaType).select(e|e.targetNamespace == getNamespace(baseElement.package,true)).first() :	
	let superComplexType = (
		let tmpSuperComplexType = superElementSchema.complexType.select(e|e.name == superElement.name).first() :
		let tmpElemWithAnonComplextType = superElementSchema.element.select(e|e.name +"Type" == superElement.name).first() :
		tmpSuperComplexType == null ? tmpElemWithAnonComplextType.complexType : tmpSuperComplexType
	) :
	let baseComplexType = baseElementSchema.complexType.select(e|e.name == baseElement.name).first() :
	let baseGroup = baseElementSchema.group2.select(e|e.name == baseElement.name).first() :	
	let isBaseComplexType = isComplexType(baseElement) :
	let isBaseGroup = isGroup(baseElement) :
	let isBaseAttributeGroup = isAttributeGroup(baseElement) :
	let extensionType = new ExtensionType :
	let complexRestrictionType = new ComplexRestrictionType :
	let complexContent = new ComplexContentType :
	let extQName = getQName(baseElementSchema, baseElement.name, getPrefix(data, baseElement.package)) :
	let appliedRestrictionStereotype = superElement.getAppliedStereotypes().select(e|e.name == "XsdBasedClass").first() :
	let isAnonContainer = getStereotypeValue(superElement, appliedRestrictionStereotype, "xsdIsAnonContainer") :	
	superElementSchema != baseElementSchema ? addImportType(data, baseElementSchema, superElementSchema, baseElement.package, getPrefix(data, baseElement.package), baseElementSchema.targetNamespace) : null ->
	superComplexType.name == null && baseComplexType.name == null ? null : (	
		isAnonContainer == true ? (
			let element = (
				let tempElem = new TopLevelElement :
				let elem = superElementSchema.element.select(e|e.name == superElement.name).first() :			
				elem == null ? (superElementSchema.element.add(tempElem) -> tempElem) : (elem.setType(null) -> elem)
			) :
			let compCont = new LocalComplexType :
			element.setComplexType(compCont) ->
			element.setName(superElement.name) ->	
			data.addOriginalName(element, getOriginalName(superElement)) ->			
			superElementSchema.complexType.remove(superComplexType) ->
			baseElementSchema.complexType.remove(baseComplexType)
		) : (
			isBaseComplexType == true ? (				
				let isXSDRestriction = getStereotypeValue(superElement, appliedRestrictionStereotype, "xsdIsRestriction") :
				extensionType.setBase(extQName) ->		
				complexRestrictionType.setBase(extQName) ->				
				isXSDRestriction != null && isXSDRestriction == true ? complexContent.setRestriction(complexRestrictionType) : complexContent.setExtension(extensionType) ->		
				superComplexType.setComplexContent(complexContent)				
			) : (
				isBaseGroup == true ? (
					let groupRef = new GroupRef :
					groupRef.setRef(extQName) ->
					superComplexType.setGroup(groupRef)
				) : (
					isBaseAttributeGroup == true ? (
						let attributeGroupRef = new AttributeGroupRef :
						attributeGroupRef.setRef(extQName) ->
						superComplexType.setAttributeGroup({attributeGroupRef})
					) : null
				)
			)
		)
	);
	
parseGeneralisation(ExportTransformationData data, Collection[SchemaType] schemaTypeList, Enumeration baseElement, PrimitiveType superElement) :
	let superElementSchema = schemaTypeList.typeSelect(SchemaType).select(e|e.targetNamespace == getNamespace(superElement.package,true)).first() :	
	let baseElementSchema = schemaTypeList.typeSelect(SchemaType).select(e|e.targetNamespace == getNamespace(baseElement.package,true)).first() :
	let superSimpleType = superElementSchema.simpleType.select(e|e.name == superElement.name).first() :
	let baseSimpleType = baseElementSchema.simpleType.select(e|e.name == baseElement.name).first() :	
	let extQName = getQName(baseElementSchema, baseElement.name, getPrefix(data, baseElement.package)) :
	superElementSchema != baseElementSchema ? addImportType(data, baseElementSchema, superElementSchema, baseElement.package, getPrefix(data, baseElement.package), baseElementSchema.targetNamespace) : null ->
	superSimpleType.restriction.setBase(extQName) ->
	setRestrictionAttrs(data, baseElement, superSimpleType.restriction);	
	
parseGeneralisation(ExportTransformationData data, Collection[SchemaType] schemaTypeList, PrimitiveType baseElement, Enumeration superElement) :
	let superElementSchema = schemaTypeList.typeSelect(SchemaType).select(e|e.targetNamespace == getNamespace(superElement.package,true)).first() :	
	let baseElementSchema = schemaTypeList.typeSelect(SchemaType).select(e|e.targetNamespace == getNamespace(baseElement.package,true)).first() :
	let superSimpleType = superElementSchema.simpleType.select(e|e.name == superElement.name).first() :
	let baseSimpleType = baseElementSchema.simpleType.select(e|e.name == baseElement.name).first() :	
	let extQName = getQName(baseElementSchema, baseElement.name, getPrefix(data, baseElement.package)) :
	superElementSchema != baseElementSchema ? addImportType(data, baseElementSchema, superElementSchema, baseElement.package, getPrefix(data, baseElement.package), baseElementSchema.targetNamespace) : null ->
	superSimpleType.restriction.setBase(extQName) ->	
	setRestrictionAttrs(data, baseElement, superSimpleType.restriction) ->
	superSimpleType.restriction.enumeration.size == 0 ? toNoFixedFacet(data, superSimpleType.restriction.enumeration, "", null, superElement) : null;
	
parseGeneralisation(ExportTransformationData data, Collection[SchemaType] schemaTypeList, Enumeration baseElement, Enumeration superElement) :
	let superElementSchema = schemaTypeList.typeSelect(SchemaType).select(e|e.targetNamespace == getNamespace(superElement.package,true)).first() :	
	let baseElementSchema = schemaTypeList.typeSelect(SchemaType).select(e|e.targetNamespace == getNamespace(baseElement.package,true)).first() :
	let superSimpleType = superElementSchema.simpleType.select(e|e.name == superElement.name).first() :
	let baseSimpleType = baseElementSchema.simpleType.select(e|e.name == baseElement.name).first() :	
	let extQName = getQName(baseElementSchema, baseElement.name, getPrefix(data, baseElement.package)) :
	superElementSchema != baseElementSchema ? addImportType(data, baseElementSchema, superElementSchema, baseElement.package, getPrefix(data, baseElement.package), baseElementSchema.targetNamespace) : null ->
	superSimpleType.restriction.setBase(extQName) ->
	setRestrictionAttrs(data, baseElement, superSimpleType.restriction) ->	
	superSimpleType.restriction.enumeration.size == 0 ? toNoFixedFacet(data, superSimpleType.restriction.enumeration, "", null, superElement) : null;
	
parseGeneralisation(ExportTransformationData data, Collection[SchemaType] schemaTypeList, PrimitiveType baseElement, PrimitiveType superElement) :
	let superElementSchema = schemaTypeList.typeSelect(SchemaType).select(e|e.targetNamespace == getNamespace(superElement.package,true)).first() :	
	let baseElementSchema = schemaTypeList.typeSelect(SchemaType).select(e|e.targetNamespace == getNamespace(baseElement.package,true)).first() :
	let superSimpleType = superElementSchema.simpleType.select(e|e.name == superElement.name).first() :
	let baseSimpleType = baseElementSchema.simpleType.select(e|e.name == baseElement.name).first() :	
	let extQName = getQName(baseElementSchema, baseElement.name, getPrefix(data, baseElement.package)) :
	superElementSchema != baseElementSchema ? addImportType(data, baseElementSchema, superElementSchema, baseElement.package, getPrefix(data, baseElement.package), baseElementSchema.targetNamespace) : null ->	
	superSimpleType.restriction.setBase(extQName) ->
	setRestrictionAttrs(data, baseElement, superSimpleType.restriction);

setRestrictionAttrs(ExportTransformationData data, Object object, RestrictionType1 restrictionType) :
	let stereoType = getStereotypedProperty(object) :
	stereoType == null ? null : setRestrictions(object, stereoType, restrictionType) ->
	removeUnwantedRestrictions(data, restrictionType);		
	