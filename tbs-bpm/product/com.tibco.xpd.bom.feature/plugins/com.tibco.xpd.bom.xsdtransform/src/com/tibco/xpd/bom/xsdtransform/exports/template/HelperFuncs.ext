import xmlSchema;
import uml;
import com::tibco::xpd::bom::xsdtransform::exports::template;

extension org::openarchitectureware::xsd::lib::qname;
extension com::tibco::xpd::bom::xsdtransform::exports::template::Extensions reexport;
extension com::tibco::xpd::bom::xsdtransform::exports::template::SimpleTypeTemplates reexport;

cached String getPrefix(ExportTransformationData data, Package pkg):
	data.generatePrefix(pkg.name/*.toLowerCase()*/);

NoFixedFacet toNoFixedFacet(ExportTransformationData data, List enumeration, String tempName, EnumerationLiteral enumLit, Enumeration tempEnum):
	let tmpFacet = new NoFixedFacet :
	tempEnum.generalization.size == 0 || enumLit == null ? (
		tempName.trim().length > 0 ? (
			tmpFacet.setValue(tempName) ->
			addFeatureMapEntry(tmpFacet.anyAttribute, tempName, "name") 
		): null		
	) : (
		let value = (
			enumLit.eAnnotations.first() != null && enumLit.eAnnotations.first().contents.first() != null ? (
				enumLit.eAnnotations.first().contents.first().value
			) : (
				tempName
			)
		) :
		value.trim().length > 0 ? (
			tmpFacet.setValue(value) ->
			addFeatureMapEntry(tmpFacet.anyAttribute, tempName, "name") 
		) : null		
	) ->		
	enumeration.add(tmpFacet) ->
	tmpFacet;
	
Object getStereotypeValue(uml::Element umlElement, uml::Stereotype stereotype, String propertyName) :
	let hasValue = hasValue(umlElement, stereotype, propertyName) :
	hasValue == true ? getValue(umlElement, stereotype, propertyName) : null;
	
cached addImportType(ExportTransformationData data, SchemaType baseSchemaType, SchemaType superSchemaType, Package basePackage, String prefix, String namespace) :
	let importType = new ImportType :
	let superDocRoot = (XmlSchemaDocumentRoot)superSchemaType.eContainer :
	let baseDocRoot = (XmlSchemaDocumentRoot)baseSchemaType.eContainer :
	
	superDocRoot.xMLNSPrefixMap.put(prefix,namespace) ->
	importType.setNamespace(namespace) ->	
	importType.setSchemaLocation(data.getFileName(baseDocRoot.schema.targetNamespace).replaceFirst("http://","").split("/").last()) ->
	(
		let appliedModelStereotype = basePackage.getAppliedStereotypes().select(e|e.name == "XsdBasedModel").first() :
		appliedModelStereotype == null ? null : (
			let stereotypeTargetNamespace = getStereotypeValue(basePackage, appliedModelStereotype, "xsdTargetNamespace") :
			let stereotypeSchemaLocation = getStereotypeValue(basePackage, appliedModelStereotype, "xsdSchemaLocation") :
			stereotypeTargetNamespace != null && stereotypeTargetNamespace.trim().length > 0 ? importType.setNamespace(stereotypeTargetNamespace) : null //->
			//stereotypeSchemaLocation != null && stereotypeSchemaLocation.trim().length > 0 ? importType.setSchemaLocation(stereotypeSchemaLocation) : null
		)
	) ->
	importType.namespace == null && importType.schemaLocation == null ? null : superSchemaType.^import.add(importType);
	
String getImportFileName(XmlSchemaDocumentRoot docRoot) :
	getFileNameByKey(docRoot.schema.targetNamespace);
	//docRoot.schema.targetNamespace + ".xsd";
	
cached Boolean isComplexType(Class cls):
	let xsdBasedModelStereotype = getXSDNotationStereotype(cls, "XsdBasedClass") :
	let xsdIsComplexType = getXSDNotationProperty(cls, xsdBasedModelStereotype, "xsdIsComplexType") :
	xsdBasedModelStereotype == null ? true : (
		xsdIsComplexType == null ? false : xsdIsComplexType
	);
	
cached Boolean isGroup(Class cls):
	let xsdBasedModelStereotype = getXSDNotationStereotype(cls, "XsdBasedClass") :
	let xsdIsGroup = getXSDNotationProperty(cls, xsdBasedModelStereotype, "xsdIsGroup") :
	xsdIsGroup == null ? false : xsdIsGroup;
	
cached Boolean isAttributeGroup(Class cls):
	let xsdBasedModelStereotype = getXSDNotationStereotype(cls, "XsdBasedClass") :
	let xsdisAttributeGroup = getXSDNotationProperty(cls, xsdBasedModelStereotype, "xsdIsAttributeGroup") :
	xsdisAttributeGroup == null ? false : xsdisAttributeGroup;

// XPD-5895: the local part was changed to lower case and all the cases were handled with lower case type names.
// But in getQName() method below local part was not changed to lower case.
// I had two options i) to not change local part to lower case here. OR ii) to change local part to lower case in getQName() method below.
// I have taken the first option because xsd types are not really lower case types. 
// so better we handle the types as they are defined the xml schema 
cached Boolean isKnownXSDType(String localPart):	
	switch(localPart) {		
		case "xsd:anyType": true
		case "xsd:anySimpleType": true
		case "xsd:gYearMonth": true
		case "xsd:gYear": true
		case "xsd:gMonthDay": true
		case "xsd:gDay": true
		case "xsd:gMonth": true
		case "xsd:QName": true
		case "xsd:NOTATION": true
		case "xsd:normalizedString": true
		case "xsd:token": true
		case "xsd:nonPositiveInteger": true
		case "xsd:long": true
		case "xsd:nonNegativeInteger": true
		case "xsd:language": true
		case "xsd:Name": true
		case "xsd:NMTOKEN": true
		case "xsd:negativeInteger": true		
		case "xsd:unsignedLong": true
		case "xsd:positiveInteger": true
		case "xsd:NCName": true
		case "xsd:NMTOKENS": true
		case "xsd:short": true
		case "xsd:unsignedInt": true
		case "xsd:IDREF": true
		case "xsd:ENTITY": true
		case "xsd:byte": true
		case "xsd:unsignedShort": true
		case "xsd:IDREFS": true
		case "xsd:ENTITIES": true
		case "xsd:unsignedByte": true
		case "xsd:boolean": true
		case "xsd:string": true
		case "xsd:integer": true
		case "xsd:int": true
		case "xsd:decimal": true
		case "xsd:float": true
		case "xsd:double": true
		case "xsd:dateTime": true
		case "xsd:date": true
		case "xsd:time": true
		case "xsd:ID": true
		case "xsd:anyURI": true
		case "xsd:duration": true
		case "xsd:base64Binary": true
		case "xsd:hexBinary": true
		default: false
	};

cached QName getQName(SchemaType schemaType, String localPart, String prefix) :	
	let targetNamespace = schemaType.targetNamespace :	
	switch(localPart) {		
		case "xsd:anyType": createQName(localPart)
		case "xsd:anySimpleType": createQName(localPart)
		case "xsd:gYearMonth": (
			let topLevelSimpleType = createGYearMonthSimpleType(schemaType) :
			createQName(targetNamespace, topLevelSimpleType.name, prefix) 
		)
		case "xsd:gYear": (
			let topLevelSimpleType = createGYearSimpleType(schemaType) :
			createQName(targetNamespace, topLevelSimpleType.name, prefix) 
		)
		case "xsd:gMonthDay": (
			let topLevelSimpleType = createGMonthDaySimpleType(schemaType) :
			createQName(targetNamespace, topLevelSimpleType.name, prefix) 
		)
		case "xsd:gDay": (
			let topLevelSimpleType = createGDaySimpleType(schemaType) :
			createQName(targetNamespace, topLevelSimpleType.name, prefix) 
		)
		case "xsd:gMonth": (
			let topLevelSimpleType = createGMonthSimpleType(schemaType) :
			createQName(targetNamespace, topLevelSimpleType.name, prefix) 
		)
		case "xsd:QName": (
			let topLevelSimpleType = createQNameSimpleType(schemaType) :
			createQName(targetNamespace, topLevelSimpleType.name, prefix) 
		)
		case "xsd:NOTATION": createQName("xsd:string")
		case "xsd:normalizedString": (
			let topLevelSimpleType = createNormalizedStringSimpleType(schemaType) :
			createQName(targetNamespace, topLevelSimpleType.name, prefix) 
		)
		case "xsd:token": (
			let topLevelSimpleType = createTokenSimpleType(schemaType) :
			createQName(targetNamespace, topLevelSimpleType.name, prefix) 
		)
		case "xsd:nonPositiveInteger": (
			let topLevelSimpleType = createNonPositiveIntegerSimpleType(schemaType) :
			createQName(targetNamespace, topLevelSimpleType.name, prefix) 
		)
		case "xsd:long": (
			let topLevelSimpleType = createLongSimpleType(schemaType) :
			createQName(targetNamespace, topLevelSimpleType.name, prefix) 
		)
		case "xsd:nonNegativeInteger": (
			let topLevelSimpleType = createNonNegativeIntegerSimpleType(schemaType) :
			createQName(targetNamespace, topLevelSimpleType.name, prefix) 
		)
		case "xsd:language": (
			let topLevelSimpleType = createLanguageSimpleType(schemaType) :
			createQName(targetNamespace, topLevelSimpleType.name, prefix) 
		)
		case "xsd:Name": (
			let topLevelSimpleType = createNameSimpleType(schemaType) :
			createQName(targetNamespace, topLevelSimpleType.name, prefix) 
		)
		case "xsd:NMTOKEN": (
			let topLevelSimpleType = createNMTokenSimpleType(schemaType) :
			createQName(targetNamespace, topLevelSimpleType.name, prefix) 
		)
		case "xsd:negativeInteger": (
			let topLevelSimpleType = createNegativeIntegerSimpleType(schemaType) :
			createQName(targetNamespace, topLevelSimpleType.name, prefix) 
		)
		case "xsd:int": createQName(localPart)			
		case "xsd:unsignedLong": (
			let topLevelSimpleType = createUnsignedLongSimpleType(schemaType) :
			createQName(targetNamespace, topLevelSimpleType.name, prefix) 
		)
		case "xsd:positiveInteger": (
			let topLevelSimpleType = createPositiveIntegerSimpleType(schemaType) :
			createQName(targetNamespace, topLevelSimpleType.name, prefix) 
		)
		case "xsd:NCName": (
			let topLevelSimpleType = createNCNameSimpleType(schemaType) :
			createQName(targetNamespace, topLevelSimpleType.name, prefix) 
		)
		case "xsd:NMTOKENS": (
			let topLevelSimpleType = createNMTokensSimpleType(schemaType) :
			createQName(targetNamespace, topLevelSimpleType.name, prefix) 
		)
		case "xsd:short": (
			let topLevelSimpleType = createShortSimpleType(schemaType) :
			createQName(targetNamespace, topLevelSimpleType.name, prefix) 
		)
		case "xsd:unsignedInt": (
			let topLevelSimpleType = createUnsignedIntSimpleType(schemaType) :
			createQName(targetNamespace, topLevelSimpleType.name, prefix) 
		)
		case "xsd:IDREF": (
			let topLevelSimpleType = createIDRefSimpleType(schemaType) :
			createQName(targetNamespace, topLevelSimpleType.name, prefix) 
		)
		case "xsd:ENTITY": (
			let topLevelSimpleType = createEntitySimpleType(schemaType) :
			createQName(targetNamespace, topLevelSimpleType.name, prefix) 
		)
		case "xsd:byte": (
			let topLevelSimpleType = createByteSimpleType(schemaType) :
			createQName(targetNamespace, topLevelSimpleType.name, prefix) 
		)
		case "xsd:unsignedShort": (
			let topLevelSimpleType = createUnsignedShortSimpleType(schemaType) :
			createQName(targetNamespace, topLevelSimpleType.name, prefix) 
		)
		case "xsd:IDREFS": (
			let topLevelSimpleType = createIDRefsSimpleType(schemaType) :
			createQName(targetNamespace, topLevelSimpleType.name, prefix) 
		)
		case "xsd:ENTITIES": (
			let topLevelSimpleType = createEntitiesSimpleType(schemaType) :
			createQName(targetNamespace, topLevelSimpleType.name, prefix) 
		)
		case "xsd:unsignedByte": (
			let topLevelSimpleType = createUnsignedByteSimpleType(schemaType) :
			createQName(targetNamespace, topLevelSimpleType.name, prefix) 
		)
		case "xsd:hexBinary": (
			let topLevelSimpleType = createHexBinarySimpleType(schemaType) :
			createQName(targetNamespace, topLevelSimpleType.name, prefix) 
		)
		case "xsd:base64Binary": (
			let topLevelSimpleType = createBase64BinarySimpleType(schemaType) :
			createQName(targetNamespace, topLevelSimpleType.name, prefix) 
		)
		case "xsd:ID": (
			let topLevelSimpleType = createIDSimpleType(schemaType) :
			createQName(targetNamespace, topLevelSimpleType.name, prefix)			
		)
		case "xsd:double": (
			let topLevelSimpleType = createDoubleSimpleType(schemaType) :
			createQName(targetNamespace, topLevelSimpleType.name, prefix)		
		)
		case "xsd:float": (
			let topLevelSimpleType = createFloatSimpleType(schemaType) :
			createQName(targetNamespace, topLevelSimpleType.name, prefix) 
		)
		default: (
			isKnownXSDType(ReplaceFirst(localPart,":","xsd:")) ? createQName(localPart) : createQName(targetNamespace, localPart, prefix)
		)
	};
	
cached QName getPropertyQName(ExportTransformationData data, Property property, String origType) :	
	let type = property.type :
	let primName = type.name :
	let appliedStereotype = property.getAppliedStereotypes().select(e|e.name == "XsdBasedElement").first() :
	let appliedRestrictedTypeStereotype = property.getAppliedStereotypes().select(e|e.name == "RestrictedType").first() :	
	appliedStereotype == null ? (
		switch(primName) {
			case "Integer": (
				let subType = getStereotypeValue(property, appliedRestrictedTypeStereotype, "integerSubType") :
				subType == null ? (
					isSignedInteger(type) == true ? createQName("xsd:int") : createQName("xsd:integer")
				) : (			
					subType.name == "signedInteger" ? createQName("xsd:int") : createQName("xsd:integer")
				)
			)
			case "Decimal": (
				let subType = getStereotypeValue(property, appliedRestrictedTypeStereotype, "decimalSubType") :
				subType == null ? (
					isFloatingPointDecimal(type) == true ? createQName("xsd:double") : createQName("xsd:decimal")
				) : (
					subType.name == "floatingPoint" ? createQName("xsd:double") : createQName("xsd:decimal")
				)
			)
			default: (
				getQName(type, origType)
			)
		}
	) : getQName(type, origType);
	
cached QName getQName(ExportTransformationData data, Classifier baseClassifier, Classifier classifier, String origType) :	
	let primName = classifier.name :
	let appliedStereotype = baseClassifier.getAppliedStereotypes().select(e|e.name == "XsdBasedElement").first() :		
	(appliedStereotype == null) ? (
		switch(primName) {
			case "Integer": (			
				isSignedInteger(baseClassifier) == true ? createQName("xsd:int") : createQName("xsd:integer")			
			)
			case "Decimal": (
				isFloatingPointDecimal(baseClassifier) == true ? createQName("xsd:double") : createQName("xsd:decimal")
			)
			default: (
				getQName(classifier, origType)
			)
		}
	) : (
		primName != null ? getQName(classifier, origType) : createQName(origType)
	);
	
cached QName getQNameStr(String primName, String origType) :
	switch(primName) {		
			case "Boolean": (
				origType == null ? createQName("xsd:boolean") : createQName(origType)
			)
			case "Text": (
				origType == null ? createQName("xsd:string") : createQName(origType)
			)
			case "Integer": (
				origType == null ? createQName("xsd:integer") : createQName(origType)
			)
			case "Decimal": (
				origType == null ? createQName("xsd:decimal") : createQName(origType) 
			)
			case "DateTime": (
				origType == null ? createQName("xsd:dateTime") : createQName(origType)
			)
			case "DateTimeTZ": (
				origType == null ? createQName("xsd:dateTime") : createQName(origType)
			)
			case "Date": (
				origType == null ? createQName("xsd:date") : createQName(origType)
			)
			case "Time": (
				origType == null ? createQName("xsd:time") : createQName(origType)
			)
			case "ID": (
				origType == null ? createQName("xsd:string") : createQName(origType)
			)
			case "URI": (
				origType == null ? createQName("xsd:anyURI") : createQName(origType)
			)					
			case "Duration": (
				origType == null ? createQName("xsd:duration") : createQName(origType)
			)
			case "Attachment": (
				origType == null ? createQName("xsd:base64Binary") : createQName(origType)
			)			
			default: (
				null//origType == null ? createQName("xsd:string") : createQName(origType)
			)
		};
		
cached Boolean isExistPackagedElementWithXSDTypeName(ExportTransformationData data, String localPart) :
	let packagedElement = data.modelsToParse.packagedElement.selectFirst(e | e.name == localPart) :
	packagedElement != null ? true : false;
	
cached QName getQName(Classifier classifier, String origType) :
	let primName = classifier.name :
	isStandardPrimitive(classifier) ? getQNameStr(primName, origType) : null;
	
cached String getBaseXSDType(String localPart):
	switch(localPart) {		
		case "xsd:anyType": "xsd:anyType"
		case "xsd:anySimpleType": "xsd:anySimpleType"
		case "xsd:gYearMonth": "xsd:string"
		case "xsd:gYear": "xsd:string"
		case "xsd:gMonthDay": "xsd:string"
		case "xsd:gDay": "xsd:string"
		case "xsd:gMonth": "xsd:string"
		case "xsd:QName": "xsd:string"
		case "xsd:NOTATION": "xsd:string"
		case "xsd:normalizedString": "xsd:string"
		case "xsd:token": "xsd:string"
		case "xsd:nonPositiveInteger": "xsd:integer"
		case "xsd:long": "xsd:integer"
		case "xsd:nonNegativeInteger": "xsd:integer"
		case "xsd:language": "xsd:string"
		case "xsd:Name": "xsd:string"
		case "xsd:NMTOKEN": "xsd:string"
		case "xsd:negativeInteger": "xsd:integer"		
		case "xsd:unsignedLong": "xsd:integer"
		case "xsd:positiveInteger": "xsd:integer"
		case "xsd:NCName": "xsd:string"
		case "xsd:NMTOKENS": "xsd:string"
		case "xsd:short": "xsd:int"
		case "xsd:unsignedInt": "xsd:integer"
		case "xsd:IDREF": "xsd:string"
		case "xsd:ENTITY": "xsd:string"
		case "xsd:byte": "xsd:int"
		case "xsd:unsignedShort": "xsd:integer"
		case "xsd:IDREFS": "xsd:string"
		case "xsd:ENTITIES": "xsd:string"
		case "xsd:unsignedByte": "xsd:int"
		case "xsd:boolean": "xsd:boolean"
		case "xsd:string": "xsd:string"
		case "xsd:integer": "xsd:integer"
		case "xsd:int": "xsd:int"
		case "xsd:decimal": "xsd:decimal"
		case "xsd:float": "xsd:double"
		case "xsd:double": "xsd:double"
		case "xsd:dateTime": "xsd:dateTime"
		case "xsd:date": "xsd:date"
		case "xsd:time": "xsd:time"
		case "xsd:ID": "xsd:string"
		case "xsd:anyURI": "xsd:anyURI"
		case "xsd:duration": "xsd:duration"
		case "xsd:base64Binary": "xsd:string"
		case "xsd:hexBinary": "xsd:string"
		default: "xsd:string"
	};

cached String getPropertyRefName(ExportTransformationData data, Property property) :	 
	let appliedPropertyStereotype = property.getAppliedStereotypes().select(e|e.name == "XsdBasedProperty").first() :	
	appliedPropertyStereotype != null ? (
		let ref = getStereotypeValue(property, appliedPropertyStereotype, "xsdRef") :	
		getTypeName(data, property, ref)	
	) : getTypeName(data, property, property.type.name);
		
cached String getPropertyTypeName(ExportTransformationData data, Property property) :	 
	let appliedPropertyStereotype = property.getAppliedStereotypes().select(e|e.name == "XsdBasedProperty").first() :	
	appliedPropertyStereotype != null ? (
		let type = getStereotypeValue(property, appliedPropertyStereotype, "xsdType") :	
		let typeName = getTypeName(data, property, type) :
		typeName != null ? typeName : (
			getPackagableElementTypeName(data, property, property.type.name)
		)
	) : getTypeName(data, property, property.type.name);
	
String getPackagableElementTypeName(ExportTransformationData data, NamedElement namedElement, String defaultGeneralTypeName) :	 
	let appliedPrimitiveStereotype = namedElement.getAppliedStereotypes().select(e|e.name == "XsdBasedPrimitiveType").first() :	
	appliedPrimitiveStereotype != null ? (
		let type = getStereotypeValue(namedElement, appliedPrimitiveStereotype, "xsdRestrictionBase") :	
		getTypeName(data, namedElement, type)	
	) : getTypeName(data, namedElement, defaultGeneralTypeName);
	
String getTypeName(ExportTransformationData data, NamedElement namedElement, String type) :
	let appliedStereotype = namedElement.getAppliedStereotypes().select(e|e.name == "XsdBasedElement").first() :	
	type != null && type.trim().length > 0 ? (			
		let tmpType = (
			let resolvedPrimType = (
				Property.isInstance(namedElement) ? getQName(((Property)namedElement).type, null) : (
					DataType.isInstance(namedElement) ? getQName(((DataType)namedElement).general.first(), null) : (
						getQNameStr(type.trim(), null)
					)
				)
			) :
			resolvedPrimType == null ? type : resolvedPrimType.localPart
		) :		
		isKnownXSDType(ReplaceFirst(tmpType,":","xsd:")) == false ? (			
			Property.isInstance(namedElement) ? ReplaceFirst(tmpType,":", getPrefix(data, ((Property)namedElement).type.package)+":")	: (			
				DataType.isInstance(namedElement) ? ReplaceFirst(tmpType,":", getPrefix(data, ((DataType)namedElement).package)+":") : ( 
					ReplaceFirst(tmpType,":","")
				)
			)
		) : (
			let appliedModelStereotype = namedElement.getModel().getAppliedStereotypes().select(e|e.name == "XsdBasedModel").first() :
			appliedModelStereotype != null || (appliedModelStereotype == null && getQNameStr(type, null) != null) ? (
				let tmpXSDType = ReplaceFirst(tmpType,":","xsd:") :			
				let resultXSDType = (
					appliedStereotype == null ? getBaseXSDType(tmpXSDType) : ReplaceFirst(type,":","xsd:")
				) :			
				Property.isInstance(namedElement) ? (				
					(resultXSDType == "xsd:integer" || resultXSDType == "xsd:decimal") ? getPropertyQName(data, (Property)namedElement, resultXSDType).localPart : resultXSDType
				) : (			
					DataType.isInstance(namedElement) ? (									
						(resultXSDType == "xsd:integer" || resultXSDType == "xsd:decimal") ? (
							let tmpQName = getQName(data, (Classifier)namedElement,(Classifier)((DataType)namedElement).general.first(), resultXSDType) :
							tmpQName != null ? tmpQName.localPart : resultXSDType						 
						) : resultXSDType 
					) : ( 
						resultXSDType
					)
				)	
			) :	type	
		)
	) : type;
	
cached Boolean isAttribute(Property property) :
	let appliedPropertyStereotype = property.getAppliedStereotypes().select(e|e.name == "XsdBasedProperty").first() :	
	appliedPropertyStereotype != null ? (
		let type = getStereotypeValue(property, appliedPropertyStereotype, "xsdIsAttribute") :
		type == null ? false : type
	) : false;
	
	
cached ComplexType getComplexWithAnonymousContainer(xmlSchema::SchemaType containerElementSchema, Class tmpCls, Collection[Package] packageList) :
	let xsdBasedModelStereotype = getXSDNotationStereotype(tmpCls, "XsdBasedClass") :
	let isAnonymousContainer = getXSDNotationProperty(tmpCls, xsdBasedModelStereotype, "xsdIsAnonType") :	
	isAnonymousContainer == true ? (
		let parentName = ReplaceLast(tmpCls.name, "Type", "") :				
		let parentElement = containerElementSchema.element.select(e|e.name == parentName).first() :
		let parentElementComplexType = parentElement.complexType :		
		parentElementComplexType
	) : null;	
	
cached boolean parseComplexWithAnonymous(Property containerElement, Property containedElement, xmlSchema::SchemaType containerElementSchema, Object containerComplexType, Object containedComplexType) :	
	(containerElement.type.eAnnotations.source.size > 0 && containedElement.type.eAnnotations.source.size > 0) ? (
		let element = new TopLevelElement : 
		let xsdBasedModelStereotype = getXSDNotationStereotype(containerElement.type, "XsdBasedClass") :		
		let isAnonymousContainer = getXSDNotationProperty(containerElement.type, xsdBasedModelStereotype, "xsdIsAnonContainer") :
		let xsdBasedModelStereotype = getXSDNotationStereotype(containedElement.type, "XsdBasedClass") :
		let isAnonymousContained = getXSDNotationProperty(containedElement.type, xsdBasedModelStereotype, "xsdIsAnonType") :				
		(isAnonymousContainer && isAnonymousContained && containedElement.type.name.contains(containerElement.type.name)) ? (			
			let xrefId = getXRefID(containerElement) :
			element.setName(containerElement.type.name) ->
			xrefId == null || xrefId.trim().length == 0 ? null : (
				element.setId(xrefId)
				//element.setAnnotation(createAnnotationType("xsdID="+xrefId)) 
			) ->			
			(containedComplexType.metaType.name == "xmlSchema::ComplexType" || containedComplexType.metaType.name == "xmlSchema::LocalComplexType" || containedComplexType.metaType.name == "xmlSchema::TopLevelComplexType") ? (
				copyComplexTypeAttrs(element, containerElementSchema, containerComplexType, containedComplexType)
			) : (
				containedComplexType.metaType.name == "xmlSchema::NamedGroup" ? (
					false
				) : (
					containedComplexType.metaType.name == "xmlSchema::NamedAttributeGroup" ? (
						false
					) : false				
				)
			)
		) : false		
	) : false ;
	
cached Boolean copyComplexTypeAttrs(TopLevelElement element, xmlSchema::SchemaType containerElementSchema, Object containerComplexType, ComplexType containedComplexType) :
	let localComplexType = new LocalComplexType :
	localComplexType.setAll(containedComplexType.all) ->
	containedComplexType.annotation != null ? localComplexType.setAnnotation(containedComplexType.annotation) : null ->
	containedComplexType.attribute != null ? localComplexType.setAttribute(containedComplexType.attribute) : null ->
	containedComplexType.attributeGroup != null ? localComplexType.setAttributeGroup(containedComplexType.attributeGroup) : null ->
	localComplexType.setBlock(containedComplexType.block) ->
	localComplexType.setChoice(containedComplexType.choice) ->
	localComplexType.setAll(containedComplexType.all) ->
	containedComplexType.complexContent != null ? localComplexType.setComplexContent(containedComplexType.complexContent) : null ->
	localComplexType.setFinal(containedComplexType.final) ->
	localComplexType.setGroup(containedComplexType.group) ->
	localComplexType.setId(containedComplexType.id) ->
	localComplexType.setMixed(containedComplexType.mixed) ->
	containedComplexType.sequence != null ? localComplexType.setSequence(containedComplexType.sequence) : null ->
	containedComplexType.simpleContent != null ? localComplexType.setSimpleContent(containedComplexType.simpleContent) : null ->
	element.setComplexType(localComplexType) ->
	containerElementSchema.element.add(element) ->
	(containerComplexType.metaType.name == "xmlSchema::ComplexType" || containerComplexType.metaType.name == "xmlSchema::LocalComplexType" || containerComplexType.metaType.name == "xmlSchema::TopLevelComplexType") ? (
		containerElementSchema.complexType.remove(containerComplexType)
	) : (
		containerComplexType.metaType.name == "xmlSchema::NamedGroup" ? (
			containerElementSchema.group2.remove(containerComplexType)
		) : (
			containerComplexType.metaType.name == "xmlSchema::NamedAttributeGroup" ? (
				containerElementSchema.attributeGroup.remove(containerComplexType)
			) : null				
		)
	) ->
	containerElementSchema.complexType.remove(containedComplexType) ->
	true;	
	
cached ExplicitGroup createSequence(NamedGroup group) : 
	traceMe(">= createSequence 1") ->
	(
		let r = new ExplicitGroup:	
		group.setSequence1(r) ->	
		r
	);
	
cached ExplicitGroup createSequence(ComplexType complexType) :
	traceMe(">= createSequence 2") -> 
	(
		let r = new ExplicitGroup:	
		(complexType.complexContent != null && complexType.complexContent.^extension != null) ? 
		(
			complexType.complexContent.^extension.sequence != null ? (
				complexType.complexContent.^extension.sequence
			)  : (
				complexType.complexContent.^extension.setSequence(r) ->
				r
			)		 
		) 
		: 
		(		
			(complexType.complexContent != null && complexType.complexContent.restriction != null) ? 
			(
				complexType.complexContent.restriction.sequence != null ? (
					complexType.complexContent.restriction.sequence
				)  : (
					complexType.complexContent.restriction.setSequence(r) ->
					r
				)			
			) 
			: 
			(	
				complexType.sequence != null ? (
					complexType.sequence
				)  : (
					complexType.setSequence(r) ->
					r
				)						
			)		
		)
	);	
	
cached ExplicitGroup createSequence(SimpleRestrictionType simpleRestrictionType) : 
	traceMe(">= createSequence 3") ->
	(
		let r = new ExplicitGroup:	
		simpleRestrictionType.sequence == null ? (
			simpleRestrictionType.setSequence(r) -> 
			r
		) : simpleRestrictionType.sequence
	);
	
cached ExplicitGroup createSequence(SimpleExtensionType simpleExtensionType) : 
	traceMe(">= createSequence 4") ->
	(
		let r = new ExplicitGroup:	
		simpleExtensionType.sequence == null ? (
			simpleExtensionType.setSequence(r) -> 
			r
		) : simpleExtensionType.sequence
	);
	
cached ExplicitGroup createSequence(RestrictionType restrictionType) : 
	traceMe(">= createSequence 5") ->
	(
		let r = new ExplicitGroup:	
		restrictionType.sequence == null ? (
			restrictionType.setSequence(r) -> 
			r
		) : restrictionType.sequence
	);
	
cached ExplicitGroup createSequence(ExtensionType extensionType) : 
	traceMe(">= createSequence 6") ->
	(
		let r = new ExplicitGroup:	
		extensionType.sequence == null ? (
			extensionType.setSequence(r) -> 
			r
		) : extensionType.sequence
	);
	
cached ExplicitGroup createChoice(RestrictionType restrictionType) : 
	traceMe(">= createChoice 1") ->
	(
		let r = new ExplicitGroup:	
		restrictionType.choice == null ? (
			restrictionType.setChoice(r) -> 
			r
		) : restrictionType.choice
	);
	
cached ExplicitGroup createChoice(ExtensionType extensionType) : 
	traceMe(">= createChoice 2") ->
	(
		let r = new ExplicitGroup:	
		extensionType.choice == null ? (
			extensionType.setChoice(r) -> 
			r
		) : extensionType.choice
	);
	
cached All createAll(RestrictionType restrictionType) : 
	traceMe(">= createAll 1") ->
	(
		let r = new All:	
		restrictionType.all == null ? (
			restrictionType.setAll(r) -> 
			r
		) : restrictionType.all
	);
	
cached All createAll(ExtensionType extensionType) : 
	traceMe(">= createAll 2") ->
	(
		let r = new All:	
		extensionType.all == null ? (
			extensionType.setAll(r) -> 
			r
		) : extensionType.all
	);
	
cached Object getComplexOrGroup(xmlSchema::SchemaType schemaType, String name) :	
	let containerComplexType = (
		let tmpContainerComplexType = schemaType.complexType.select(e|e.name == name).first() :
		let tmpContainerElemWithAnonComplexType = schemaType.element.select(e|e.name +"Type" == name).first() :
		tmpContainerComplexType == null ? tmpContainerElemWithAnonComplexType.complexType : tmpContainerComplexType
	) :
	//let containerComplexType = schema.complexType.select(e|e.name == name).first() :	
	let containerGroup = schemaType.group2.select(e|e.name == name).first() :
	let containerAttributeGroup = schemaType.attributeGroup.select(e|e.name == name).first() :
	containerComplexType != null ? containerComplexType : (
		containerGroup != null ? containerGroup : (
			containerAttributeGroup != null ? containerAttributeGroup : null
		)
	);
	
cached addAnyTypeToSequence(ExplicitGroup explicitGroup, AnyType anyType, Class parentClass) :
	let existingAnyType = explicitGroup.any.select(e|e.id == anyType.id).first() :
	existingAnyType == null ? addSortAnyTypeToExplicitGroup(anyType, explicitGroup, parentClass) : null;
	
cached addElementToSequence(ExplicitGroup explicitGroup, Element element, Class parentClass) :
	let existingElement = explicitGroup.element.select(e|e.id == element.id).first() :
	existingElement == null ? addSortElementToExplicitGroup(element, explicitGroup, parentClass) : null;
	
cached Boolean isSimpleContentExtension(Property property) :
	let appliedPropertyStereotype = property.getAppliedStereotypes().select(e|e.name == "XsdBasedProperty").first() :
	appliedPropertyStereotype == null ? false : (
		let isSimpleContentExtension = getStereotypeValue(property, appliedPropertyStereotype, "xsdIsSimpleContentExtension") :		
		isSimpleContentExtension == null ? false : isSimpleContentExtension
	);		 
	 
cached Boolean isSimpleContentRestriction(Property property) :
	let appliedPropertyStereotype = property.getAppliedStereotypes().select(e|e.name == "XsdBasedProperty").first() :	
	appliedPropertyStereotype == null ? false : (
		let isSimpleContentRestriction = getStereotypeValue(property, appliedPropertyStereotype, "xsdIsSimpleContentRestriction") :		
		isSimpleContentRestriction == null ? false : isSimpleContentRestriction
	);
	
cached parseExplicitGroupTree(ExportTransformationData data, Object complexType, String modelName, List xsdExplicitGroupTreeValues, Object tmpExplicitGroup, boolean isRootSequence, List[Object] targetList, List listCount, Class parentClass) :	
	let nextCommand = xsdExplicitGroupTreeValues.first() :	
	let key = (
		ComplexType.isInstance(complexType) ? ((ComplexType)complexType).name + "-" + modelName + "-" + listCount.size.toString() : (
			Group.isInstance(complexType) ? ((Group)complexType).name + "-" + modelName + "-" + listCount.size.toString() : complexType.toString() + "-" + modelName + "-" + listCount.size.toString()
		)
	) :	
	let isAllMultiplicitySet = (
		let appliedClassStereotype = parentClass.getAppliedStereotypes().select(e|e.name == "XsdBasedClass").first() :	
		appliedClassStereotype != null && getStereotypeValue(parentClass, appliedClassStereotype, "xsdIsAllMultiplicitySet") == true
	) :
	traceMe("xsdExplicitGroupTreeValues "+xsdExplicitGroupTreeValues) ->
	traceMe("tmpExplicitGroup "+tmpExplicitGroup) ->	
	
	listCount.add("") ->	
	nextCommand != null && nextCommand.contains("=") == true ? targetList.add(tmpExplicitGroup) : null ->	
	nextCommand == null || nextCommand.trim() == "" ? null : (
		let newList = xsdExplicitGroupTreeValues.withoutFirst() :
		nextCommand == "-" ? (
			parseExplicitGroupTree(data, complexType, modelName, newList, tmpExplicitGroup/*.eContainer*/, isRootSequence, targetList, listCount, parentClass)
		)	 : null ->
		nextCommand == "~" ? (
			parseExplicitGroupTree(data, complexType, modelName, newList, tmpExplicitGroup.eContainer, isRootSequence, targetList, listCount, parentClass)
		)	 : null ->				
		tmpExplicitGroup == null && nextCommand == "S" ? (
			let explicitGroup = (				
				 data.getExplicitGroupDetail(key) == null ? (
				 	let tmpNewExplicitGroup = new ExplicitGroup :				 				 					 	
				 	tmpNewExplicitGroup
				 ) : data.getExplicitGroupDetail(key)
			) :
			(isComplex(complexType) || isGroup(complexType)) ? (				
				isComplex(complexType) ? (
					complexType.sequence == null && complexType.complexContent.^extension.sequence == null && complexType.complexContent.restriction.sequence == null  ? (
						data.addToExplicitGroupValues(key, explicitGroup) ->						
						(
							let complexContentExtension = complexType.complexContent.^extension :			
							let complexContentRestriction = complexType.complexContent.restriction :
							complexContentExtension == null && complexContentRestriction == null ? (
								complexType.setSequence(explicitGroup)
							) : (
								complexContentExtension != null ? complexContentExtension.setSequence(explicitGroup) : (
									complexContentRestriction != null ? complexContentRestriction.setSequence(explicitGroup) : null
								)
							)
						)						
					) : null
				) : (
					complexType.sequence1 == null ? (
						data.addToExplicitGroupValues(key, explicitGroup) ->						
						complexType.setSequence1(explicitGroup)						
					) : null
				)				
			) : null ->			
			(
				let nextCommand = newList.first() :				
				nextCommand == "-" ? (
					let newList = newList.withoutFirst() :
					parseExplicitGroupTree(data, complexType, modelName, newList, null, isRootSequence, targetList, listCount, parentClass)	
				) : null ->
				nextCommand == "|" ? (
					let newList = newList.withoutFirst() :
					parseExplicitGroupTree(data, complexType, modelName, newList, explicitGroup, isRootSequence, targetList, listCount, parentClass)	
				) : null ->
				nextCommand == "~" ? (								
					parseExplicitGroupTree(data, complexType, modelName, newList, explicitGroup, isRootSequence, targetList, listCount, parentClass)	
				) : null ->
				nextCommand.contains("=") == true ? targetList.add(explicitGroup) : null
			)			
		) : null ->
		
		tmpExplicitGroup == null && nextCommand == "C" ? (
			let explicitGroup = (				
				data.getExplicitGroupDetail(key) == null ? (
					let tmpNewExplicitGroup = new ExplicitGroup :
				 	tmpNewExplicitGroup 
				) : data.getExplicitGroupDetail(key)
			) :
			(isComplex(complexType) || isGroup(complexType)) ? (				
				isComplex(complexType) ? (
					complexType.choice == null ? (
						data.addToExplicitGroupValues(key, explicitGroup) ->
						(
							let complexContentExtension = complexType.complexContent.^extension :			
							let complexContentRestriction = complexType.complexContent.restriction :
							complexContentExtension == null && complexContentRestriction == null ? (
								complexType.setChoice(explicitGroup)
							) : (
								complexContentExtension != null ? complexContentExtension.setChoice(explicitGroup) : (
									complexContentRestriction != null ? complexContentRestriction.setChoice(explicitGroup) : null
								)
							)
						)					
					) : null
				) : (
					complexType.choice1 == null ? (
						data.addToExplicitGroupValues(key, explicitGroup) ->
						complexType.setChoice1(explicitGroup)						
					) : null
				)				
			) : null ->					
			(
				let nextCommand = newList.first() :
				nextCommand == "-" ? (
					let newList = newList.withoutFirst() :					
					parseExplicitGroupTree(data, complexType, modelName, newList, null, isRootSequence, targetList, listCount, parentClass)	
				) : null ->
				nextCommand == "|" ? (
					let newList = newList.withoutFirst() :
					parseExplicitGroupTree(data, complexType, modelName, newList, explicitGroup, isRootSequence, targetList, listCount, parentClass)	
				) : null ->
				nextCommand == "~" ? (					
					parseExplicitGroupTree(data, complexType, modelName, newList, explicitGroup, isRootSequence, targetList, listCount, parentClass)	
				) : null ->
				nextCommand.contains("=") == true ? targetList.add(explicitGroup) : null
			)	
		) : null ->
		
		tmpExplicitGroup == null && nextCommand == "A" ? (
			let explicitGroup = (				
				data.getExplicitGroupDetail(key) == null ? (
					let tmpAll = new All :
					isAllMultiplicitySet == true ? (
						tmpAll.setMinOccurs(0) ->
						tmpAll.setMaxOccurs(1)
					) : null ->
					tmpAll			
				) : data.getExplicitGroupDetail(key)
			) :
			(isComplex(complexType) || isGroup(complexType)) ? (				
				isComplex(complexType) ? (
					complexType.all == null ? (
						data.addToExplicitGroupValues(key, explicitGroup) ->
						complexType.setAll(explicitGroup)						
					) : null
				) : (
					complexType.all1 == null ? (
						data.addToExplicitGroupValues(key, explicitGroup) ->
						complexType.setAll1(explicitGroup)						
					) : null
				)				
			) : null ->					
			(
				let nextCommand = newList.first() :
				nextCommand == "-" ? (
					let newList = newList.withoutFirst() :					
					parseExplicitGroupTree(data, complexType, modelName, newList, null, isRootSequence, targetList, listCount, parentClass)	
				) : null ->
				nextCommand == "|" ? (
					let newList = newList.withoutFirst() :
					parseExplicitGroupTree(data, complexType, modelName, newList, explicitGroup, isRootSequence, targetList, listCount, parentClass)	
				) : null ->
				nextCommand == "~" ? (					
					parseExplicitGroupTree(data, complexType, modelName, newList, explicitGroup, isRootSequence, targetList, listCount, parentClass)	
				) : null ->
				nextCommand.contains("=") == true ? targetList.add(explicitGroup) : null
			)	
		) : null ->
		
		tmpExplicitGroup != null && nextCommand == "S" ? (		
			let explicitGroup = (				
				data.getExplicitGroupDetail(key) == null ? (
					let newExplicitGroup = new ExplicitGroup :					
					data.addToExplicitGroupValues(key, newExplicitGroup) ->
					tmpExplicitGroup.sequence.add(newExplicitGroup) ->
					newExplicitGroup
				) : (
					data.getExplicitGroupDetail(key)
				)
			) :			
			(
				let nextCommand = newList.first() :
				nextCommand == "-" ? (
					let newList = newList.withoutFirst() :					
					isComplex(explicitGroup.eContainer) || isGroup(explicitGroup.eContainer) ? (
						parseExplicitGroupTree(data, complexType, modelName, newList, null, isRootSequence, targetList, listCount, parentClass)				
					) : (
						parseExplicitGroupTree(data, complexType, modelName, newList, explicitGroup.eContainer, isRootSequence, targetList, listCount, parentClass)
					)	
				) : null ->
				nextCommand == "|" ? (
					let newList = newList.withoutFirst() :
					parseExplicitGroupTree(data, complexType, modelName, newList, explicitGroup,isRootSequence, targetList, listCount, parentClass)	
				) : null ->
				nextCommand == "~" ? (	
					let newList = newList.withoutFirst() :
					isComplex(tmpExplicitGroup.eContainer) || isGroup(tmpExplicitGroup.eContainer) ? (
						null				
					) : (
						parseExplicitGroupTree(data, complexType, modelName, newList, tmpExplicitGroup.eContainer, isRootSequence, targetList, listCount, parentClass)
					)						
				) : null ->
				nextCommand.contains("=") == true ? targetList.add(explicitGroup) : null				
			)
		) : null ->
		
		tmpExplicitGroup != null && nextCommand == "C" ? (
			let explicitGroup = (				
				data.getExplicitGroupDetail(key) == null ? (
					let newExplicitGroup = new ExplicitGroup :					
					data.addToExplicitGroupValues(key, newExplicitGroup) ->
					tmpExplicitGroup.choice.add(newExplicitGroup) ->
					newExplicitGroup
				) : (
					data.getExplicitGroupDetail(key)
				)
			) :
			(
				let nextCommand = newList.first() :
				nextCommand == "-" ? (
					let newList = newList.withoutFirst() :					
					isComplex(tmpExplicitGroup) || isGroup(tmpExplicitGroup) ? (						
						parseExplicitGroupTree(data, complexType, modelName, newList, null, isRootSequence, targetList, listCount, parentClass)				
					) : (						
						parseExplicitGroupTree(data, complexType, modelName, newList, explicitGroup.eContainer, isRootSequence, targetList, listCount, parentClass)
					)						
				) : null ->
				nextCommand == "|" ? (
					let newList = newList.withoutFirst() :
					parseExplicitGroupTree(data, complexType, modelName, newList, explicitGroup,isRootSequence, targetList, listCount, parentClass)	
				) : null ->
				nextCommand == "~" ? (	
					let newList = newList.withoutFirst() :
					isComplex(tmpExplicitGroup.eContainer) || isGroup(tmpExplicitGroup.eContainer) ? (
						null				
					) : (
						parseExplicitGroupTree(data, complexType, modelName, newList, tmpExplicitGroup.eContainer, isRootSequence, targetList, listCount, parentClass)
					)						
				) : null ->
				nextCommand.contains("=") == true ? targetList.add(explicitGroup) : null
			)		
		) : null ->
		
		tmpExplicitGroup != null && nextCommand == "A" ? (
			let explicitGroup = (				
				data.getExplicitGroupDetail(key) == null ? (
					let newExplicitGroup = new All :
					isAllMultiplicitySet == true ? (
						newExplicitGroup.setMinOccurs(0) ->
						newExplicitGroup.setMaxOccurs(1)
					) : null ->
					data.addToExplicitGroupValues(key, newExplicitGroup) ->
					tmpExplicitGroup.all.add(newExplicitGroup) ->
					newExplicitGroup
				) : (
					data.getExplicitGroupDetail(key)
				)
			) :			
			(
				let nextCommand = newList.first() :
				nextCommand == "-" ? (
					let newList = newList.withoutFirst() :					
					isComplex(tmpExplicitGroup) || isGroup(tmpExplicitGroup) ? (						
						parseExplicitGroupTree(data, complexType, modelName, newList, null, isRootSequence, targetList, listCount, parentClass)				
					) : (						
						parseExplicitGroupTree(data, complexType, modelName, newList, explicitGroup.eContainer, isRootSequence, targetList, listCount, parentClass)
					)						
				) : null ->
				nextCommand == "|" ? (
					let newList = newList.withoutFirst() :
					parseExplicitGroupTree(data, complexType, modelName, newList, explicitGroup,isRootSequence, targetList, listCount, parentClass)	
				) : null ->
				nextCommand == "~" ? (	
					let newList = newList.withoutFirst() :
					isComplex(tmpExplicitGroup.eContainer) || isGroup(tmpExplicitGroup.eContainer) ? (
						null				
					) : (
						parseExplicitGroupTree(data, complexType, modelName, newList, tmpExplicitGroup.eContainer, isRootSequence, targetList, listCount, parentClass)
					)						
				) : null ->
				nextCommand.contains("=") == true ? targetList.add(explicitGroup) : null
			)		
		) : null	
	);
	
cached Boolean isComplex(Object obj) :
	(obj.metaType.name == "xmlSchema::ComplexType" || obj.metaType.name == "xmlSchema::LocalComplexType" || obj.metaType.name == "xmlSchema::TopLevelComplexType") ? (
		true
	) : false;			

cached Boolean isGroup(Object obj) :
	(obj.metaType.name == "xmlSchema::NamedGroup") ? (
		true
	) : false;	
	
cached Boolean isAnonTypeEnum(Enumeration enumeration): 
	let xsdBasedEnumerationStereotype = getXSDNotationStereotype(enumeration, "XsdBasedEnumeration") :
	let xsdIsAnonTypeValue = getXSDNotationProperty(enumeration, xsdBasedEnumerationStereotype, "xsdIsAnonType") :	
	xsdIsAnonTypeValue == null || xsdIsAnonTypeValue.toString().trim().length == 0 ? false : (
		xsdIsAnonTypeValue == true || xsdIsAnonTypeValue.toString().toLowerCase().trim() == "true" ? true : false
	);
	
cached Boolean isAnonTypeClass(Class cls): 
	let xsdBasedModelStereotype = getXSDNotationStereotype(cls, "XsdBasedClass") :
	let xsdIsAnonTypeValue = getXSDNotationProperty(cls, xsdBasedModelStereotype, "xsdIsAnonType") :	
	xsdIsAnonTypeValue == null || xsdIsAnonTypeValue.toString().trim().length == 0 ? false : (
		xsdIsAnonTypeValue == true || xsdIsAnonTypeValue.toString().toLowerCase().trim() == "true" ? true : false
	);
	
cached String getOriginalName(NamedElement namedElement) :
	let xsdOrigNameValue = (
		Enumeration.isInstance(namedElement) == true ? (
			let appliedStereotype = namedElement.getAppliedStereotypes().select(e|e.name == "XsdBasedPrimitiveType").first() :
			appliedStereotype == null ? null : getStereotypeValue(namedElement, appliedStereotype, "xsdSimpleTypeName")
		) : (
			PrimitiveType.isInstance(namedElement) == true ? (
				let appliedStereotype = namedElement.getAppliedStereotypes().select(e|e.name == "XsdBasedPrimitiveType").first() :
				appliedStereotype == null ? null : getStereotypeValue(namedElement, appliedStereotype, "xsdSimpleTypeName")
			) : (
				Property.isInstance(namedElement) == true ? (
					let appliedStereotype = namedElement.getAppliedStereotypes().select(e|e.name == "XsdBasedProperty").first() :
					appliedStereotype == null ? null : getStereotypeValue(namedElement, appliedStereotype, "xsdName")
				) : (
					Class.isInstance(namedElement) == true ? (
						let appliedStereotype = namedElement.getAppliedStereotypes().select(e|e.name == "XsdBasedClass").first() :
						appliedStereotype == null ? null : getStereotypeValue(namedElement, appliedStereotype, "xsdName")
					) : null
				)
			)
		)
	) : 	
	xsdOrigNameValue == null || xsdOrigNameValue.toString().trim().length == 0 ? namedElement.name : xsdOrigNameValue;

cached ExplicitGroup getElementSequence(ExportTransformationData data, Object complexType, Property property) :
	let appliedPropertyStereotype = property.getAppliedStereotypes().select(e|e.name == "XsdBasedProperty").first() :	
	appliedPropertyStereotype != null ? (
		let parentClass = (Class) property.eContainer :
		getXSDSequencesAtDepth(parentClass, 1).size == 0 ? (
			getOldElementSequence(data, complexType, property)
		) : (
			let sequenceObj = getXSDSequenceForProperty(property) :			
			sequenceObj != null ? (			
				let ownedAttributes = parentClass.ownedAttribute.select(e | isSimpleContentExtension(e) == false && isSimpleContentRestriction(e) == false) :				
				sequenceObj != null ? (
					let targetDepth = getDepth(sequenceObj) :
					let targetPosition = getExplicitGroupPosition(sequenceObj) :
					let elemPosition = getPropertyPosition(data, parentClass, property, sequenceObj, ownedAttributes) :			
					let startDepth = {} :	
					let rootSeq = getRootExplicitGroup(data,complexType, parentClass) :
					treverse(data, sequenceObj, rootSeq, parentClass) ->
					addExplicitGroups(data, startDepth, targetDepth, rootSeq, parentClass, elemPosition, sequenceObj) ->
					data.getExplicitGroupForSeq(sequenceObj).eContainer != null ? null :
					(
						let parentSeq = getParentSequence(sequenceObj) :
						parentSeq == null ? null : (
							let isChoice = isChoice(parentSeq) :
							let isAll = isAll(parentSeq) :
							let parentExpGroup = data.getExplicitGroupForSeq(parentSeq) :
							let childExpGroup = data.getExplicitGroupForSeq(sequenceObj) :
							isAll == true ? (
								parentExpGroup.all.add(childExpGroup) 
							): (
								isChoice == true ? (				
									parentExpGroup.choice.add(childExpGroup) 
								) : (
									parentExpGroup.sequence.add(childExpGroup)
								)
							)
						)
					) ->					
					data.getExplicitGroupForSeq(sequenceObj)			
				) : null
			) : null
		)
	) : (
		complexType != null ? (			
			createSequence(complexType) 
		) : null
	);
	
treverse(ExportTransformationData data, Object sequenceObj, Object rootSeq, Class parentClass) :
	let parentSeq = getParentSequence(sequenceObj) :    
    parentSeq == null ? null : (
    	data.getExplicitGroupForSeq(parentSeq) != null ? null : (
    		let targetDepth = getDepth(parentSeq) :
			let targetPosition = getExplicitGroupPosition(parentSeq) :					
			let startDepth = {} :				
			treverse(data, parentSeq, rootSeq, parentClass) ->
			addExplicitGroups(data, startDepth, targetDepth, rootSeq, parentClass, 1, parentSeq)
    	)
    );

// Basically adds the very first all, choice or sequence - whichever it was originally
cached Object getRootExplicitGroup(ExportTransformationData data, Object complexType, Class parentClass) :
	let currentSequenceForDepth = getXSDSequencesAtDepth(parentClass, 1).first() :
	let isChoice = isChoice(currentSequenceForDepth) :
	let isAll = isAll(currentSequenceForDepth) :
	let minOccurs = getSequenceMinOccurs(currentSequenceForDepth) :
	let maxOccurs = getSequenceMaxOccurs(currentSequenceForDepth) :	
	let existingExplicitGroup = data.getExplicitGroupForSeq(currentSequenceForDepth) :
	let complexContentExtension = complexType.complexContent.^extension :		
	let complexContentRestriction = complexType.complexContent.restriction :
	let insertingContainer = (
		complexContentExtension != null ? complexContentExtension : (
			complexContentRestriction != null ? complexContentRestriction : (
				complexType	
			)
		)		
	) :
	existingExplicitGroup == null ? (
		let explicitGroup = (
			isAll == true ? new All : new ExplicitGroup
		) :	
		minOccurs.toString() == "1" ? null : explicitGroup.setMinOccurs(minOccurs) ->
		maxOccurs == -1 ? explicitGroup.setMaxOccurs(AllNniMember1::unbounded) : (							
			maxOccurs.toString() == "1" ? null : explicitGroup.setMaxOccurs(maxOccurs)
		) ->
		isAll == true ? (
			insertingContainer.setAll(explicitGroup) 
		): (
			isChoice == true ? (				
				insertingContainer.setChoice(explicitGroup) 
			) : (
				insertingContainer.setSequence(explicitGroup)
			)
		) ->	
		data.addSeqExplicitGroup(currentSequenceForDepth, explicitGroup) ->	
		currentSequenceForDepth
	) : existingExplicitGroup;
			
// Recursively adds all the other explicit groups and will return the one that the property will then require inserting into
cached addExplicitGroups(ExportTransformationData data, List startDepth, Integer targetDepth, Object parentSeq, Class parentClass, Integer elemPosition, Object sequenceObj) :	
	startDepth.size == targetDepth ? (		
		null 
	) : (
		let currentSequencesForDepth = (
			startDepth.add("") ->
			getXSDSequencesAtDepth(parentClass, (startDepth.size+1))
		) :
		currentSequencesForDepth.collect(e | 
			(
				let existingExplicitGroup = data.getExplicitGroupForSeq(e) :
				existingExplicitGroup == null ? (
					let currentElemPos = getElementPosition(e) :
					let explicitGroupForInsertion = data.getExplicitGroupForSeq(sequenceObj) :					
					
					explicitGroupForInsertion == null ? (
						let isChoice = isChoice(e) :
						let isAll = isAll(e) :
						let minOccurs = getSequenceMinOccurs(e) :
						let maxOccurs = getSequenceMaxOccurs(e) :
						let explicitGroup = (
							isAll == true ? new All : new ExplicitGroup
						) :	
						let parentExplicitGroup = (
							let tmpParentSeq = getParentSequence(e) :
							data.getExplicitGroupForSeq(tmpParentSeq)
						) :						
						minOccurs.toString() == "1" ? null : explicitGroup.setMinOccurs(minOccurs) ->
						maxOccurs == -1 ? explicitGroup.setMaxOccurs(AllNniMember1::unbounded) : (							
							maxOccurs.toString() == "1" ? null : explicitGroup.setMaxOccurs(maxOccurs)
						) ->						
						isAll == true ? parentExplicitGroup.all.add(explicitGroup) : (
							isChoice == true ? parentExplicitGroup.choice.add(explicitGroup) : (
								parentExplicitGroup.sequence.add(explicitGroup)
							)
						) ->						
						data.addSeqExplicitGroup(e, explicitGroup) ->
						addExplicitGroups(data, {}.addAll(startDepth), targetDepth, e, parentClass, elemPosition, sequenceObj)
					) : (						
						explicitGroupForInsertion.eContainer == null ? (
							let parentExplicitGroup = (
								let tmpParentSeq = getParentSequence(sequenceObj) :
								data.getExplicitGroupForSeq(tmpParentSeq)
							) :
							let isChoice = isChoice(sequenceObj) :
							let isAll = isAll(sequenceObj) :							
								isAll == true ? parentExplicitGroup.all.add(explicitGroupForInsertion) : (
									isChoice == true ? parentExplicitGroup.choice.add(explicitGroupForInsertion) : (
										parentExplicitGroup.sequence.add(explicitGroupForInsertion)
									)
								) 
							
						) : null ->												
						addExplicitGroups(data, {}.addAll(startDepth), targetDepth, e, parentClass, elemPosition, sequenceObj)
					)
				) : (						
					existingExplicitGroup.eContainer == null ? (
						let parentExplicitGroup = (
							let tmpParentSeq = getParentSequence(e) :
							data.getExplicitGroupForSeq(tmpParentSeq)
						) :
						let isChoice = isChoice(e) :
						let isAll = isAll(e) :
						let currentElemPos = getElementPosition(e) :
						currentElemPos <= elemPosition ? (
							isAll == true ? parentExplicitGroup.all.add(existingExplicitGroup) : (
								isChoice == true ? parentExplicitGroup.choice.add(existingExplicitGroup) : (
									parentExplicitGroup.sequence.add(existingExplicitGroup)
								)
							)
						) : null
					) : null ->
					addExplicitGroups(data, {}.addAll(startDepth), targetDepth, e, parentClass, elemPosition, sequenceObj)
				)
			)
		)
	);
	
cached Boolean isRootSequence(Class parentClass) :
	let appliedClassStereotype = parentClass.getAppliedStereotypes().select(e|e.name == "XsdBasedClass").first() :
	appliedClassStereotype != null ? (
		let currentSequenceForDepth = getXSDSequencesAtDepth(parentClass, 1).first() :
		let isChoice = isChoice(currentSequenceForDepth) :
		let isAll = isAll(currentSequenceForDepth) :
		isChoice == false && isAll == false ? true : false
	) : true;
	
cached Boolean isRootChoice(Class parentClass) :
	let appliedClassStereotype = parentClass.getAppliedStereotypes().select(e|e.name == "XsdBasedClass").first() :
	appliedClassStereotype != null ? (
		let currentSequenceForDepth = getXSDSequencesAtDepth(parentClass, 1).first() :
		let isChoice = isChoice(currentSequenceForDepth) :
		isChoice
	) : false;
	
cached Boolean isRootAll(Class parentClass) :
	let appliedClassStereotype = parentClass.getAppliedStereotypes().select(e|e.name == "XsdBasedClass").first() :
	appliedClassStereotype != null ? (
		let currentSequenceForDepth = getXSDSequencesAtDepth(parentClass, 1).first() :
		let isAll = isAll(currentSequenceForDepth) :
		isAll
	) : false;
	
// use this for old BOMS that have the old string hierachy to work out the explicit groups
cached ExplicitGroup getOldElementSequence(ExportTransformationData data, Object complexType, Property property) :
	let appliedPropertyStereotype = property.getAppliedStereotypes().select(e|e.name == "XsdBasedProperty").first() :	
	appliedPropertyStereotype != null ? (	 
		let xsdExplicitGroupTreeValue = getStereotypeValue(property, appliedPropertyStereotype, "xsdExplicitGroupTree") :
		let xsdExplicitGroupTreeValues = xsdExplicitGroupTreeValue.split(",") :
		let isRootSequence = (
			let appliedModelStereotype = property.getModel().getAppliedStereotypes().select(e|e.name == "XsdBasedModel").first() :
			appliedModelStereotype == null ? true : (xsdExplicitGroupTreeValues.first() == "S")
		) :
		let parentClass = (Class) property.eContainer :		
		let targetList = {} :	
		let listCount = {} :
		parseExplicitGroupTree(data, complexType, property.getModel().name, xsdExplicitGroupTreeValues, null, isRootSequence, targetList, listCount, parentClass) ->
		traceMe("getting element " + property.name) ->		
		traceMe("existing sequence = " + targetList.last()) ->
		targetList.last() == null ? (
			complexType != null ? (
				traceMe("createSequence 1") ->
				createSequence(complexType) 
			) : null
		) : (				
			complexType == null ? targetList.last() : (
				targetList.last().eContainer == null ? createSequence(complexType) : (					
					let counterList = {} :
					let rootExplicitGroup = (
						complexType.sequence != null ? complexType.sequence : (
							complexType.choice != null ? complexType.choice : null
						)
					) :
					rootExplicitGroup != null ? (
						let minOccurs = getMinOccursForExplicitGroup(parentClass, (counterList.size).toString()) :	
						let maxOccurs = getMaxOccursForExplicitGroup(parentClass, (counterList.size).toString()) :
						minOccurs.toString() == "1" ? null : rootExplicitGroup.setMinOccurs(minOccurs) ->
						maxOccurs == -1 ? rootExplicitGroup.setMaxOccurs(AllNniMember1::unbounded) : (							
							maxOccurs.toString() == "1" ? null : rootExplicitGroup.setMaxOccurs(maxOccurs)
						) ->
						counterList.add("") ->					
						rootExplicitGroup.eContents.flatten().select(b|ExplicitGroup.isInstance(b) == true).collect(e | (
								let minOccurs = getMinOccursForExplicitGroup(parentClass, (counterList.size).toString()) :	
								let maxOccurs = getMaxOccursForExplicitGroup(parentClass, (counterList.size).toString()) :						
								minOccurs.toString() == "1" ? null : e.setMinOccurs(minOccurs) ->
								maxOccurs == -1 ? e.setMaxOccurs(AllNniMember1::unbounded) : (
									maxOccurs.toString() == "1" ? null : e.setMaxOccurs(maxOccurs)
								) ->
								counterList.add("") ->
								(e.sequence.size > 0 || e.choice.size > 0) ? parseContents(e,counterList, parentClass) : null
							)
						)
					) : null ->
					targetList.last()
				) 
			)						
		)
	) : (
		complexType != null ? (
			traceMe("createSequence 2") ->
			createSequence(complexType) 
		) : null
	);
	
parseContents(ExplicitGroup explicitGroup,List counterList, Class parentClass) :
	explicitGroup.eContents.flatten().select(b|ExplicitGroup.isInstance(b) == true).collect(e | (
			let minOccurs = getMinOccursForExplicitGroup(parentClass, (counterList.size).toString()) :
			let maxOccurs = getMaxOccursForExplicitGroup(parentClass, (counterList.size).toString()) :			
			minOccurs.toString() == "1" ? null : e.setMinOccurs(minOccurs) ->
			maxOccurs == -1 ? e.setMaxOccurs(AllNniMember1::unbounded) : (
				maxOccurs.toString() == "1" ? null : e.setMaxOccurs(maxOccurs)
			) ->
			counterList.add("") ->
			(e.sequence.size > 0 || e.choice.size > 0) ? parseContents(e,counterList, parentClass) : null
		)
	); 	
	
cached Boolean isAllContainer(ExportTransformationData data, Property property) :
	let appliedPropertyStereotype = property.getAppliedStereotypes().select(e|e.name == "XsdBasedProperty").first() :	
	appliedPropertyStereotype != null ? (	 
		let parentClass = (Class) property.eContainer :
		getXSDSequencesAtDepth(parentClass, 1).size == 0 ? (
			let xsdExplicitGroupTreeValue = getStereotypeValue(property, appliedPropertyStereotype, "xsdExplicitGroupTree") :
			let xsdExplicitGroupTreeValues = xsdExplicitGroupTreeValue.split(",") :
			let isRootAll = (xsdExplicitGroupTreeValues.first() == "A") :
			isRootAll
		) : (
			let isRootAll = isRootAll(parentClass) :
			isRootAll		
		)
	) : (
		false
	);
	
cached addSortElementToExplicitGroup(LocalElement elem, ExplicitGroup explicitGroup, Class parentClass) :
	let existingElement = explicitGroup.element.select(e|e.id == elem.id).first() :
	existingElement == null ? explicitGroup.element.add(elem) : null;	
	
cached addSortAnyTypeToExplicitGroup(AnyType anyType, ExplicitGroup explicitGroup, Class parentClass) :
	explicitGroup.any.add(anyType);
	
setElementStereotypedValues(ExportTransformationData data, Property property, Element element) :
	let appliedPropertyStereotype = property.getAppliedStereotypes().select(e|e.name == "XsdBasedProperty").first() :
	let appliedPrimitiveStereotype = property.getAppliedStereotypes().select(e|e.name == "XsdBasedPrimitiveType").first() :
	appliedPropertyStereotype == null || element == null ? null : (				
		let form = getStereotypeValue(property, appliedPropertyStereotype, "xsdForm") :
		let tempDefault = getStereotypeValue(property, appliedPropertyStereotype, "xsdDefault") :
		let tempId = getStereotypeValue(property, appliedPropertyStereotype, "xsdId") :
		let fixed = getStereotypeValue(property, appliedPropertyStereotype, "xsdFixed") :				
		let abstract = getStereotypeValue(property, appliedPropertyStereotype, "xsdAbstract") :				
		let nillable = getStereotypeValue(property, appliedPropertyStereotype, "xsdNillable") :
		let substitutionGroup = getStereotypeValue(property, appliedPropertyStereotype, "xsdSubstitutionGroup") :			
		form != null && form.trim().length > 0 ? (
			form == "qualified" ? element.setForm(FormChoice::qualified) : null -> 
			form == "unqualified" ? element.setForm(FormChoice::unqualified) : null			
		) : null ->	
		tempDefault != null && tempDefault.trim().length > 0 ? element.setDefault(tempDefault) : null ->
		tempId != null && tempId.trim().length > 0 ? element.setId(tempId) : null ->
		fixed != null && fixed.trim().length > 0 ? element.setFixed(fixed) : null ->
		abstract != null && abstract.trim().length > 0 ? element.setAbstract(abstract) : null ->		
		nillable != null && nillable.trim().length > 0 && nillable.trim().toLowerCase() == "true" ? element.setNillable(true) : null ->
		substitutionGroup != null && substitutionGroup.trim().length > 0 ? (					
			let qname = createQName(substitutionGroup) :
			element.setSubstitutionGroup(qname)
		) : null ->
		setElementOrComplexBlock(property, element) ->
		setElemComplexOrSimpleFinal(property, element)
	);
	
cached Object getRootSchema(Object obj) :
	xmlSchema::SchemaType.isInstance(obj) || obj == null ? obj : getRootSchema(obj.eContainer);
	
setOtherStereotypedValues(ExportTransformationData data, Property property, Element element, SchemaType schemaType2) :
	let appliedPropertyStereotype = property.getAppliedStereotypes().select(e|e.name == "XsdBasedProperty").first() :
	let appliedPrimitiveStereotype = property.getAppliedStereotypes().select(e|e.name == "XsdBasedPrimitiveType").first() :
	let parentClass = (Class) property.eContainer :
	appliedPropertyStereotype == null || element == null ? null : (
		//let tempName = getStereotypeValue(property, appliedPropertyStereotype, "xsdName") :
		let type = getStereotypeValue(property, appliedPropertyStereotype, "xsdType") :		
		let form = getStereotypeValue(property, appliedPropertyStereotype, "xsdForm") :
		let tempDefault = getStereotypeValue(property, appliedPropertyStereotype, "xsdDefault") :
		let tempId = getStereotypeValue(property, appliedPropertyStereotype, "xsdId") :
		let fixed = getStereotypeValue(property, appliedPropertyStereotype, "xsdFixed") :				
		let abstract = getStereotypeValue(property, appliedPropertyStereotype, "xsdAbstract") :
		let nillable = getStereotypeValue(property, appliedPropertyStereotype, "xsdNillable") :
		let substitutionGroup = getStereotypeValue(property, appliedPropertyStereotype, "xsdSubstitutionGroup") :
				
		//tempName != null && tempName.trim().length > 0 ? element.setName(tempName) : null ->
		type != null && type.trim().length > 0 ? (					
			let qname = (
				//isKnownXSDType("xsd:"+type) ? (					
				//	getQName(schemaType,("xsd:"+type),getPrefix(data,parentClass.package))
				//) :	createQName(ReplaceFirst(type,":","xsd:"))
				isKnownXSDType("xsd:"+type) ? (		
					let schemaType = getRootSchema(element) :	
					schemaType == null ? createQName(ReplaceFirst(type,":","xsd:")) : getQName(schemaType,("xsd:"+type),data.getPrefixForNamespace(schemaType.targetNamespace))
				) :	createQName(ReplaceFirst(type,":","xsd:"))
			) :			
			element.setType(qname)
		) : null ->	
		form != null && form.trim().length > 0 ? (
			form == "qualified" ? element.setForm(FormChoice::qualified) : null -> 
			form == "unqualified" ? element.setForm(FormChoice::unqualified) : null			
		) : null ->	
		tempDefault != null && tempDefault.trim().length > 0 ? element.setDefault(tempDefault) : null ->
		tempId != null && tempId.trim().length > 0 ? element.setId(tempId) : null ->
		fixed != null && fixed.trim().length > 0 ? element.setFixed(fixed) : null ->
		abstract != null && abstract.trim().length > 0 ? element.setAbstract(abstract) : null ->	
		nillable != null && nillable.trim().length > 0 && nillable.trim().toLowerCase() == "true" ? element.setNillable(true) : null ->
		substitutionGroup != null && substitutionGroup.trim().length > 0 ? (					
			let qname = createQName(substitutionGroup) :
			element.setSubstitutionGroup(qname)
		) : null ->
		setElementOrComplexBlock(property, element) ->
		setElemComplexOrSimpleFinal(property, element)
	) ->
	appliedPrimitiveStereotype == null || element == null ? null : (
		let simpleTypeName = getStereotypeValue(property, appliedPrimitiveStereotype, "xsdSimpleTypeName") :		
		let simpleTypeId = getStereotypeValue(property, appliedPrimitiveStereotype, "xsdSimpleTypeId") :				
		let restrictionId = getStereotypeValue(property, appliedPrimitiveStereotype, "xsdRestrictionId") :
		let restrictionBase = getStereotypeValue(property, appliedPrimitiveStereotype, "xsdRestrictionBase") :
		element.simpleType == null ? null : (
			simpleTypeName != null && simpleTypeName.trim().length > 0 ? element.simpleType.setName(simpleTypeName) : null ->
			simpleTypeId != null && simpleTypeId.trim().length > 0 ? element.simpleType.setId(simpleTypeId) : null ->
			setElemComplexOrSimpleFinal(property, element) ->
			element.simpleType.restriction == null ? null : (
				restrictionId != null && restrictionId.trim().length > 0 ? element.simpleType.restriction.setId(restrictionId) : null ->				
				restrictionBase != null && restrictionBase.trim().length > 0 ? (					
					let type = getPackagableElementTypeName(data, property, ReplaceFirst(restrictionBase,":","xsd:")) :
					let qName = (	
						//isKnownXSDType(ReplaceFirst(type,":","xsd:")) == false ? (		
						//	createQName(type)
						//) : (
						//	getQName(schemaType,type,getPrefix(data,parentClass.package))  
						//)
						isKnownXSDType("xsd:"+type) ? (		
							let schemaType = getRootSchema(element) :	
							schemaType == null ? createQName(ReplaceFirst(type,":","xsd:")) : getQName(schemaType,("xsd:"+type),data.getPrefixForNamespace(schemaType.targetNamespace))
						) :	createQName(ReplaceFirst(type,":","xsd:"))
					) :	
					element.simpleType.restriction.setBase(qName)					
				) : null ->
				PrimitiveTypeFacets::RestrictedType.isInstance(property) == false ? setOtherStereotypedPropertyRestrictionValues(data, property, element.simpleType.restriction) : null					
			)
		)
	);
	
setOtherStereotypedPropertyRestrictionValues(ExportTransformationData data, Property property, RestrictionType1 restriction) :
	let appliedRestrictionStereotype = property.getAppliedStereotypes().select(e|e.name == "XsdBasedRestriction").first() :
	appliedRestrictionStereotype == null ? null : (
		restriction == null ? null : (
			let fractionDigitsId = getStereotypeValue(property, appliedRestrictionStereotype, "xsdFractionDigitsId") :
			let fractionDigitsFixed = getStereotypeValue(property, appliedRestrictionStereotype, "xsdFractionDigitsFixed") :
			let fractionDigitsValue = getStereotypeValue(property, appliedRestrictionStereotype, "xsdFractionDigitsValue") :			
			let lengthId = getStereotypeValue(property, appliedRestrictionStereotype, "xsdLengthId") :
			let lengthFixed = getStereotypeValue(property, appliedRestrictionStereotype, "xsdLengthFixed") :
			let lengthValue = getStereotypeValue(property, appliedRestrictionStereotype, "xsdLengthValue") :
			let maxExclusiveId = getStereotypeValue(property, appliedRestrictionStereotype, "xsdMaxExclusiveId") :
			let maxExclusiveFixed = getStereotypeValue(property, appliedRestrictionStereotype, "xsdMaxExclusiveFixed") :
			let maxExclusiveValue = getStereotypeValue(property, appliedRestrictionStereotype, "xsdMaxExclusiveValue") :
			let maxInclusiveId = getStereotypeValue(property, appliedRestrictionStereotype, "xsdMaxInclusiveId") :
			let maxInclusiveFixed = getStereotypeValue(property, appliedRestrictionStereotype, "xsdMaxInclusiveFixed") :
			let maxInclusiveValue = getStereotypeValue(property, appliedRestrictionStereotype, "xsdMaxInclusiveValue") :
			let maxLengthId = getStereotypeValue(property, appliedRestrictionStereotype, "xsdMaxLengthId") :
			let maxLengthFixed = getStereotypeValue(property, appliedRestrictionStereotype, "xsdMaxLengthFixed") :
			let maxLengthValue = getStereotypeValue(property, appliedRestrictionStereotype, "xsdMaxLengthValue") :			
			let minExclusiveId = getStereotypeValue(property, appliedRestrictionStereotype, "xsdMinExclusiveId") :
			let minExclusiveFixed = getStereotypeValue(property, appliedRestrictionStereotype, "xsdMinExclusiveFixed") :
			let minExclusiveValue = getStereotypeValue(property, appliedRestrictionStereotype, "xsdMinExclusiveValue") :
			let minInclusiveId = getStereotypeValue(property, appliedRestrictionStereotype, "xsdMinInclusiveId") :
			let minInclusiveFixed = getStereotypeValue(property, appliedRestrictionStereotype, "xsdMinInclusiveFixed") :
			let minInclusiveValue = getStereotypeValue(property, appliedRestrictionStereotype, "xsdMinInclusiveValue") :
			let minLengthId = getStereotypeValue(property, appliedRestrictionStereotype, "xsdMinLengthId") :
			let minLengthFixed = getStereotypeValue(property, appliedRestrictionStereotype, "xsdMinLengthFixed") :
			let minLengthValue = getStereotypeValue(property, appliedRestrictionStereotype, "xsdMinLengthValue") :
			let patternId = getStereotypeValue(property, appliedRestrictionStereotype, "xsdPatternId") :
			let patternFixed = getStereotypeValue(property, appliedRestrictionStereotype, "xsdPatternFixed") :
			let patternValue = getStereotypeValue(property, appliedRestrictionStereotype, "xsdPatternValue") :						
			let totalDigitsId = getStereotypeValue(property, appliedRestrictionStereotype, "xsdTotalDigitsId") :
			let totalDigitsFixed = getStereotypeValue(property, appliedRestrictionStereotype, "xsdTotalDigitsFixed") :
			let totalDigitsValue = getStereotypeValue(property, appliedRestrictionStereotype, "xsdTotalDigitsValue") :
			let whitespaceId = getStereotypeValue(property, appliedRestrictionStereotype, "xsdWhitespaceId") :
			let whitespaceFixed = getStereotypeValue(property, appliedRestrictionStereotype, "xsdWhitespaceFixed") :
			let whitespaceValue = getStereotypeValue(property, appliedRestrictionStereotype, "xsdWhitespaceValue") :
			
			(restriction.fractionDigits.first() == null || restriction.fractionDigits.size == 0) ? (
				restriction.fractionDigits.add(new NumFacet)
			) : null ->			
			(restriction.length.first() == null || restriction.length.size == 0) ? (
				restriction.length.add(new NumFacet)
			) : null ->
			(restriction.maxExclusive.first() == null || restriction.maxExclusive.size == 0) ? (
				restriction.maxExclusive.add(new Facet)
			) : null ->
			(restriction.maxInclusive.first() == null || restriction.maxInclusive.size == 0) ? (
				restriction.maxInclusive.add(new Facet)
			) : null ->
			(restriction.maxLength.first() == null || restriction.maxLength.size == 0) ? (
				restriction.maxLength.add(new NumFacet)
			) : null ->
			(restriction.minExclusive.first() == null || restriction.minExclusive.size == 0) ? (
				restriction.minExclusive.add(new Facet)
			) : null ->
			(restriction.minInclusive.first() == null || restriction.minInclusive.size == 0) ? (
				restriction.minInclusive.add(new Facet)
			) : null ->
			(restriction.minLength.first() == null || restriction.minLength.size == 0) ? (
				restriction.minLength.add(new NumFacet)
			) : null ->
			(restriction.pattern.first() == null || restriction.pattern.size == 0) ? (
				restriction.pattern.add(new PatternType)
			) : null ->
			(restriction.totalDigits.first() == null || restriction.totalDigits.size == 0) ? (
				restriction.totalDigits.add(new TotalDigitsType)
			) : null ->
			(restriction.whiteSpace.first() == null || restriction.whiteSpace.size == 0) ? (
				restriction.whiteSpace.add(new WhiteSpaceType)
			) : null ->
			
			restriction.fractionDigits.first() != null && fractionDigitsId != null && fractionDigitsId.trim().length > 0 ? restriction.fractionDigits.first().setId(fractionDigitsId) : null ->
			restriction.fractionDigits.first() != null && fractionDigitsFixed != null ? restriction.fractionDigits.first().setFixed(toBoolean(fractionDigitsFixed)) : null ->
			restriction.fractionDigits.first() != null && fractionDigitsValue != null ? restriction.fractionDigits.first().setValue(fractionDigitsValue) : null ->
			restriction.fractionDigits.first().value == null ? (
				restriction.fractionDigits.remove(restriction.fractionDigits.first())
			) : null ->
			
			restriction.length.first() != null && lengthId != null && lengthId.trim().length > 0 ? restriction.length.first().setId(lengthId) : null ->
			restriction.length.first() != null && lengthFixed != null ? restriction.length.first().setFixed(toBoolean(lengthFixed)) : null ->
			restriction.length.first() != null && lengthValue != null ? restriction.length.first().setValue(lengthValue) : null ->
			restriction.length.first().value == null ? (
				restriction.length.remove(restriction.length.first())
			) : null ->
			
			restriction.maxExclusive.first() != null && maxExclusiveId != null && maxExclusiveId.trim().length > 0 ? restriction.maxExclusive.first().setId(maxExclusiveId) : null ->
			restriction.maxExclusive.first() != null && maxExclusiveFixed != null ? restriction.maxExclusive.first().setFixed(toBoolean(maxExclusiveFixed)) : null ->
			restriction.maxExclusive.first() != null && maxExclusiveValue != null ? restriction.maxExclusive.first().setValue(maxExclusiveValue) : null ->
			restriction.maxExclusive.first().value == null || restriction.maxExclusive.first().value.trim().length == 0 ? (				
				restriction.maxExclusive.remove(restriction.maxExclusive.first())
			) : null ->
			
			restriction.maxInclusive.first() != null && maxInclusiveId != null && maxInclusiveId.trim().length > 0 ? restriction.maxInclusive.first().setId(maxInclusiveId) : null ->
			restriction.maxInclusive.first() != null && maxInclusiveFixed != null ? restriction.maxInclusive.first().setFixed(toBoolean(maxInclusiveFixed)) : null ->
			restriction.maxInclusive.first() != null && maxInclusiveValue != null ? restriction.maxInclusive.first().setValue(maxInclusiveValue) : null ->
			restriction.maxInclusive.first().value == null || restriction.maxInclusive.first().value.trim().length == 0 ? (
				restriction.maxInclusive.remove(restriction.maxInclusive.first())
			) : null ->
			
			restriction.maxLength.first() != null && maxLengthId != null && maxLengthId.trim().length > 0 ? restriction.maxLength.first().setId(maxLengthId) : null ->
			restriction.maxLength.first() != null && maxLengthFixed != null ? restriction.maxLength.first().setFixed(toBoolean(maxLengthFixed)) : null ->
			restriction.maxLength.first() != null && maxLengthValue != null ? restriction.maxLength.first().setValue(maxLengthValue) : null ->
			restriction.maxLength.first().value == null || (restriction.maxLength.first().value != null && restriction.length.first().value != null) ? (
				restriction.maxLength.remove(restriction.maxLength.first())
			) : null ->
			
			restriction.minExclusive.first() != null && minExclusiveId && minExclusiveId.trim().length > 0 != null ? restriction.minExclusive.first().setId(minExclusiveId) : null ->
			restriction.minExclusive.first() != null && minExclusiveFixed != null ? restriction.minExclusive.first().setFixed(toBoolean(minExclusiveFixed)) : null ->
			restriction.minExclusive.first() != null && minExclusiveValue != null ? restriction.minExclusive.first().setValue(minExclusiveValue) : null ->
			restriction.minExclusive.first().value == null || restriction.minExclusive.first().value.trim().length == 0 ? (
				restriction.minExclusive.remove(restriction.minExclusive.first())
			) : null ->
			
			restriction.minInclusive.first() != null && minInclusiveId && minInclusiveId.trim().length > 0 != null ? restriction.minInclusive.first().setId(minInclusiveId) : null ->
			restriction.minInclusive.first() != null && minInclusiveFixed != null ? restriction.minInclusive.first().setFixed(toBoolean(minInclusiveFixed)) : null ->
			restriction.minInclusive.first() != null && minInclusiveValue != null ? restriction.minInclusive.first().setValue(minInclusiveValue) : null ->
			restriction.minInclusive.first().value == null || restriction.minInclusive.first().value.trim().length == 0 ? (
				restriction.minInclusive.remove(restriction.minInclusive.first())
			) : null ->
			
			restriction.minLength.first() != null && minLengthId != null && minLengthId.trim().length > 0 ? restriction.minLength.first().setId(minLengthId) : null ->
			restriction.minLength.first() != null && minLengthFixed != null ? restriction.minLength.first().setFixed(toBoolean(minLengthFixed)) : null ->
			restriction.minLength.first() != null && minLengthValue != null ? restriction.minLength.first().setValue(minLengthValue) : null ->
			restriction.minLength.first().value == null || (restriction.minLength.first().value != null && restriction.length.first().value != null) ? (
				restriction.minLength.remove(restriction.minLength.first())
			) : null ->
			
			restriction.pattern.first() != null && patternId != null && patternId.trim().length > 0 ? restriction.pattern.first().setId(patternId) : null ->
			restriction.pattern.first() != null && patternFixed != null && (patternFixed == true || patternFixed.toString() == "true") ? restriction.pattern.first().setFixed(toBoolean(patternFixed)) : null ->
			restriction.pattern.first() != null && patternValue != null ? restriction.pattern.first().setValue(patternValue) : null ->
			restriction.pattern.first().value == null ? (
				restriction.pattern.remove(restriction.pattern.first())
			) : null ->
			
			restriction.totalDigits.first() != null && totalDigitsId != null && totalDigitsId.trim().length > 0 ? restriction.totalDigits.first().setId(totalDigitsId) : null ->
			restriction.totalDigits.first() != null && totalDigitsFixed != null ? restriction.totalDigits.first().setFixed(toBoolean(totalDigitsFixed)) : null ->
			restriction.totalDigits.first() != null && totalDigitsValue != null ? restriction.totalDigits.first().setValue(totalDigitsValue) : null ->
			restriction.totalDigits.first().value == null ? (
				restriction.totalDigits.remove(restriction.totalDigits.first())
			) : null ->
									
			restriction.whiteSpace.first() != null && whitespaceId != null && whitespaceId.trim().length > 0 ? restriction.whiteSpace.first().setId(whitespaceId) : null ->
			restriction.whiteSpace.first() != null && whitespaceFixed != null ? restriction.whiteSpace.first().setFixed(toBoolean(whitespaceFixed)) : null ->
			restriction.whiteSpace.first() != null && whitespaceValue != null ? restriction.whiteSpace.first().setValue(whitespaceValue) : null ->
			restriction.whiteSpace.first().value == null ? (
				restriction.whiteSpace.remove(restriction.whiteSpace.first())
			) : null ->
			
			removeUnwantedRestrictions(data, restriction)			
		)
	);
	
cached removeUnwantedRestrictions(ExportTransformationData data, RestrictionType1 restrictionType) :
	///	
	restrictionType.base.localPart.toLowerCase() == "gday" ||
	restrictionType.base.localPart.toLowerCase() == "gyearmonth" ||
	restrictionType.base.localPart.toLowerCase() == "gyear" ||
	restrictionType.base.localPart.toLowerCase() == "gmonthday" ||
	restrictionType.base.localPart.toLowerCase()  == "gmonth" ? (
		restrictionType.maxLength.remove(restrictionType.maxLength.first()) ->
		restrictionType.pattern.remove(restrictionType.pattern.first())			
	) : null ->
	restrictionType.base.localPart.toLowerCase() == "qname" ||
	restrictionType.base.localPart.toLowerCase() == "token" ||
	restrictionType.base.localPart.toLowerCase() == "language" ||
	restrictionType.base.localPart.toLowerCase() == "name" ||
	restrictionType.base.localPart.toLowerCase() == "nmtoken" ||
	restrictionType.base.localPart.toLowerCase() == "ncname" ||
	restrictionType.base.localPart.toLowerCase() == "nmtokens" ||
	restrictionType.base.localPart.toLowerCase() == "id" ||
	restrictionType.base.localPart.toLowerCase() == "idref" ||
	restrictionType.base.localPart.toLowerCase() == "idrefs" ||
	restrictionType.base.localPart.toLowerCase() == "entity" ||
	restrictionType.base.localPart.toLowerCase() == "entities" ||
	restrictionType.base.localPart.toLowerCase() == "anysimpletype" ? (
		Element.isInstance(restrictionType.eContainer.eContainer) ? (
			((Element)restrictionType.eContainer.eContainer).setSimpleType(null) ->
			((Element)restrictionType.eContainer.eContainer).setType(restrictionType.base)
		) : null		
	) : null ->
	restrictionType.base.localPart.toLowerCase() == ("float") ? (			
		restrictionType.totalDigits.remove(restrictionType.totalDigits.first())
	) : null ->
	
	///
	restrictionType.base.localPart.toLowerCase() == "string" ? (						
		restrictionType.maxExclusive.remove(restrictionType.maxExclusive.first()) ->
		restrictionType.maxInclusive.remove(restrictionType.maxInclusive.first()) ->
		restrictionType.minExclusive.remove(restrictionType.minExclusive.first()) ->
		restrictionType.minInclusive.remove(restrictionType.minInclusive.first())
	) : null ->
	restrictionType.minInclusive.first() != null && restrictionType.minInclusive.first().value == null ? (
		restrictionType.minInclusive.remove(restrictionType.minInclusive.first())
	) : null;	
	
removeClashingRestrictions(Object propertyOrPrim, RestrictionType1 restrictionType) :
	let appliedRestrictionStereotype = propertyOrPrim.getAppliedStereotypes().select(e|e.name == "XsdBasedRestriction").first() :
	appliedRestrictionStereotype != null ? (
		let lengthValue = getStereotypeValue(propertyOrPrim, appliedRestrictionStereotype, "xsdLengthValue") :
		let minExclusiveValue = getStereotypeValue(propertyOrPrim, appliedRestrictionStereotype, "xsdMinExclusiveValue") :	
		let minInclusiveValue = getStereotypeValue(propertyOrPrim, appliedRestrictionStereotype, "xsdMinInclusiveValue") :	
		let maxExclusiveValue = getStereotypeValue(propertyOrPrim, appliedRestrictionStereotype, "xsdMaxExclusiveValue") :	
		let maxInclusiveValue = getStereotypeValue(propertyOrPrim, appliedRestrictionStereotype, "xsdMaxInclusiveValue") :
		lengthValue != null ? ( 
			restrictionType.minLength.remove(restrictionType.minLength.first()) ->
			restrictionType.maxLength.remove(restrictionType.maxLength.first())
		) : null ->
		restrictionType.minExclusive.first().value != null && restrictionType.minInclusive.first().value != null ? (			
			minExclusiveValue != null && minExclusiveValue.trim().length > 0 ? restrictionType.minInclusive.remove(restrictionType.minInclusive.first()) : null ->
			minInclusiveValue != null && minInclusiveValue.trim().length > 0 ? restrictionType.minExclusive.remove(restrictionType.minExclusive.first()) : null
		) : null ->
		restrictionType.maxExclusive.first().value != null && restrictionType.maxInclusive.first().value != null ? (
			maxExclusiveValue != null && maxExclusiveValue.trim().length > 0 ? restrictionType.maxInclusive.remove(restrictionType.maxInclusive.first()) : null ->
			maxInclusiveValue != null && maxInclusiveValue.trim().length > 0  ? restrictionType.maxExclusive.remove(restrictionType.maxExclusive.first()) : null
		) : null
	) : null;
	
setElementOrComplexBlock(Object classOrProperty, Object elemOrComplex) :
	let appliedStereotype = (
		Class.isInstance(classOrProperty) ? classOrProperty.getAppliedStereotypes().select(e|e.name == "XsdBasedClass").first() : classOrProperty.getAppliedStereotypes().select(e|e.name == "XsdBasedProperty").first()
	) :
	appliedStereotype == null || elemOrComplex == null ? null : (
		let block = getStereotypeValue(classOrProperty, appliedStereotype, "xsdBlock") :
		setBlock(elemOrComplex, block)
	);	
	
setBlock(Object elemOrComplex, Object block) :
	block != null && block.trim().length > 0 ? (
		let splitList = block.split(" ") :
		let tmpList = {} :
		splitList.select(e|e!=null && e.trim().length > 0).collect(e|tmpList.add(e.toString())) ->					
		switch(block) {
			case "#all": (
				ComplexType.isInstance(elemOrComplex) ? elemOrComplex.setBlock(DerivationSetMember0::all) : elemOrComplex.setBlock(BlockSetMember0::all)				
			)
			case "extension": (
				elemOrComplex.setBlock({BlockSetMember1Item::^extension})
			)
			case "restriction": (
				elemOrComplex.setBlock({BlockSetMember1Item::restriction})
			)					
			case "substitution": (
				elemOrComplex.setBlock({BlockSetMember1Item::substitution})
			)										
			default:											
				elemOrComplex.setBlock(tmpList)				
		}
	) : null;

setElemComplexOrSimpleFinal(Object classPropertyOrPrim, Object elemComplexOrSimple) :
	let appliedStereotype = (
		Class.isInstance(classPropertyOrPrim) ? classPropertyOrPrim.getAppliedStereotypes().select(e|e.name == "XsdBasedClass").first() : (
			Property.isInstance(classPropertyOrPrim) ? classPropertyOrPrim.getAppliedStereotypes().select(e|e.name == "XsdBasedProperty").first() : (
				DataType.isInstance(classPropertyOrPrim) ? classPropertyOrPrim.getAppliedStereotypes().select(e|e.name == "XsdBasedPrimitiveType").first() : null
			)
		)
	) :
	appliedStereotype == null || elemComplexOrSimple == null ? null : (
		let tmpFinal = (
			Class.isInstance(classPropertyOrPrim) ? getStereotypeValue(classPropertyOrPrim, appliedStereotype, "xsdFinal")  : (
				Property.isInstance(classPropertyOrPrim) ? getStereotypeValue(classPropertyOrPrim, appliedStereotype, "xsdFinal")  : (
					DataType.isInstance(classPropertyOrPrim) ? getStereotypeValue(classPropertyOrPrim, appliedStereotype, "xsdSimpleTypeFinal")  : null
				)
			)
		):
		setFinal(elemComplexOrSimple, tmpFinal)
	);		
	
setFinal(Object elemComplexOrSimple, Object finalVal) :
	finalVal != null && finalVal.trim().length > 0 ? (
		let splitList = finalVal.split(" ") :
		let tmpList = {} :
		splitList.select(e|e!=null && e.trim().length > 0).collect(e|tmpList.add(e.toString())) ->					
		switch(finalVal) {
			case "#all": (
				SimpleType.isInstance(elemComplexOrSimple) ? elemComplexOrSimple.setFinal(SimpleDerivationSetMember0::all) : elemComplexOrSimple.setFinal(DerivationSetMember0::all)								
			)				
			default:											
				elemComplexOrSimple.setFinal(tmpList)				
		}
	) : null;

// this would return the parent schema if the property is from a restricted class, otherwise it would return the original schema   	
cached xmlSchema::SchemaType getPropertySchema(Collection[xmlSchema::SchemaType] schemaTypeList, Property property) :
	// XPD-3917: whenever a property is from restricted class, schema must be 
	// from parent to set the restriction's base and element's type
	let baseClassForRestrictedProperty = (Class)_getBaseClassForRestrictedProperty(property) : 
	let originalParentClass = (Class) property.eContainer :
	let classForPropertySchema = (
		baseClassForRestrictedProperty != null ? baseClassForRestrictedProperty : originalParentClass
	) :
	let propertySchema = schemaTypeList.typeSelect(xmlSchema::SchemaType).select(e|e.targetNamespace == getNamespace(classForPropertySchema.package, true)).first() :
	propertySchema;

cached xmlSchema::SchemaType getPropertyTypeSchema(Collection[xmlSchema::SchemaType] schemaTypeList, Property property) :
	let propertyTypeSchema = schemaTypeList.typeSelect(xmlSchema::SchemaType).select(e|e.targetNamespace == getNamespace(((PrimitiveType)property.type).package,true)).first() :
	propertyTypeSchema != null ? propertyTypeSchema : (
		let propertyTypeSchema = schemaTypeList.typeSelect(xmlSchema::SchemaType).select(e|e.targetNamespace == getNamespace(((Enumeration)property.type).package,true)).first() :
		propertyTypeSchema
	);
	
cached Boolean isInMemberType(ExportTransformationData data, DataType baseElement, DataType superElement, SchemaType superElementSchema) :
	let appliedPrimitiveStereotype = superElement.getAppliedStereotypes().select(e|e.name == "XsdBasedPrimitiveType").first() :	
	let appliedUnionTypeStereotype = baseElement.getAppliedStereotypes().select(e|e.name == "XsdBasedUnion").first() :
	let xsdMemberTypes = getStereotypeValue(baseElement, appliedUnionTypeStereotype, "xsdMemberTypes") :
	let origSuperElemName = getStereotypeValue(superElement, appliedPrimitiveStereotype, "xsdSimpleTypeName") :
	xsdMemberTypes.contains("{"+superElementSchema.targetNamespace+"}"+origSuperElemName);
	
Object getPropertyMinOccurs(Property property) :
	let appliedPropertyStereotype = property.getAppliedStereotypes().select(e|e.name == "XsdBasedProperty").first() :	
	appliedPropertyStereotype != null ? (
		let minOccursValue = getStereotypeValue(property, appliedPropertyStereotype, "xsdMinOccurs") :
		minOccursValue != null && minOccursValue.trim().length > 0 ? minOccursValue.asInteger() : 1
	) : property.lower;
	
Object getPropertyMaxOccurs(Property property) :
	let appliedPropertyStereotype = property.getAppliedStereotypes().select(e|e.name == "XsdBasedProperty").first() :	
	appliedPropertyStereotype != null ? (
		let maxOccursValue = getStereotypeValue(property, appliedPropertyStereotype, "xsdMaxOccurs") :
		maxOccursValue == "*" ? AllNniMember1::unbounded : (
			maxOccursValue != null && maxOccursValue.trim().length > 0 ? maxOccursValue.asInteger() : 1
		)	
	) : (
		property.upper.toString() == "-1" ? AllNniMember1::unbounded : property.upper
	);