import xmlSchema;
import type;
import uml;
import com::tibco::xpd::bom::xsdtransform::exports::template;

extension org::openarchitectureware::xsd::lib::qname;
extension org::openarchitectureware::xsd::lib::map;
extension com::tibco::xpd::bom::xsdtransform::exports::template::Extensions reexport;
extension com::tibco::xpd::bom::xsdtransform::exports::template::GeneralisationFuncs reexport;
extension com::tibco::xpd::bom::xsdtransform::exports::template::IncrementalGeneralisationFuncs reexport;
extension com::tibco::xpd::bom::xsdtransform::exports::template::CompositionFuncs reexport;
extension com::tibco::xpd::bom::xsdtransform::exports::template::IncrementalCompositionFuncs reexport;
extension com::tibco::xpd::bom::xsdtransform::exports::template::RestrictionFuncs reexport;
extension com::tibco::xpd::bom::xsdtransform::exports::template::HelperFuncs reexport;
extension com::tibco::xpd::bom::xsdtransform::exports::template::Bom2Xsd reexport;
	
Object incrementalTransform(ExportTransformationData data, Class umlClass, String bomFullPathUri) :
	let model = umlClass.getModel() :
	let schemaType = createIncrementalDocumentRoot(data, model, bomFullPathUri):
	let superclasses = {} :
	let primitives = {} :
	let enums = {} :
	let generalizations = {} :
	let associations = {} :
	
	parseSuperClass(umlClass, superclasses, primitives, enums) ->	
			
	schemaType.schema.simpleType.addAll(primitives.collect(e|createSimpleType(data, e, schemaType.schema)).select(e|e != null)) ->
	schemaType.schema.simpleType.addAll(enums.collect(e|createSimpleType(data, e, schemaType.schema)).select(e|e != null)) ->
	schemaType.schema.complexType.addAll(superclasses.select(e| isComplexType(e)).collect(e|createComplexType(data, e, schemaType.schema)).select(e|e != null)) ->
	schemaType.schema.group2.addAll(superclasses.select(e| isGroup(e)).collect(e|createGroup(e, schemaType.schema)).select(e|e != null)) ->
	schemaType.schema.attributeGroup.addAll(superclasses.select(e| isAttributeGroup(e)).collect(e|createAttributeGroup(e, schemaType.schema)).select(e|e != null)) ->
	
	superclasses.select(e|e.generalization != null).collect(e|generalizations.addAll(e.generalization)) ->
	primitives.select(e|e.generalization != null).collect(e|generalizations.addAll(e.generalization)) ->
	enums.select(e|e.generalization != null).collect(e|generalizations.addAll(e.generalization)) ->
	
	superclasses.select(e|e.getAssociations() != null).collect(e|associations.addAll(e.getAssociations())) ->
	primitives.select(e|e.getAssociations() != null).collect(e|associations.addAll(e.getAssociations())) ->
	enums.select(e|e.getAssociations() != null).collect(e|associations.addAll(e.getAssociations())) ->
	
	generalizations.select(e|e.general != null && e.general.name != null && isDefaultPrimitiveType(e.general.name, _getNearestPackageName(e.general))).collect(e|parseGeneralisationDefaultPrimitives(data, {schemaType.schema}, e)) ->
	generalizations.select(e|e.general != null && e.general.name != null && !isDefaultPrimitiveType(e.general.name, _getNearestPackageName(e.general))).collect(e|parseIncrementalGeneralisation(data, schemaType.schema, e)) ->
	
	parseAssociations(data, schemaType.schema, associations) ->
	
	superclasses.collect(e | parseClassProperties(data, schemaType.schema, e)) ->
	primitives.eAllContents.typeSelect(Property).select(e|e.association == null && isSimpleContentExtension(e) == false && isSimpleContentRestriction(e) == false && Class.isInstance(e.eContainer) == true).collect(e|parseIncrementalProperty(data, schemaType.schema, e, {e.eContainer.getModel()})) ->
	enums.eAllContents.typeSelect(Property).select(e|e.association == null && isSimpleContentExtension(e) == false && isSimpleContentRestriction(e) == false && Class.isInstance(e.eContainer) == true).collect(e|parseIncrementalProperty(data, schemaType.schema, e, {e.eContainer.getModel()})) ->
	
	schemaType;
	
parseAssociations(ExportTransformationData data, SchemaType schemaType, Collection[Association] associations) :
	associations.typeSelect(Association).collect(e | parseAssociation(data, schemaType, e));
	
parseAssociation(ExportTransformationData data, SchemaType schemaType, Association association) :
	let associations = association.getAssociations() :
	association.ownedEnd.size == 0 ? parseIncrementalBiDirectionalComposition(data, schemaType, association) : null ->
	association.ownedEnd.size > 0 ? parseIncrementalComposition(data, schemaType, association) : null ->
	associations != null && associations.size > 0 ? parseAssociations(data, schemaType, associations) : null;
	
parseClassProperties(ExportTransformationData data, xmlSchema::SchemaType schemaType, Class tmpCls) :
	tmpCls.ownedAttribute.select(e|e.association == null && isSimpleContentExtension(e) == false && isSimpleContentRestriction(e) == false).collect(e|parseIncrementalProperty(data, schemaType, e, {tmpCls.getModel()}));	
	
	
// create a DocumentRoot object and declare depending namespaces.
// EMF defines the XMLSchema namespace automatically, but this way we avoid using a prefix for it. 
cached xmlSchema::XmlSchemaDocumentRoot createIncrementalDocumentRoot(ExportTransformationData data, Package pkg, String bomFullPathUri):
	let docRoot = new xmlSchema::XmlSchemaDocumentRoot :
	let tempSchemaType = createSchema(data, pkg) :			
	docRoot.setSchema(tempSchemaType) ->
	docRoot.xMLNSPrefixMap.put("",getNamespace(pkg,true)) ->
	docRoot.xMLNSPrefixMap.put(getPrefix(data, pkg),getNamespace(pkg,true)) ->	
	docRoot.xMLNSPrefixMap.put("xsd","http://www.w3.org/2001/XMLSchema") ->
	
	docRoot.schema.setAnnotation({createAnnotationType("BOMORIGIN::"+bomFullPathUri)}) ->
	docRoot;
	
cached parseSuperClass(Class umlClass, List superclasses, List primitiveList, List enumList) :
      superclasses.contains(umlClass) ? null : (
            superclasses.add(umlClass) ->
            parseClassContents(umlClass, superclasses, primitiveList, enumList) ->            
            umlClass.superClass.collect(e|parseSuperClass(e,superclasses, primitiveList, enumList)) ->              
            umlClass.getAssociations().memberEnd.type.typeSelect(Class).collect(e | parseSuperClass(e,superclasses, primitiveList, enumList))         
      );

	
cached parseSuperEnumeration(Enumeration enumeration, List primitiveList, List enumList) :	
	enumList.contains(enumeration) ? null : (		
		enumList.add(enumeration) ->		
		PrimitiveType.isInstance(enumeration.generalization.first().general) ? (		
			parseSuperPrimitive((PrimitiveType)enumeration.generalization.first().general,primitiveList)			
		) : (
			Enumeration.isInstance(enumeration.generalization.first().general) ? (
				parseSuperEnumeration((Enumeration)enumeration.generalization.first().general,primitiveList, enumList)
			) : null
		)
	);
	
cached parseSuperPrimitive(PrimitiveType umlPrimitive, List primitiveList) :	
	let isDefaultPrimitiveType = isDefaultPrimitiveType(umlPrimitive.name, _getNearestPackageName(umlPrimitive)) :	
	primitiveList.contains(umlPrimitive) || isDefaultPrimitiveType ? null : (		
		primitiveList.add(umlPrimitive) ->
		PrimitiveType.isInstance(umlPrimitive.generalization.first().general) ? (		
			parseSuperPrimitive((PrimitiveType)umlPrimitive.generalization.first().general,primitiveList)			
		) : null
	);

cached parseClassContents(Class umlClass, List superclasses, List primitiveList, List enumList) :
      umlClass.ownedAttribute.collect(e|parseEachProperty(e, superclasses, primitiveList, enumList)) ->
      umlClass.ownedOperation.type.typeSelect(PrimitiveType).collect(e|parseSuperPrimitive(e,primitiveList)) ->
      umlClass.ownedOperation.type.typeSelect(Enumeration).collect(e|parseSuperEnumeration(e,primitiveList,enumList)) ->
      umlClass.ownedOperation.type.typeSelect(Class).collect(e|parseSuperClass(e,superclasses,primitiveList,enumList)) ->
      umlClass.ownedOperation.ownedParameter.type.typeSelect(PrimitiveType).collect(e|parseSuperPrimitive(e,primitiveList)) ->
      umlClass.ownedOperation.ownedParameter.type.typeSelect(Enumeration).collect(e|parseSuperEnumeration(e,primitiveList,enumList)) ->
      umlClass.ownedOperation.ownedParameter.type.typeSelect(Class).collect(e|parseSuperClass(e,superclasses,primitiveList,enumList));

cached parseEachProperty(Property property, List superclasses, List primitiveList, List enumList) :
	PrimitiveType.isInstance(property.type) == true ? parseSuperPrimitive(property.type,primitiveList) : null ->
	Enumeration.isInstance(property.type) == true ? parseSuperEnumeration(property.type,primitiveList,enumList) : null ->
	Class.isInstance(property.type) == true ? parseSuperClass(property.type,superclasses,primitiveList,enumList) : null;