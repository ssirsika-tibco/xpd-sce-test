// author glewis

import xmlSchema;
import type;
import uml;
import com::tibco::xpd::bom::xsdtransform::exports::template;

extension org::openarchitectureware::xsd::lib::qname;
extension org::openarchitectureware::xsd::lib::map;
extension com::tibco::xpd::bom::xsdtransform::exports::template::Extensions reexport;
extension com::tibco::xpd::bom::xsdtransform::exports::template::Bom2Xsd reexport;

// Gather primitive types that have base xsd type and at least one root element assigned to them	
cached parseTopLevelElementsAndAttributes(ExportTransformationData data, Collection[xmlSchema::SchemaType] schemaTypeList, Collection[Package] filteredPackages, Collection[Package] allPackages, List[String] topLevelElementOrAttributeNames) :
	// gather up all of these types mainly for user defined boms as we create a top level element of each type to the schema
	let primList = allPackages.packagedElement.typeSelect(PrimitiveType).select(e | PrimitiveType.isInstance(e) == true) :
	let enumList = allPackages.packagedElement.typeSelect(Enumeration).select(e | Enumeration.isInstance(e) == true) :
	let clsList = allPackages.packagedElement.typeSelect(Class).select(e | Class.isInstance(e) == true) :
	
	// for every package we encounter we parse both top level attribute and elements
	allPackages.collect(e | (
			let packageTopLevelAttributes = getTopLevelAttributes(e) :
			let packageTopLevelElements = getTopLevelElements(e) :			
			packageTopLevelAttributes.collect(attr | (
				// parse the top level attributes
				parseTopLevelAttributes(data, schemaTypeList, filteredPackages, allPackages, topLevelElementOrAttributeNames, attr, e)
				)
			) ->
			packageTopLevelElements.collect(elem | (
				// parse the top level elements
				parseTopLevelElements(data, schemaTypeList, filteredPackages, allPackages, topLevelElementOrAttributeNames, elem, e)
				)
			)			
		)
	) ->
	
	// parse user defined top level elements
	primList.select(e | isUserDefinedTopLevelElement(e)).collect(e | parseUserDefinedTopLevelElementsForTypes(data, schemaTypeList, e, topLevelElementOrAttributeNames)) ->
	enumList.select(e | isUserDefinedTopLevelElement(e)).collect(e | parseUserDefinedTopLevelElementsForTypes(data, schemaTypeList, e, topLevelElementOrAttributeNames)) ->
	clsList.select(e | isUserDefinedTopLevelElement(e)).collect(e | parseUserDefinedTopLevelElementsForClasses(data, schemaTypeList, e, topLevelElementOrAttributeNames));
	
cached parseTopLevelAttributes(ExportTransformationData data, Collection[xmlSchema::SchemaType] schemaTypeList, Collection[Package] filteredPackages, Collection[Package] allPackages, List[String] topLevelElementOrAttributeNames, Object topLevelAttribute, Package currentPackage) :	
	// gather the stereotype values for this top level attribute
	let isAnonymous = getAttributeIsAnonymous(topLevelAttribute) :
	let isBaseXSDType = getAttributeIsBaseXSDType(topLevelAttribute) :
	let name = getAttributeName(topLevelAttribute) :				
	let id = getAttributeID(topLevelAttribute) :
	let fixed = getAttributeFixed(topLevelAttribute) :				
	let defaultVal = getAttributeDefault(topLevelAttribute) :
	let classifier = getAttributeType(topLevelAttribute) :
	
	// get the schema that the attribute type belongs to
	let typeSchema = schemaTypeList.typeSelect(xmlSchema::SchemaType).select(e|e.targetNamespace == getNamespace(classifier.package,true)).first() :
	// get the schema that the actual attribute belongs to
	let containerSchema = schemaTypeList.typeSelect(xmlSchema::SchemaType).select(e|e.targetNamespace == getNamespace(currentPackage,true)).first() :
	
	// ensure that this schema has not already been parsed yet (preventative step to avoid duplicates)
	data.parsedOAWSchemas.contains(containerSchema.eContainer) == true ? null  : (	
		let topLevelAttribute = new TopLevelAttribute :	
		
		// if this attribute does not have an anonymous simple type then we go into the first block else we parse the latter one						
		isAnonymous == false ? (
			let appliedPrimitiveStereotype = classifier.getAppliedStereotypes().select(e|e.name == "XsdBasedPrimitiveType").first() :
			let type = getStereotypeValue(classifier, appliedPrimitiveStereotype, "xsdRestrictionBase") :
			let simpleType = new LocalSimpleType :
			let restrictionType = new RestrictionType1 :
			
			// ensure that this attributes container can indeed be found in cache before moving on
			containerSchema != null ? (
				name == null ? null : topLevelAttribute.setName(name) ->
				id == null ? null : topLevelAttribute.setId(id) ->
				fixed == null ? null : topLevelAttribute.setFixed(fixed) ->				
				defaultVal == null ? null : topLevelAttribute.setDefault(defaultVal) ->		
			
				// if we are creating an attribute that is of type standard xsd type then we go into first block
				isBaseXSDType == true ? (
					type != null && type.trim().length > 0 ? (	
						let newType = getTypeName(data, classifier, ReplaceFirst(type,":","xsd:")) :			
						let qname = getQName(containerSchema, newType, getPrefix(data, classifier.package)) :
						restrictionType.setBase(qname) ->
						appliedPrimitiveStereotype == null ? null : setRestrictions(classifier, appliedPrimitiveStereotype, restrictionType)
					) : null 
				) : ( // parses the case where this attribute is of type another simple type in one of our created schemas
					classifier != null ? (
						let xsdSimpleTypeName = getStereotypeValue(classifier, appliedPrimitiveStereotype, "xsdSimpleTypeName") :
						restrictionType.setBase(createQName(typeSchema.targetNamespace,xsdSimpleTypeName))
					) : null
				) ->
				
				// set the restriction on the simple type
				simpleType.setRestriction(restrictionType) ->
				topLevelAttribute.setSimpleType(simpleType) ->
				
				// if attribute is of any of the any types then it will produce an invalid schema to put restriction on so this must be a direct type
				isObjectAnyType(classifier, "xsdAnySimpleType") ? (				
					topLevelAttribute.setType(createQName("xsd:anySimpleType")) ->			
					topLevelAttribute.setSimpleType(null)
				) : (
					isObjectAnyType(classifier, "xsdAnyType") ? (				
						topLevelAttribute.setType(null) ->			
						topLevelAttribute.setSimpleType(null)
					) : (
						restrictionType.eContents.flatten().size == 0 ? (
							topLevelAttribute.setType(restrictionType.base) ->			
							topLevelAttribute.setSimpleType(null)
						) : null
					)
				) ->					
				
				// ensure this attribute does not already exist in the schema
				containerSchema.attribute.select(e|e.name == topLevelAttribute.name).first() == null ? (
					//topLevelElementOrAttributeNames.add(topLevelAttribute.name+"_attr_"+containerSchema.targetNamespace) ->
					
					// if the attribute resides in a difference schema than what its type is pointing to then we have to add an import for this schema
					containerSchema != typeSchema ? addImportType(data, typeSchema, containerSchema, classifier.package, getPrefix(data, classifier.package), typeSchema.targetNamespace) : null ->
					
					containerSchema.attribute.add(topLevelAttribute) 
				) : null			
			) : null
		) : (
			// get stereotype values so we can add any small details in when creating the new attribute
			let appliedPrimitiveStereotype = classifier.getAppliedStereotypes().select(e|e.name == "XsdBasedPrimitiveType").first() :
			let appliedUnionTypeStereotype = classifier.getAppliedStereotypes().select(e|e.name == "XsdBasedUnion").first() :		
			let type = getStereotypeValue(classifier, appliedPrimitiveStereotype, "xsdRestrictionBase") :
			let simpleType = new LocalSimpleType :
			let restrictionType = new RestrictionType1 :
			let unionType = new UnionType :
			let stereoType = getStereotypedProperty(classifier) :		
			let xsdMemberTypes = getStereotypeValue(classifier, appliedUnionTypeStereotype, "xsdMemberTypes") :
			let xsdIsAnonUnionSimpleType = getStereotypeValue(classifier, appliedPrimitiveStereotype, "xsdIsAnonUnionSimpleType") :	
			
			// ensure that this attributes container can indeed be found in cache before moving on
			containerSchema != null ? (
				name == null ? null : (
					xsdIsAnonUnionSimpleType ? addFeatureMapEntry(topLevelAttribute.anyAttribute, name, "name") : null ->
					// XPD-2569: might want to delete above line and uncomment below line if you want to add ecore:name unconditionally
					// havent identified any case while working on this, so leaving it commented at the time of check-in
					//addFeatureMapEntry(topLevelAttribute.anyAttribute, name, "name") ->
					topLevelAttribute.setName(name) 
				) ->
				id == null ? null : topLevelAttribute.setId(id) ->
				fixed == null ? null : topLevelAttribute.setFixed(fixed) ->				
				defaultVal == null ? null : topLevelAttribute.setDefault(defaultVal) ->							
				
				// if we are creating an attribute that is of type standard xsd type then we go into first block
				isBaseXSDType == true ? (
					type != null && type.trim().length > 0 ? (		
						let newType = getTypeName(data, classifier, ReplaceFirst(type,":","xsd:")) :						
						let qname = getQName(containerSchema, newType, getPrefix(data, classifier.package)) :
						appliedUnionTypeStereotype == null ? (							
							restrictionType.setBase(qname)										
						) : null
					) : null 
				) : (
					// parses the case where this attribute is of type another simple type in one of our created schemas
					type != null && type.trim().length > 0 ? (
						let xsdSimpleTypeName = getStereotypeValue(classifier, appliedPrimitiveStereotype, "xsdSimpleTypeName") :
						appliedUnionTypeStereotype == null ? (
							restrictionType.setBase(createQName(typeSchema.targetNamespace,ReplaceFirst(xsdSimpleTypeName,":","")))								
						) : null ->									
						typeSchema.simpleType.select(e | e.name == ReplaceFirst(xsdSimpleTypeName,":","")).first() != null ? null : (
							let topLevelSimpleType = createSimpleType(data, classifier, typeSchema) :									
							typeSchema.simpleType.add(topLevelSimpleType)
						) 
					) : null
				) ->
				
				stereoType == null ? null : setRestrictions(classifier, stereoType, restrictionType) ->	
				
				// if attribute has a simple type that needs enumerations then we parse them
				Enumeration.isInstance(classifier) ? (
					classifier.ownedLiteral.size > 0 ? (
						classifier.ownedLiteral.collect(e|toNoFixedFacet(data, restrictionType.enumeration, e.name, e, classifier)) ->
						classifier.ownedLiteral.collect(e|setOtherStereotypedValues(e, restrictionType.enumeration, e.name))
					) : null
				) : null ->
				
				// if we have no unions then we can simple set the restriction on simpletype
				appliedUnionTypeStereotype == null ? (
					simpleType.setRestriction(restrictionType)									
				) : ( // else set the unions on the simple type
					setMemberTypesList(unionType, createMemberTypeQNameList(data, xsdMemberTypes, classifier.getModel())) ->
					simpleType.setUnion(unionType)			
				) ->							
				topLevelAttribute.setSimpleType(simpleType) ->		
				// XPD-2569: add ecore:name for anonymous simple type in an attribute
				addFeatureMapEntry(simpleType.anyAttribute, classifier.name, "name") ->
				
				// again if any of these types are of anyType then we need to remove the restriction and set the type so we can end up with valid schema
				isObjectAnyType(classifier, "xsdAnySimpleType") ? (	
					topLevelAttribute.setType(createQName("xsd:anySimpleType")) ->			
					topLevelAttribute.setSimpleType(null)
				) : (
					isObjectAnyType(classifier, "xsdAnyType") ? (				
						topLevelAttribute.setType(null) ->			
						topLevelAttribute.setSimpleType(null)
					) : (
						restrictionType.eContents.flatten().size == 0 ? (
							appliedUnionTypeStereotype == null ? (
								topLevelAttribute.setType(restrictionType.base) ->			
								topLevelAttribute.setSimpleType(null)
							) : null
						) : null
					)
				) ->			
						
				// check to see that attribute is not already in the schema
				containerSchema.attribute.select(e|e.name == topLevelAttribute.name).first() == null ? (
					//topLevelElementOrAttributeNames.add(topLevelAttribute.name+"_attr_"+containerSchema.targetNamespace) ->
					
					// add import for the schema if both attribute and its type are in different ones
					containerSchema != typeSchema ? addImportType(data, typeSchema, containerSchema, classifier.package, getPrefix(data, classifier.package), typeSchema.targetNamespace) : null ->
					
					containerSchema.attribute.add(topLevelAttribute) 
				) : null
			) : null
		)
	);
	
cached parseTopLevelElements(ExportTransformationData data, Collection[xmlSchema::SchemaType] schemaTypeList, Collection[Package] filteredPackages, Collection[Package] allPackages, List[String] topLevelElementOrAttributeNames, Object topLevelElement, Package currentPackage) :	
	// gather the stereotype values for this top level element
	let isAnonymous = getElementIsAnonymous(topLevelElement) :
	let isBaseXSDType = getElementIsBaseXSDType(topLevelElement) :
	let name = getElementName(topLevelElement) :				
	let id = getElementID(topLevelElement) :
	let fixed = getElementFixed(topLevelElement) :
	let final = getElementFinal(topLevelElement) :
	let block = getElementBlock(topLevelElement) :
	let nillable = getElementNillable(topLevelElement) :
	let abstract = getElementAbstract(topLevelElement) :
	let substitutionGroupNamespace = getElementSubstitutionGroupNamespace(topLevelElement) :
	let substitutionGroupLocalPart = getElementSubstitutionGroupLocalPart(topLevelElement) :
	let defaultVal = getElementDefault(topLevelElement) :
	let classifier = getElementType(topLevelElement) :	
	
	// get the schema that the element type belongs to
	let typeSchema = schemaTypeList.typeSelect(xmlSchema::SchemaType).select(e|e.targetNamespace == getNamespace(classifier.package,true)).first() :
	// get the schema that the element actually belongs to
	let containerSchema = schemaTypeList.typeSelect(xmlSchema::SchemaType).select(e|e.targetNamespace == getNamespace(currentPackage,true)).first() :
	
	// ensure that this schema has not already been parsed yet (preventative step to avoid duplicates)
	data.parsedOAWSchemas.contains(containerSchema.eContainer) == true ? null  : (	
		let topLevelElement = new TopLevelElement :
		
		(Enumeration.isInstance(classifier) == true || PrimitiveType.isInstance(classifier) == true) ? (
			// if this element does not have an anonymous simple type then we go into the first block else we parse the latter one	
			isAnonymous == false ? (
				let appliedPrimitiveStereotype = classifier.getAppliedStereotypes().select(e|e.name == "XsdBasedPrimitiveType").first() :
				let type = getStereotypeValue(classifier, appliedPrimitiveStereotype, "xsdRestrictionBase") :		
				let simpleType = new LocalSimpleType :
				let restrictionType = new RestrictionType1 :					
				
				// ensure that this elements container can indeed be found in cache before moving on
				containerSchema != null ? (	
					name == null ? null : topLevelElement.setName(name) ->
					id == null ? null : topLevelElement.setId(id) ->
					fixed == null ? null : topLevelElement.setFixed(fixed) ->												
					nillable == null ? null : topLevelElement.setNillable(nillable) ->				
					abstract != null ? topLevelElement.setAbstract(abstract) : null ->
					substitutionGroupNamespace != null && substitutionGroupLocalPart != null ? topLevelElement.setSubstitutionGroup(createQName(substitutionGroupNamespace,substitutionGroupLocalPart,data.getPrefixForNamespace(substitutionGroupNamespace))) : null ->
					defaultVal == null ? null : topLevelElement.setDefault(defaultVal) ->
					setBlock(topLevelElement, block) ->
					setFinal(topLevelElement, final) ->							
					// if we are creating an element that is of type standard xsd type then we go into first block
					isBaseXSDType == true ? (
						type != null && type.trim().length > 0 ? (		
							let newType = getTypeName(data, classifier, ReplaceFirst(type,":","xsd:")) :			
							let qname = getQName(containerSchema, newType, getPrefix(data, classifier.package)) :
							restrictionType.setBase(qname) ->
							appliedPrimitiveStereotype == null ? null : setRestrictions(classifier, appliedPrimitiveStereotype, restrictionType)
						) : null 
					) : ( // parses the case where this element is of type another simple type in one of our created schemas
						classifier != null ? (
							let xsdSimpleTypeName = getStereotypeValue(classifier, appliedPrimitiveStereotype, "xsdSimpleTypeName") :
							restrictionType.setBase(createQName(typeSchema.targetNamespace,xsdSimpleTypeName))									
						) : null
					) ->
					simpleType.setRestriction(restrictionType) ->
					topLevelElement.setSimpleType(simpleType) ->	
					
					// If any of these types are of anyType then we need to remove the restriction and set the type so we can end up with valid schema
					isObjectAnyType(classifier, "xsdAnySimpleType") ? (		
						topLevelElement.setType(createQName("xsd:anySimpleType")) ->			
						topLevelElement.setSimpleType(null)
					) : (
						isObjectAnyType(classifier, "xsdAnyType") ? (
							substitutionGroupLocalPart != null ? topLevelElement.setType(null) : topLevelElement.setType(createQName("xsd:anyType")) ->						
							topLevelElement.setSimpleType(null)
						) : (
							restrictionType.eContents.flatten().size == 0 ? (
								topLevelElement.setType(restrictionType.base) ->			
								topLevelElement.setSimpleType(null)
							) : null
						)
					) ->
					
					// this may not be needed now - previously we thought that all elements referenced by substitutuion groups needed to 
					// have a direct type rather than restriction base but not sure if this is so...
					// XPD-3082 - Comment out
					//data.allTopLevelElementsReferencedBySubstitutionGroups.contains(topLevelElement.name) ? (topLevelElement.setType(restrictionType.base) -> topLevelElement.setSimpleType(null)) : null  ->
							
					// check to see that element is not already in the schema		
					containerSchema.element.select(e|e.name == topLevelElement.name).first() == null ? (
						//topLevelElementOrAttributeNames.add(topLevelElement.name+"_elem_"+containerSchema.targetNamespace) ->
						
						// add import for the schema if both element and its type are in different ones
						containerSchema != typeSchema ? addImportType(data, typeSchema, containerSchema, classifier.package, getPrefix(data, classifier.package), typeSchema.targetNamespace) : null ->
						
						containerSchema.element.add(topLevelElement) 
					) : null
				) : null
			) : (
				let appliedPrimitiveStereotype = classifier.getAppliedStereotypes().select(e|e.name == "XsdBasedPrimitiveType").first() :
				let appliedUnionTypeStereotype = classifier.getAppliedStereotypes().select(e|e.name == "XsdBasedUnion").first() :	
				let type = getStereotypeValue(classifier, appliedPrimitiveStereotype, "xsdRestrictionBase") :		
				let simpleType = new LocalSimpleType :
				let restrictionType = new RestrictionType1 :
				let unionType = new UnionType :
				let stereoType = getStereotypedProperty(classifier) :
				let xsdMemberTypes = getStereotypeValue(classifier, appliedUnionTypeStereotype, "xsdMemberTypes") :
				let xsdIsAnonUnionSimpleType = getStereotypeValue(classifier, appliedPrimitiveStereotype, "xsdIsAnonUnionSimpleType") :			
				
				// ensure that this elements container can indeed be found in cache before moving on
				containerSchema != null ? (						
					name == null ? null : (
						xsdIsAnonUnionSimpleType ? addFeatureMapEntry(topLevelElement.anyAttribute, name, "name") : null ->
						// XPD-2569: might want to delete above line and uncomment below line if you want to add ecore:name unconditionally
						// havent identified any case while working on this, so leaving it commented at the time of check-in
						//addFeatureMapEntry(topLevelElement.anyAttribute, name, "name")->
						topLevelElement.setName(name) 
					) ->
					id == null ? null : topLevelElement.setId(id) ->
					fixed == null ? null : topLevelElement.setFixed(fixed) ->												
					nillable == null ? null : topLevelElement.setNillable(nillable) ->				
					abstract != null ? topLevelElement.setAbstract(abstract) : null ->
					substitutionGroupNamespace != null && substitutionGroupLocalPart != null ? topLevelElement.setSubstitutionGroup(createQName(substitutionGroupNamespace,substitutionGroupLocalPart,data.getPrefixForNamespace(substitutionGroupNamespace))) : null ->
					defaultVal == null ? null : topLevelElement.setDefault(defaultVal) ->	
					setBlock(topLevelElement, block) ->
					setFinal(topLevelElement, final) ->
					
					// if we are creating an element that is of type standard xsd type then we go into first block
					isBaseXSDType == true ? (
						type != null && type.trim().length > 0 ? (					
							let newType = getTypeName(data, classifier, ReplaceFirst(type,":","xsd:")) :
							let qname = getQName(containerSchema, newType, getPrefix(data, classifier.package)) :								
							appliedUnionTypeStereotype == null ? (
								restrictionType.setBase(qname)										
							) : null
						) : null 
					) : ( // parses the case where this element is of type another simple type in one of our created schemas
						type != null && type.trim().length > 0 ? (
							let xsdSimpleTypeName = getStereotypeValue(classifier, appliedPrimitiveStereotype, "xsdSimpleTypeName") :									
							appliedUnionTypeStereotype == null ? (
								restrictionType.setBase(createQName(typeSchema.targetNamespace,ReplaceFirst(xsdSimpleTypeName,":","")))									
							) : null ->
							typeSchema.simpleType.select(e | e.name == ReplaceFirst(xsdSimpleTypeName,":","")).first() != null ? null : (
								let topLevelSimpleType = createSimpleType(data, classifier, typeSchema) :									
								typeSchema.simpleType.add(topLevelSimpleType)
							) 
						) : null
					) ->
					
					stereoType == null ? null : setRestrictions(classifier, stereoType, restrictionType) ->	
					
					// if element has a simple type that needs enumerations then we parse them
					Enumeration.isInstance(classifier) ? (
						classifier.ownedLiteral.size > 0 ? (
							classifier.ownedLiteral.collect(e|toNoFixedFacet(data, restrictionType.enumeration, e.name, e, classifier)) ->
							classifier.ownedLiteral.collect(e|setOtherStereotypedValues(e, restrictionType.enumeration, e.name))
						) : null
					) : null ->
					
					// if we have no unions then we can simple set the restriction on simpletype
					appliedUnionTypeStereotype == null ? (
						simpleType.setRestriction(restrictionType)									
					) : (			
						setMemberTypesList(unionType, createMemberTypeQNameList(data, xsdMemberTypes, classifier.getModel())) ->
						simpleType.setUnion(unionType)			
					) ->
												
					topLevelElement.setSimpleType(simpleType) ->	
					// XPD-2569: add ecore:name for anonymous simple type in an element
					addFeatureMapEntry(simpleType.anyAttribute, classifier.name, "name") ->
					
					// If any of these types are of anyType then we need to remove the restriction and set the type so we can end up with valid schema
					isObjectAnyType(classifier, "xsdAnySimpleType") ? (		
						topLevelElement.setType(createQName("xsd:anySimpleType")) ->			
						topLevelElement.setSimpleType(null)
					) : (
						isObjectAnyType(classifier, "xsdAnyType") ? (				
							substitutionGroupLocalPart != null ? topLevelElement.setType(null) : topLevelElement.setType(createQName("xsd:anyType")) ->			
							topLevelElement.setSimpleType(null)
						) : (
							restrictionType.eContents.flatten().size == 0 ? (
								appliedUnionTypeStereotype == null ? (
									topLevelElement.setType(restrictionType.base) ->			
									topLevelElement.setSimpleType(null)
								) : null
							) : null
						)
					) ->	
					
					// this may not be needed now - previously we thought that all elements referenced by substitutuion groups needed to 
					// have a direct type rather than restriction base but not sure if this is so...
					// XPD-3082 - Comment out
					//data.allTopLevelElementsReferencedBySubstitutionGroups.contains(topLevelElement.name) ? (topLevelElement.setType(restrictionType.base) -> topLevelElement.setSimpleType(null)) : null  ->
								
					// check to see that element is not already in the schema					
					containerSchema.element.select(e|e.name == topLevelElement.name).first() == null ? (
						//topLevelElementOrAttributeNames.add(topLevelElement.name+"_elem_"+containerSchema.targetNamespace) ->
						
						// add import for the schema if both element and its type are in different ones			
						containerSchema != typeSchema ? addImportType(data, typeSchema, containerSchema, classifier.package, getPrefix(data, classifier.package), typeSchema.targetNamespace) : null ->
		
						containerSchema.element.add(topLevelElement) 
					): null			
				) : null
			)		
		) : (
			// if this element does not have an anonymous simple type then we go into the first block else we parse the latter one	
			isAnonymous == false ? (
				let appliedClassStereotype = classifier.getAppliedStereotypes().select(e|e.name == "XsdBasedClass").first() :
				let type = getStereotypeValue(classifier, appliedClassStereotype, "xsdName") :						
				// ensure that this elements container can indeed be found in cache before moving on
				containerSchema != null ? (					
					name == null ? null : topLevelElement.setName(name) ->
					id == null ? null : topLevelElement.setId(id) ->
					fixed == null ? null : topLevelElement.setFixed(fixed) ->												
					nillable == null ? null : topLevelElement.setNillable(nillable) ->				
					abstract != null ? topLevelElement.setAbstract(abstract) : null ->
					substitutionGroupNamespace != null && substitutionGroupLocalPart != null ? topLevelElement.setSubstitutionGroup(createQName(substitutionGroupNamespace,substitutionGroupLocalPart,data.getPrefixForNamespace(substitutionGroupNamespace))) : null ->
					defaultVal == null ? null : topLevelElement.setDefault(defaultVal) ->
					setBlock(topLevelElement, block) ->
					setFinal(topLevelElement, final) ->
					
					type != null && type.trim().length > 0 ? (
						let qname = createQName(typeSchema.targetNamespace,type) :
						topLevelElement.setType(qname)
					) : null ->				
					containerSchema.element.select(e|e.name == topLevelElement.name).first() == null ? (
						containerSchema == typeSchema ? null : addImportType(data, typeSchema, containerSchema, classifier.package, getPrefix(data, classifier.package), typeSchema.targetNamespace) -> 
						containerSchema.element.add(topLevelElement)
						//topLevelElementOrAttributeNames.add(topLevelElement.name+"_elem_"+containerSchema.targetNamespace)
					) : null
				) : null					
			) : (				
				let appliedClassStereotype = classifier.getAppliedStereotypes().select(e|e.name == "XsdBasedClass").first() :
				let xrefId = getXRefID(classifier) :
				let type = getStereotypeValue(classifier, appliedClassStereotype, "xsdName") :
				let topLevelComplexType = (
					// XPD-5171: search for the existing complex type with its name. no need to call getOriginalName()
					let existingComplex = data.getComplexForName(containerSchema.targetNamespace + ":" + classifier.name) :
					existingComplex != null && TopLevelComplexType.isInstance(existingComplex) ? existingComplex : createComplexType(data, classifier, containerSchema)
				) :
				// XPD-4907: tmpTopElement was getting assigned the anonymous complex type of the top level element 
				// rather than the top level element as the name suggests
				let tmpTopElement = topLevelElement : //schemaTypeList.element.select(e|e.complexType != null && e.name == classifier.name).first() :
				let ownedAttributes = classifier.ownedAttribute.select(e | isSimpleContentExtension(e) == false && isSimpleContentRestriction(e) == false) :
				let isSimpleContentRestriction = classifier.ownedAttribute.select(e | isSimpleContentRestriction(e) == true).size > 0 :
				let isSimpleContentExtension = classifier.ownedAttribute.select(e | isSimpleContentExtension(e) == true).size > 0 :
				let clsType = classifier.general.first() :			
				let localComplexType = new LocalComplexType:
				let complexContent = new ComplexContentType :
				let extensionType = new ExtensionType :
				let complexRestrictionType = new ComplexRestrictionType :			
				// ensure that this elements container can indeed be found in cache before moving on
				containerSchema != null ? (				
					name == null ? null : topLevelElement.setName(name) ->
					id == null ? null : topLevelElement.setId(id) ->
					fixed == null ? null : topLevelElement.setFixed(fixed) ->										
					nillable == null ? null : topLevelElement.setNillable(nillable) ->				
					abstract != null ? topLevelElement.setAbstract(abstract) : null ->
					substitutionGroupNamespace != null && substitutionGroupLocalPart != null ? topLevelElement.setSubstitutionGroup(createQName(substitutionGroupNamespace,substitutionGroupLocalPart,data.getPrefixForNamespace(substitutionGroupNamespace))) : null ->
					defaultVal == null ? null : topLevelElement.setDefault(defaultVal) ->
					setBlock(topLevelElement, block) ->
					setFinal(topLevelElement, final) ->
					clsType == null	? (					
						// parse top level elements with anonymouse complex types
						containerSchema.complexType.add(topLevelComplexType) ->	
						
						// set simple content extension or restrictions if indeed it needs to have one
						isSimpleContentRestriction == true ? (
							topLevelComplexType.setSimpleContent(createSimpleContent(data, classifier, schemaTypeList, false))
						) : (
							isSimpleContentExtension == true ? (
								topLevelComplexType.setSimpleContent(createSimpleContent(data, classifier, schemaTypeList, true))
							) : null//createSequence(topLevelComplexType) 
						) ->
						
						// add all the attributes to this new anonymous complex type within the top level element
						ownedAttributes.collect(e | (e.association == null ? 
							(
								traceMe("calling add attribute to complex type")->
								addAttributeToComplexType(data, schemaTypeList, e, topLevelComplexType, allPackages)
							) : 
							(
								traceMe("e.association is not null so calling parse association for e = " + e + " e.association = " + e.association)->
								parseAssociations(data, schemaTypeList, {e.association}, allPackages) ))
							)->
						
						// copy over all the top level complex type details to the elements anonymous complex type
						topLevelComplexType.choice != null ? topLevelComplexType.setSequence(null) : null ->
						topLevelComplexType.all != null ? topLevelComplexType.setSequence(null) : null ->
													
						localComplexType.setAll(topLevelComplexType.all) ->
						topLevelComplexType.annotation != null ? localComplexType.setAnnotation(topLevelComplexType.annotation) : null ->
						topLevelComplexType.attribute != null ? localComplexType.setAttribute(topLevelComplexType.attribute) : null ->
						topLevelComplexType.anyAttribute1 != null ? localComplexType.setAnyAttribute1(topLevelComplexType.anyAttribute1) : null ->					
						topLevelComplexType.attributeGroup != null ? localComplexType.setAttributeGroup(topLevelComplexType.attributeGroup) : null ->
						localComplexType.setBlock(topLevelComplexType.block) ->							
						topLevelComplexType.complexContent != null ? localComplexType.setComplexContent(topLevelComplexType.complexContent) : null ->
						localComplexType.setFinal(topLevelComplexType.final) ->
						localComplexType.setGroup(topLevelComplexType.group) ->
						localComplexType.setId(topLevelComplexType.id) ->
						localComplexType.setMixed(topLevelComplexType.mixed) ->
						topLevelComplexType.all != null ? (
							localComplexType.setAll(topLevelComplexType.all) ->
							localComplexType.all.element.setId(null)
						): null ->
						topLevelComplexType.choice != null ? (
							localComplexType.setChoice(topLevelComplexType.choice) ->
							localComplexType.choice.element.setId(null)
						): null ->
						topLevelComplexType.sequence != null ? (
							localComplexType.setSequence(topLevelComplexType.sequence) ->
							localComplexType.sequence.element.setId(null)
						): null ->
						topLevelComplexType.simpleContent != null ? localComplexType.setSimpleContent(topLevelComplexType.simpleContent) : null ->
						topLevelElement.setType(null) ->
						topLevelElement.setComplexType(localComplexType) ->
						// XPD-2569: add ecore:name for anonymous complex type within a top level element
						addFeatureMapEntry(localComplexType.anyAttribute, classifier.name, "name") ->
						containerSchema.complexType.remove(topLevelComplexType) ->							
						
						// XPD-4907: bharti:: i dont know the reason why this is being removed!!
						// commenting this line also worked fine in few cases which I tested.
						// tmpTopElement has empty or newly created topLevelElement, removing such new object doesn't make much sense
						// tried few cases by removing topLevelElement instead of tmpTopElement. 
						// but leaving it as it is to avoid any regressions
						containerSchema.element.remove(tmpTopElement) ->
						
						// if we have not got this top level element already then we go ahead and add it
						containerSchema.element.select(e|e.name == topLevelElement.name).first() == null ? (
							//topLevelElementOrAttributeNames.add(topLevelElement.name+"_elem_"+containerSchema.targetNamespace) ->		
							
							// add import to schema if the element is contained in another schema to its type
							containerSchema == typeSchema ? null : addImportType(data, typeSchema, containerSchema, classifier.package, getPrefix(data, classifier.package), typeSchema.targetNamespace) ->			
							containerSchema.element.add(topLevelElement) ->								
							localComplexType.eAllContents.typeSelect(Element).collect(elem | ( 
							
								// XPD-5935: The problem is if an element name in a TopLevelElement clashes with the anonymous complex type. 
								// The reason for above problem is - elem in the complex type is being checked if it is anonymous.
								// and this check is being done by looking for all anonymous classes in all the packages and the anonymous
								// class name is compared with element name. if the element has type then it is not anonymous.
								// so first check if the element has type before checking if it is anonymous
								elem.type == null ? 
									(
										let tmpElement = elem :
										let elemName = elem.name :
										let tmpAnonCls = allPackages.eAllContents.typeSelect(Class).select(e | isAnonTypeClass(e) == true && e.name == elemName).first() :
										tmpAnonCls != null ? (
												let tmpAppliedClassStereotype = tmpAnonCls.getAppliedStereotypes().select(e|e.name == "XsdBasedClass").first() :
												let complexName = getStereotypeValue(tmpAnonCls, tmpAppliedClassStereotype, "xsdName") :
												let anonTopLevelComplexType = schemaTypeList.eAllContents.typeSelect(TopLevelComplexType).select(e|e.name == complexName ).first() :
												//anonTopLevelComplexType.eAllContents.typeSelect(LocalComplexType).select(e | e.name == null && e.sequence == null && e.choice == null && e.complexContent == null && e.simpleContent == null).collect(e | e.eContainer.setComplexType(null)) ->
												tmpElement.setName(complexName) ->
												fixAnonTypes(data, schemaTypeList, tmpElement, anonTopLevelComplexType)						
											) : null
									) : 
									(
										// XPD-5935: if type for an element exists, then it is not anonymous 
										null
									)
								)	
							)
						) : null
					) : (
						// parse top level elements of direct type constructs
						let clsTypeSchema = schemaTypeList.typeSelect(SchemaType).select(e|e.targetNamespace == getNamespace(clsType.package,true)).first() :
						let clsTypeStereotype = clsType.getAppliedStereotypes().select(e|e.name == "XsdBasedClass").first() :
						let clsTypeName = getStereotypeValue(clsType, clsTypeStereotype, "xsdName") :
						let clsTypeComplexType = clsTypeSchema.complexType.select(e|e.name == clsTypeName).first() :
						let clsStereotype = classifier.getAppliedStereotypes().select(e|e.name == "XsdBasedClass").first() :
						let isXSDRestriction = getStereotypeValue(classifier, clsStereotype, "xsdIsRestriction") :
						
						//clsTypeComplexType.eAllContents.typeSelect(LocalComplexType).select(e | e.name == null && e.sequence == null && e.choice == null && e.complexContent == null && e.simpleContent == null).collect(e | e.eContainer.setComplexType(null)) ->
						extensionType.setBase(createQName(clsTypeSchema.targetNamespace,clsTypeName)) ->
						complexRestrictionType.setBase(createQName(clsTypeSchema.targetNamespace,clsTypeName)) ->
						isXSDRestriction != null && isXSDRestriction == true ? complexContent.setRestriction(complexRestrictionType) : complexContent.setExtension(extensionType) ->
						// XPD-4386: support mixed construct on TLE extending a complex type
						complexContent.setMixed(topLevelComplexType.mixed)->	
						localComplexType.setComplexContent(complexContent) ->	
						topLevelElement.setComplexType(localComplexType) ->
						// XPD-2569: add ecore:name for anonymous complex type (extending other complex type) within a top level element
						addFeatureMapEntry(localComplexType.anyAttribute, classifier.name, "name") ->
						topLevelElement.setType(null) ->
						containerSchema.element.remove(tmpTopElement) ->
						
						// if we have not got this top level element already then we go ahead and add it
						containerSchema.element.select(e|e.name == topLevelElement.name).first() == null ? (															
							//topLevelElementOrAttributeNames.add(topLevelElement.name+"_elem_"+containerSchema.targetNamespace) ->
							
							// add import to schema if the element is contained in another shcema to its type
							containerSchema == typeSchema ? null : addImportType(data, typeSchema, containerSchema, classifier.package, getPrefix(data, classifier.package), typeSchema.targetNamespace) ->
							
							// actually add the new top level element to schema and add all the attributes to it that it should have
							containerSchema.element.add(topLevelElement) ->
							ownedAttributes.collect(e | (e.association == null ? addAttributeToComplexType(data, schemaTypeList, e, localComplexType, allPackages) : parseAssociations(data, schemaTypeList, {e.association}, allPackages) ))
						) : null													
					)
				) : null
			)
		)
	);
	
// Gets all the user defined top level elements for a given Enumeration or Primitive Type and adds them to the schema
cached parseUserDefinedTopLevelElementsForTypes(ExportTransformationData data, Collection[xmlSchema::SchemaType] schemaTypeList, DataType dataType, List[String] topLevelElementOrAttributeNames) :		
	let topLevelElement = new TopLevelElement :
	let simpleType = new LocalSimpleType :
	let restrictionType = new RestrictionType1 :
	let name = (
		let origName = getOriginalName(dataType) :
		origName != null ? origName : dataType.name
	) :
	let containerSchema = schemaTypeList.typeSelect(xmlSchema::SchemaType).select(e|e.targetNamespace == getNamespace(dataType.package,true)).first() :		
	
	topLevelElementOrAttributeNames.contains(name+"_elem_"+containerSchema.targetNamespace) ? null : (	
		
		// XPD-5895: If the user defined primitive type is having same name as xsd base type (for instance a Text primitive type with name as 'Name' 
		// which the reserved word validation done by CDSEntityNameRule.validateClassifier doesn't report as a problem. It checks for Java reserved words and JavaScript reserved words) 
		// then the top level element added for this primitive type gets the wrong base type set. 
		// It was trying to set the base xsd type (without any prefix, which was not correct) instead of the user defined primitive type 
		
		let prefix = data.getPrefixForNamespace(containerSchema.targetNamespace):
		let qName = createQName(containerSchema.targetNamespace, name):
		let localPart = getLocalPart(qName.localPart) :
		let dataTypePrefix = getPrefix(data, dataType.package) :
		
		topLevelElement.setName(name + "Element") ->
		
		isKnownXSDType("xsd:" + localPart) ? (
					traceMe("known xsd type " + localPart)->
					restrictionType.setBase(getQName(containerSchema, "xsd:" + localPart, prefix))
				) : (
					traceMe("unknown xsd type " + localPart)->
					restrictionType.setBase(createQName(containerSchema.targetNamespace, localPart, getPrefix(data, dataType.package))
				)
		) ->
		
		simpleType.setRestriction(restrictionType) ->
		topLevelElement.setSimpleType(simpleType) ->					
		containerSchema.element.select(e|e.name == topLevelElement.name).first() == null ? (
			topLevelElementOrAttributeNames.add(topLevelElement.name+"_elem_"+containerSchema.targetNamespace) ->
			containerSchema.element.add(topLevelElement) 
		) : null
	);
	
// Gets all the user defined top level elements for a given Class and adds them to the schema
cached parseUserDefinedTopLevelElementsForClasses(ExportTransformationData data, Collection[xmlSchema::SchemaType] schemaTypeList, Classifier classifier, List[String] topLevelElementOrAttributeNames) :		
	let topLevelElement = new TopLevelElement :	
	let name = (
		let origName = getOriginalName(classifier) :
		origName != null ? origName : classifier.name
	) :
	let containerSchema = schemaTypeList.typeSelect(xmlSchema::SchemaType).select(e|e.targetNamespace == getNamespace(classifier.package,true)).first() :		
	topLevelElementOrAttributeNames.contains(name+"_elem_"+containerSchema.targetNamespace) ? null : (	
		topLevelElement.setName(name+"Element") ->
		topLevelElement.setType(createQName(containerSchema.targetNamespace,name)) ->		
		containerSchema.element.select(e|e.name == topLevelElement.name).first() == null ? (
			topLevelElementOrAttributeNames.add(topLevelElement.name+"_elem_"+containerSchema.targetNamespace) ->
			containerSchema.element.add(topLevelElement) 
		) : null
	);
		