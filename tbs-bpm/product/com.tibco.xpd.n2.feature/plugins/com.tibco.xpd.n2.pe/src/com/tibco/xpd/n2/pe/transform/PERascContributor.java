/*
 * Copyright (c) TIBCO Software Inc 2004, 2019. All rights reserved.
 */

package com.tibco.xpd.n2.pe.transform;

import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintStream;
import java.io.UnsupportedEncodingException;
import java.net.URI;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Map.Entry;

import org.eclipse.core.resources.IContainer;
import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Status;
import org.eclipse.core.runtime.SubMonitor;

import com.tibco.bpm.dt.rasc.MicroService;
import com.tibco.bpm.dt.rasc.PropertyValue;
import com.tibco.bpm.dt.rasc.Version;
import com.tibco.xpd.analyst.resources.xpdl2.Xpdl2ResourcesPlugin;
import com.tibco.xpd.analyst.resources.xpdl2.utils.SharedResourceUtil;
import com.tibco.xpd.n2.bpel.builder.BPELOnDemandBuilder;
import com.tibco.xpd.n2.bpel.utils.BPELN2Utils;
import com.tibco.xpd.n2.daa.utils.N2PENamingUtils;
import com.tibco.xpd.n2.pe.PEActivator;
import com.tibco.xpd.n2.pe.internal.Messages;
import com.tibco.xpd.rasc.core.RascAppSummary;
import com.tibco.xpd.rasc.core.RascContext;
import com.tibco.xpd.rasc.core.RascContributor;
import com.tibco.xpd.rasc.core.RascDependency;
import com.tibco.xpd.rasc.core.RascWriter;
import com.tibco.xpd.resources.WorkingCopy;
import com.tibco.xpd.resources.XpdResourcesPlugin;
import com.tibco.xpd.resources.builder.ondemand.BuildTargetSet;
import com.tibco.xpd.resources.logger.Logger;
import com.tibco.xpd.resources.projectconfig.ProjectConfig;
import com.tibco.xpd.resources.util.SpecialFolderUtil;
import com.tibco.xpd.xpdExtension.EmailResource;
import com.tibco.xpd.xpdExtension.ParticipantSharedResource;
import com.tibco.xpd.xpdExtension.RestServiceResource;
import com.tibco.xpd.xpdl2.Package;
import com.tibco.xpd.xpdl2.Participant;
import com.tibco.xpd.xpdl2.Process;
import com.tibco.xpd.xpdl2.util.Xpdl2ModelUtil;

/**
 * An implementation of RascContributor to add Process Engine and Page Flow BPEL
 * files in the RASC artifacts.
 *
 * @author pwatson
 * @since 19 Mar 2019
 */
public class PERascContributor implements RascContributor {
    /**
     * The unique identifier for this RascContribution implementation.
     */
    private static String ID = "com.tibco.xpd.n2.pe.transform.pe.contributor"; //$NON-NLS-1$

    private static final String LOG_BUILD_FAILED = "Project build failed."; //$NON-NLS-1$

    private static final String LINE_SEPARATOR = "line.separator"; //$NON-NLS-1$

    private static final String workModelVersionRange =
            "workModelVersionRange=\""; //$NON-NLS-1$

    private static final String workModelVersionRangeRegex =
            workModelVersionRange + "(.*?)\""; //$NON-NLS-1$

    private static final String BPEL_FILE_ENCODING = "UTF-8"; //$NON-NLS-1$

    /**
     * The name of the manifest attribute to which the collection of shared
     * resource references will be written.
     */
    public static final String SHARED_RESOURCE_MANIFEST_ATTR =
            "Resource-Dependencies"; //$NON-NLS-1$

    /**
     * The shared-resource manifest attribute property that identifies the type
     * of resource.
     */
    private static final String SHARED_RSRC_TYPE_PROP = "type"; //$NON-NLS-1$

    /**
     * The shared-resource manifest attribute property that describes the
     * resource.
     */
    private static final String SHARED_RSRC_DESC_PROP = "description"; //$NON-NLS-1$

    /**
     * The identifies a REST service shared-resource within the manifest
     * attribute "Resource-Dependencies.
     */
    private static final String REST_SERVICE_SHARED_RSRC_TYPE = "HTTPClient"; //$NON-NLS-1$

    /**
     * The identifies an EMail service shared-resource within the manifest
     * attribute "Resource-Dependencies.
     */
    private static final String EMAIL_SERVICE_SHARED_RSRC_TYPE = "EMail"; //$NON-NLS-1$

    /**
     * The MicroServices to which the Process Engine artifacts generated by this
     * contributor will be delivered.
     */
    public static final MicroService[] BP_DESTINATION_SERVICES =
            { MicroService.BP };

    /**
     * The MicroServices to which the Page-Flow artifacts generated by this
     * contributor will be delivered.
     */
    public static final MicroService[] PF_DESTINATION_SERVICES =
            { MicroService.UP };

    /**
     * The MicroServices to which the BOM Data Dependency artifacts generated by
     * this contributor will be delivered.
     */
    public static final MicroService[] BOM_DATAINFO_SERVICES =
            { MicroService.BP };

    /**
     * @see com.tibco.xpd.rasc.core.RascContributor#getId()
     */
    @Override
    public String getId() {
        return PERascContributor.ID;
    }

    /**
     * @see com.tibco.xpd.rasc.core.RascContributor#hasContributionsFor(org.eclipse.core.resources.IProject)
     */
    @Override
    public boolean hasContributionsFor(IProject aProject) {
        List<IResource> xpdlResources = SpecialFolderUtil
                .getAllDeepResourcesInSpecialFolderOfKind(aProject,
                        N2PENamingUtils.PROCESS_SPECIALFOLDER_KIND,
                        N2PENamingUtils.XPDL_FILE_EXTENSION,
                        false);
        if ((xpdlResources != null) && (!xpdlResources.isEmpty())) {
            return true;
        }

        try {
            // are there any BOM asset references
            return hasBomDependencies(aProject, null);
        } catch (CoreException e) {
            return false;
        }
    }

    /**
     * @see com.tibco.xpd.rasc.core.RascContributor#process(org.eclipse.core.resources.IProject,
     *      com.tibco.xpd.rasc.core.RascContext,
     *      org.eclipse.core.runtime.IProgressMonitor,
     *      com.tibco.xpd.rasc.core.RascWriter)
     *
     * @param aProject
     * @param aContext
     * @param aProgressMonitor
     * @param aWriter
     * @throws Exception
     */
    @Override
    public void process(IProject aProject, RascContext aContext,
            IProgressMonitor aProgressMonitor, RascWriter aWriter)
            throws Exception {

        SubMonitor monitor = SubMonitor.convert(aProgressMonitor,
                Messages.PERascContributor_BuildingProcesses_status,
                2);
        monitor.subTask(Messages.PERascContributor_BuildingProcesses_status);

        // refresh the generated BPEL files for the given project
        BPELOnDemandBuilder bpelBuilder = new BPELOnDemandBuilder(aProject);

        IStatus status = bpelBuilder.buildProject(monitor.split(1));
        if (!status.isOK()) {
            Logger logger = Xpdl2ResourcesPlugin.getDefault().getLogger();
            logger.debug(PERascContributor.LOG_BUILD_FAILED);
            logger.log(status);
            monitor.done();
            return;
        }

        addBpelToRasc(monitor.split(1),
                aWriter,
                bpelBuilder,
                aContext.getVersion());

        // add the shared-resource references to the RASC
        addSharedResources(aWriter, getSharedResources(aProject));

        // add the BOM dependency references to the RASC
        addBomDependencies(aWriter, aContext.getAppSummary());

        monitor.subTask(""); //$NON-NLS-1$
        monitor.done();
    }

    /**
     * Add the BPEL files to the RASC
     * 
     * @param aProgressMonitor
     * @param aWriter
     * @param bpelBuilder
     * @param version
     * @throws CoreException
     */
    private void addBpelToRasc(IProgressMonitor aProgressMonitor,
            final RascWriter aWriter, BPELOnDemandBuilder bpelBuilder,
            Version version) throws CoreException {
        /*
         * Get the target derived file info - we will then output content to the
         * RASC according to these
         */
        Collection<BuildTargetSet> builtTargets = bpelBuilder.getBuiltTargets();

        int numTargets = countBpelResources(builtTargets);

        SubMonitor monitor = SubMonitor.convert(aProgressMonitor,
                Messages.PERascContributor_AddingRuntimeProcesses,
                numTargets);
        monitor.subTask(Messages.PERascContributor_AddingRuntimeProcesses);

        try {
            /*
             * Iterate the build targets. Output the BPEL files to the
             * appropriate micro-services
             */
            for (BuildTargetSet buildTargetSet : builtTargets) {
                for (Entry<IResource, Object> targetAndSource : buildTargetSet
                        .getTargetToSourceObjectMap().entrySet()) {

                    IResource targetResource = targetAndSource.getKey();
                    Object sourceObject = targetAndSource.getValue();

                    if (sourceObject instanceof Process
                            && BPELN2Utils.BPEL_FILE_EXTENSION.equals(
                                    targetResource.getFileExtension())) {

                        Process sourceProcess = (Process) sourceObject;

                        // determine its recipient MicroServices
                        MicroService[] destinations =
                                getDestinations(targetResource);

                        if (destinations != null) {
                            addRascBpelResource(aWriter,
                                    (IFile) targetResource,
                                    sourceProcess,
                                    destinations,
                                    version);
                        }
                    }

                    monitor.worked(1);
                }
            }

        } finally {
            monitor.subTask(""); //$NON-NLS-1$
            monitor.done();
        }
    }

    /**
     * Add the given target BPEL resource to the RASC.
     * 
     * @param aWriter
     *            The RASC writer
     * @param bpelFile
     *            The BPEL resource
     * @param sourceProcess
     *            The process that BPEL was derived from.
     * @param destinations
     *            The destination micro-service
     * @param version
     * @throws CoreException
     */
    private void addRascBpelResource(RascWriter aWriter, IFile bpelFile,
            Process sourceProcess, MicroService[] destinations, Version version)
            throws CoreException {

        // find the real location of the BPEL file
        URI uri = bpelFile.getLocationURI();
        if (uri == null) {
            return; // ignore this file
        }

        try {
            // copy the BPEL file to the RASC
            InputStream input =
                    replaceUserTaskModelsVersionRange(bpelFile, version);

            try {
                String relativePath =
                        bpelFile.getProjectRelativePath().toString();

                /*
                 * The temp build folder is Project/.processOut; in the RASC we
                 * just want "processOut"
                 */
                if (relativePath.charAt(0) == '.') {
                    relativePath = relativePath.substring(1);
                }

                // create a RASC artifact with the BPEL file name
                OutputStream output = aWriter.addContent(relativePath,
                        Xpdl2ModelUtil.getDisplayName(sourceProcess),
                        sourceProcess.getName(),
                        destinations);
                try {
                    int len;
                    byte[] buffer = new byte[1024];
                    while ((len = input.read(buffer)) > 0) {
                        output.write(buffer, 0, len);
                    }
                } finally {
                    output.close();
                }

            } finally {
                input.close();
            }
        } catch (Exception e) {
            IStatus status =
                    new Status(Status.ERROR, "PE RASC Contributor Plug-in", //$NON-NLS-1$
                            e.getMessage(), e);
            throw new CoreException(status);
        }
    }

    /**
     * In the generated BPEL file (which may have been generated and cached on
     * disk some time ago) there are <model:UserTaskDataModelType> elements with
     * version number ranges referencing work model elements. These need to be
     * replaced during streaming to RASC.
     * 
     * Sid ACE-883: For reference, this code copied from BPM Studio's
     * N2PEPackagerPartcipant class then modified for RASC env'
     * 
     * @param bpelFile
     * @param version
     * 
     * @return An input stream for the modified file.
     */
    private InputStream replaceUserTaskModelsVersionRange(IFile bpelFile,
            Version version) throws CoreException {
        /*
         * Load the existing content into a string builder.
         */
        StringBuilder strBuilder = new StringBuilder();

        InputStream contentsInputStream = null;
        InputStreamReader inputStreamReader = null;
        BufferedReader bufferedReader = null;

        try {
            contentsInputStream = bpelFile.getContents();
            inputStreamReader = new InputStreamReader(contentsInputStream,
                    Charset.forName(BPEL_FILE_ENCODING));

            bufferedReader = new BufferedReader(inputStreamReader);
            String expLine = null;
            while ((expLine = bufferedReader.readLine()) != null) {
                strBuilder.append(expLine);
                strBuilder.append(System.getProperty(LINE_SEPARATOR));
            }

        } catch (IOException e) {
            throw new CoreException(new Status(IStatus.ERROR,
                    PEActivator.PLUGIN_ID,
                    "IOException whilst reading BPEL file: " + e.getMessage())); //$NON-NLS-1$

        } finally {
            if (bufferedReader != null) {
                try {
                    bufferedReader.close();
                } catch (IOException e) {
                    throw new CoreException(new Status(IStatus.ERROR,
                            PEActivator.PLUGIN_ID,
                            "IOException whilst closing BPEL bufferedReader: " //$NON-NLS-1$
                                    + e.getMessage()));
                }
            }
            if (inputStreamReader != null) {
                try {
                    inputStreamReader.close();
                } catch (IOException e) {
                    throw new CoreException(new Status(IStatus.ERROR,
                            PEActivator.PLUGIN_ID,
                            "IOException whilst closing BPEL inputStreamReader: " //$NON-NLS-1$
                                    + e.getMessage()));
                }
            }

            if (contentsInputStream != null) {
                try {
                    contentsInputStream.close();
                } catch (IOException e) {
                    throw new CoreException(new Status(IStatus.ERROR,
                            PEActivator.PLUGIN_ID,
                            "IOException whilst closing BPEL contentsInputStream: " //$NON-NLS-1$
                                    + e.getMessage()));
                }
            }
        }

        /*
         * Rebuild the property with the correct version number from the RASC
         * generation context.
         */

        String newAttribute =
                String.format("workModelVersionRange=\"[%1$s,%1$s]\"", //$NON-NLS-1$
                        version.toString());

        String origBpelContents = strBuilder.toString();
        String changedBpelContents = origBpelContents
                .replaceAll(workModelVersionRangeRegex, newAttribute);

        byte[] bytes = changedBpelContents
                .getBytes(Charset.forName(BPEL_FILE_ENCODING));

        return new ByteArrayInputStream(bytes);
    }

    /**
     * Determines the MicroServices to which the given resource is to be
     * delivered. If the response is <code>null</code>, the resource will not be
     * included in the RASC artifacts.
     * 
     * @param aResource
     *            the resource that is to be delivered to the MicroServices.
     * @return the list of MicroService destinations. May be <code>null</code>.
     */
    private MicroService[] getDestinations(IResource aResource) {
        if (BPELN2Utils.BP_OUTPUTFOLDER_NAME.equals(aResource.getName())) {
            return PERascContributor.BP_DESTINATION_SERVICES;
        }
        if (BPELN2Utils.PF_OUTPUTFOLDER_NAME.equals(aResource.getName())) {
            return PERascContributor.PF_DESTINATION_SERVICES;
        }
        IContainer parent = aResource.getParent();
        return (parent == null) ? null : getDestinations(parent);
    }

    /**
     * @param builtTargets
     * @return The total number of target resources built for the project.
     */
    private int countBpelResources(Collection<BuildTargetSet> builtTargets) {
        int count = 0;

        for (BuildTargetSet buildTargetSet : builtTargets) {
            count += buildTargetSet.getTargetResources().size();
        }
        return count;
    }

    /**
     * Adds the given collection of shared resource references to the RASC (via
     * the given RascWriter).
     * 
     * @param aWriter
     *            the accessor for the RASC.
     * @param aSharedResources
     *            the collection of shared resource referencs.
     */
    private void addSharedResources(RascWriter aWriter,
            Collection<ParticipantSharedResource> aSharedResources) {
        if (aSharedResources.isEmpty()) {
            return;
        }

        // create a list of RASC manifest PropertyValues for each resource
        ArrayList<PropertyValue> attrValue = new ArrayList<>();
        for (ParticipantSharedResource sharedResource : aSharedResources) {
            RestServiceResource restService = sharedResource.getRestService();
            if (restService != null) {
                PropertyValue property = new PropertyValue();
                property.setValue(restService.getResourceName());
                property.setAttribute(SHARED_RSRC_TYPE_PROP,
                        REST_SERVICE_SHARED_RSRC_TYPE);
                property.setAttribute(SHARED_RSRC_DESC_PROP,
                        restService.getDescription());
                attrValue.add(property);
                continue;
            }

            EmailResource email = sharedResource.getEmail();
            if (email != null) {
                PropertyValue property = new PropertyValue();
                property.setValue(email.getInstanceName());
                property.setAttribute(SHARED_RSRC_TYPE_PROP,
                        EMAIL_SERVICE_SHARED_RSRC_TYPE);
                attrValue.add(property);
                continue;
            }
        }

        if (attrValue.isEmpty()) {
            return;
        }

        // add the references to the RASC manifest
        PropertyValue[] values =
                attrValue.toArray(new PropertyValue[attrValue.size()]);
        aWriter.setManifestAttribute(SHARED_RESOURCE_MANIFEST_ATTR, values);
    }

    /**
     * Find all SharedResource instances within the given project. Returns an
     * empty collection if none are found.
     * 
     * @param aProject
     *            the project to search.
     * @return the collection of shared resource found.
     */
    private Collection<ParticipantSharedResource> getSharedResources(
            IProject aProject) {
        Collection<Package> packages = getProcessPackages(aProject);
        if ((packages == null) || (packages.isEmpty())) {
            return Collections.emptyList();
        }

        Collection<ParticipantSharedResource> result = new ArrayList<>();
        for (Package pkg : packages) {
            result.addAll(getSharedResources(pkg.getParticipants()));

            for (Process process : pkg.getProcesses()) {
                result.addAll(getSharedResources(process.getParticipants()));
            }
        }

        return result;
    }

    /**
     * Return all instances of the given Participants that reference shared
     * resources. If there are no shared resource references the return value
     * will be an empty collection.
     * 
     * @param aParticipants
     *            the participants to search.
     * @return the collection of shared resource references.
     */
    private Collection<ParticipantSharedResource> getSharedResources(
            Collection<Participant> aParticipants) {
        if ((aParticipants == null) || (aParticipants.isEmpty())) {
            return Collections.emptyList();
        }

        Collection<ParticipantSharedResource> result = new ArrayList<>();
        ParticipantSharedResource sharedResource;
        for (Participant participant : aParticipants) {
            sharedResource = SharedResourceUtil
                    .getParticipantSharedResource(participant);
            if (sharedResource != null) {
                result.add(sharedResource);
            }
        }

        return result;
    }

    /**
     * Looks through the resources within the given project and returns any
     * Process Packages it may find. If there are no Process Packages the return
     * value will be an empty collection.
     * 
     * @param aProject
     *            the Project whose resources are to be searched.
     * @return the collection of Process Packages found.
     */
    private Collection<Package> getProcessPackages(IProject aProject) {
        return getProcessPackages(SpecialFolderUtil
                .getAllDeepResourcesInSpecialFolderOfKind(aProject,
                        N2PENamingUtils.PROCESS_SPECIALFOLDER_KIND,
                        N2PENamingUtils.XPDL_FILE_EXTENSION,
                        false));
    }

    /**
     * Looks through the given resources and returns any Process Packages it may
     * find. If there are no Process Packages the return value will be an empty
     * collection.
     * 
     * @param aResources
     *            the Resources to be searched.
     * @return the collection of Process Packages found.
     */
    private Collection<Package> getProcessPackages(
            Collection<IResource> aResources) {
        if ((aResources == null) || (aResources.isEmpty())) {
            return Collections.emptyList();
        }

        Collection<Package> result = new ArrayList<>();
        for (IResource resource : aResources) {
            WorkingCopy wc =
                    XpdResourcesPlugin.getDefault().getWorkingCopy(resource);
            Package xpdlPackage = (Package) wc.getRootElement();
            if (xpdlPackage == null) {
                continue;
            }

            result.add(xpdlPackage);
        }

        return result;
    }

    /**
     * Adds an artifact, if required, that lists the references to those project
     * dependencies that contain BOM assets.
     * 
     * @param aWriter
     *            the RascWriter to which the artifact is to be written.
     * @param aAppSummary
     *            the summary of the deployed application; from which
     *            dependencies can be derived.
     * @throws Exception
     */
    private void addBomDependencies(RascWriter aWriter,
            RascAppSummary aAppSummary) throws Exception {
        // look for any direct/indirect dependencies containing BOMs
        Collection<RascDependency> bomDependencies =
                getBomDependencies(aAppSummary.getReferencedProjects(), null);

        // if none found
        if (bomDependencies.isEmpty()) {
            return;
        }

        // output JSON to the RASC
        OutputStream output = aWriter.addContent("dataInfo.di", //$NON-NLS-1$
                "data-dependencies", //$NON-NLS-1$
                "dataInfo.di", //$NON-NLS-1$
                PERascContributor.BOM_DATAINFO_SERVICES);
        try {
            write(bomDependencies, output);
        } finally {
            output.close();
        }
    }

    /**
     * Recursively traverses the given RascDependency objects to return those
     * that contain a BOM asset.
     * 
     * @param aDependencies
     *            the dependencies to be visited.
     * @param aVisited
     *            the on-going collection of visited dependencies (to prevent
     *            circular references).
     * @return the collection of dependencies with BOM assets.
     * @throws CoreException
     */
    private Collection<RascDependency> getBomDependencies(
            Collection<RascDependency> aDependencies,
            Collection<RascDependency> aVisited) throws CoreException {
        Collection<RascDependency> result = new ArrayList<>();
        if (aVisited == null) {
            aVisited = new HashSet<>();
        }

        for (RascDependency dependency : aDependencies) {
            // if we've already visited this one
            if (!aVisited.add(dependency)) {
                continue;
            }

            // if it contains a BOM - include it in result
            if (dependency.hasAssetType(
                    com.tibco.xpd.bom.resources.ui.Activator.BOM_ASSET_ID)) {
                result.add(dependency);
            }

            // visit nested dependencies
            result.addAll(getBomDependencies(dependency.getReferencedProjects(),
                    aVisited));
        }

        return result;
    }

    /**
     * Writes the given project dependency references, as a JSON packet, to the
     * given PrintStream.
     * 
     * @param aDependencies
     *            the project dependency references.
     * @param printer
     *            the PrintStream to which to write the references.
     * @throws UnsupportedEncodingException
     *             if UTF8 is not supported.
     */
    private void write(Collection<RascDependency> aDependencies,
            OutputStream aOutput) throws UnsupportedEncodingException {

        PrintStream printer =
                new PrintStream(aOutput, false, StandardCharsets.UTF_8.name());
        printer.print("{\"dataProjectDependencies\":["); //$NON-NLS-1$

        boolean first = true;
        for (RascDependency dependency : aDependencies) {
            if (!first) {
                printer.print(',');
                first = false;
            }
            printer.print("\"projectId\":\""); //$NON-NLS-1$
            printer.print(dependency.getInternalName());
            printer.print("\",\"version\":\""); //$NON-NLS-1$
            printer.print(dependency.getDependencyRange());
            printer.print("\"}"); //$NON-NLS-1$
        }
        printer.print("]}"); //$NON-NLS-1$
    }

    /**
     * Recursively checks the project dependency to see if any contains a BOM
     * asset.
     * 
     * @param aProject
     *            the project whose dependencies are to be searched.
     * @return true if any project in the dependency hierarchy contains a BOM
     *         asset. Otherwise false.
     * @throws CoreException
     */
    private boolean hasBomDependencies(IProject aProject,
            Collection<IProject> aVisited) throws CoreException {
        // keep a record of those we've visited
        if (aVisited == null) {
            aVisited = new HashSet<>();
        }

        // have we've already seen this project
        else if (!aVisited.add(aProject)) {
            return false;
        }

        for (IProject reference : aProject.getReferencedProjects()) {
            // if it contains a BOM asset
            ProjectConfig projectConfig =
                    XpdResourcesPlugin.getDefault().getProjectConfig(reference);
            if (projectConfig.hasAssetType(
                    com.tibco.xpd.bom.resources.ui.Activator.BOM_ASSET_ID)) {
                return true;
            }

            // if nested dependencies contain BOM reference
            if (hasBomDependencies(reference, aVisited)) {
                return true;
            }
        }

        return false;
    }
}
