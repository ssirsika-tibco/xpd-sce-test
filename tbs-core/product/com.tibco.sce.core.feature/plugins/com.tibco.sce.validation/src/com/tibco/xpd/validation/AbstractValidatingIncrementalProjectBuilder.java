/**
 * Copyright (c) TIBCO Software Inc 2004-2010. All rights reserved.
 */

package com.tibco.xpd.validation;

import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.resources.IncrementalProjectBuilder;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.ui.internal.Workbench;

import com.tibco.xpd.resources.XpdResourcesPlugin;
import com.tibco.xpd.resources.util.ProjectUtil;
import com.tibco.xpd.validation.explicit.Validator;
import com.tibco.xpd.validation.internal.ValidationManager;
import com.tibco.xpd.validation.provider.ValidationException;
import com.tibco.xpd.validation.rules.ValidationUtil;

/**
 * Sometimes builders that are downstream of a particular builder are dependent
 * on the non-existence of validation markers on a source file generated by an
 * upstream builder.
 * <p>
 * It is not always guaranteed that a validation will have been performed.
 * <p>
 * In these situations the upstream builder should sub-class this class which
 * will allow is to specify resources to revalidate (i.e. the files it has
 * created and their dependencies) (via the
 * {@link #doBuild(int, Map, IProgressMonitor, Set)}).
 * 
 * XPD-391.
 * 
 * <p>
 * <strong>Since 3.5</strong>: This builder will not run if the project has a
 * migration marker on it, ie the project needs to be migrated to the latest
 * version.
 * </p>
 * 
 * @author aallway
 * @since 3.3 (16 Apr 2010)
 */
public abstract class AbstractValidatingIncrementalProjectBuilder extends
        IncrementalProjectBuilder {

    private Validator validator;

    /*
     * (non-Javadoc)
     * 
     * @see org.eclipse.core.resources.IncrementalProjectBuilder#build(int,
     * java.util.Map, org.eclipse.core.runtime.IProgressMonitor)
     */
    @Override
    protected final IProject[] build(int kind, Map args,
            IProgressMonitor monitor) throws CoreException {

        if (shouldRun() && isProjectCurrent(getProject())) {
            Set<IResource> filesToValidate = new HashSet<IResource>();

            /* Perform the sub-class's build. */
            IProject[] dependentProjects =
                    doBuild(kind, args, monitor, filesToValidate);

            /* Validate any files that the sub-class has indicated. */
            validateFilesAffectedByBuild(filesToValidate);

            return dependentProjects;
        }
        return null;
    }

    /**
     * Check if this builder should run. Default implementation returns
     * <code>true</code> if this is not the RCP application. Subclasses may
     * override
     * 
     * @return
     * @since 3.5.2
     */
    protected boolean shouldRun() {
        // XPD-4044: Builder should not run when the workbench is in closing
        // process.
        boolean isClosing = false;
        if (!(XpdResourcesPlugin.isRCP() || XpdResourcesPlugin
                .isInHeadlessMode())) {
            if (Workbench.getInstance() != null) {

                isClosing = Workbench.getInstance().isClosing();
                return (!isClosing);
            }
        }
        return true;
    }

    /**
     * Check if the project is up-to-date and doesn't need migrating.
     * 
     * @param project
     * 
     * @return <code>true</code> if the project is current, <code>false</code>
     *         if it needs migrating.
     * @throws CoreException
     * @since 3.5
     */
    private boolean isProjectCurrent(IProject project) throws CoreException {
        return !ProjectUtil.doesProjectHaveMigrationMarker(project);
    }

    /**
     * In this method the subclass should do everything it would normally do in
     * it's implementation of {@link #build(int, Map, IProgressMonitor)} with
     * the addition that it should add any files that it wishes to be
     * revalidated to the filesToValidate list.
     * <p>
     * These files (and their validation dependencies) will be revalidated
     * before {@link #build(int, Map, IProgressMonitor)} exits.
     * 
     * @param kind
     *            see {@link #build(int, Map, IProgressMonitor)}
     * @param args
     *            see {@link #build(int, Map, IProgressMonitor)}
     * @param monitor
     *            see {@link #build(int, Map, IProgressMonitor)}
     * @param filesToValidate
     *            List to return files that should be revalidated.
     * 
     * @return see {@link #build(int, Map, IProgressMonitor)}
     */
    protected abstract IProject[] doBuild(int kind, Map args,
            IProgressMonitor monitor, Set<IResource> filesToValidate)
            throws CoreException;

    /**
     * This method is executed at the end of a build on a particular resource
     * and validates any files that the sub-class
     * {@link #doBuild(int, Map, IProgressMonitor, List)} has indicated.
     * 
     * @param filesToValidate
     */
    private void validateFilesAffectedByBuild(
            Collection<IResource> filesToValidate) {

        /*
         * Sid XPD-3914: If any of the returned files to validate (nominally
         * will contain the files just built if they are things that are user
         * visible and therefore referencable - such as generated BOMs) THEN
         * check if any of them match dependency-index PROXY items waiting to be
         * resolved.
         */
        Set<IResource> allFilesToValidate =
                getPossibleProxyDependents(filesToValidate);
        allFilesToValidate.addAll(filesToValidate);

        Validator validator = getValidator();

        for (IResource resource : allFilesToValidate) {
            try {
                // System.out
                //                        .println("[" + Thread.currentThread().getId() + "]==> ABSTRACTVALIDATIONBUILDER validate: " //$NON-NLS-1$ //$NON-NLS-2$
                // + resource.getFullPath());

                validator.indexAndValidate(resource, true, true);

                // System.out
                //                        .println("[" + Thread.currentThread().getId() + "]<== ABSTRACTVALIDATIONBUILDER validate: " //$NON-NLS-1$ //$NON-NLS-2$
                // + resource.getFullPath());

            } catch (ValidationException e) {
                /*
                 * Do nothing. This is only thrown if a working copy cannot be
                 * created for the given resource. If there isn't a working copy
                 * for the resource then we are not interested in indexing or
                 * validating it.
                 */
            }
        }

        return;
    }

    /**
     * Sid XPD-3914: Returns set of files which look like they may have a PROXY
     * dependency on one or more of the files to possibly generated by
     * {@link #doBuild(int, Map, IProgressMonitor, Set)}
     * <p>
     * Nominally filesToValidate returned by doBuild() will also contain the
     * files that the builder has generated (if any) EXPECIALLY if they are
     * things that are user visible and therefore referencable (such as
     * generated BOMs).
     * <p>
     * Basically checks the dependency index for any file depended-upon in a
     * PROXY(file doesn't exist yet) type entry that looks like it has the same
     * special-folder-relative path as a file returned by doBuild(). The set of
     * files dependent upon these PROXY type entries is compiled and then
     * returned.
     * 
     * @param filesToValidate
     * 
     * @return Set of files that look like they may depend on one of the files
     *         returned by doBuild(), but the dependency was initially
     *         unresolved because the file hadn't been generated yet.
     */
    protected Set<IResource> getPossibleProxyDependents(
            Collection<IResource> filesToValidate) {
        return ValidationUtil.getPossibleProxyDependents(filesToValidate);
    }

    /**
     * Get the explicit validator (this will validate for all available
     * destinations).
     * 
     * @return
     */
    private Validator getValidator() {
        if (validator == null) {
            // Validate for all available destinations
            validator =
                    new Validator(ValidationManager.getInstance()
                            .getDestinations());
        }
        return validator;
    }

    /**
     * Cancel current processing.
     * 
     * @param monitor
     *            Progress monitor
     * @param forgetBuildSate
     *            <code>true</code> if build state should be forgotten
     */
    protected void checkCancel(IProgressMonitor monitor, boolean forgetBuildSate) {
        IncrementalProjectBuilder builder = forgetBuildSate ? this : null;
        ProjectUtil.checkBuildCancel(monitor, builder);
    }
}
