/*
 * Copyright (c) TIBCO Software Inc 2004, 2010. All rights reserved.
 */

package com.tibco.xpd.resources.ui.compare.viewer;

import java.util.ResourceBundle;

import org.eclipse.compare.CompareConfiguration;
import org.eclipse.compare.CompareUI;
import org.eclipse.compare.ICompareInputLabelProvider;
import org.eclipse.compare.IStreamContentAccessor;
import org.eclipse.compare.ITypedElement;
import org.eclipse.compare.IViewerCreator;
import org.eclipse.compare.contentmergeviewer.ContentMergeViewer;
import org.eclipse.compare.internal.MergeViewerContentProvider;
import org.eclipse.compare.structuremergeviewer.ICompareInput;
import org.eclipse.compare.structuremergeviewer.IDiffContainer;
import org.eclipse.compare.structuremergeviewer.IDiffElement;
import org.eclipse.draw2d.ColorConstants;
import org.eclipse.jface.action.ActionContributionItem;
import org.eclipse.jface.action.IContributionItem;
import org.eclipse.jface.action.Separator;
import org.eclipse.jface.action.ToolBarManager;
import org.eclipse.jface.viewers.StructuredSelection;
import org.eclipse.jface.viewers.TreeViewer;
import org.eclipse.jface.viewers.Viewer;
import org.eclipse.swt.SWT;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.swt.widgets.Control;

import com.tibco.xpd.resources.ui.compare.nodes.IChildCompareNode;
import com.tibco.xpd.resources.ui.compare.nodes.XpdCompareNode;
import com.tibco.xpd.resources.ui.compare.viewer.internal.ExpandAllCompareNodesAction;
import com.tibco.xpd.resources.ui.compare.viewer.internal.MergeContentTitleLabelProvider;
import com.tibco.xpd.resources.ui.compare.viewer.internal.MergeContentTreeContentProvider;
import com.tibco.xpd.resources.ui.compare.viewer.internal.MergeContentTreeViewer;
import com.tibco.xpd.resources.ui.compare.viewer.internal.MergeContentViewerType;
import com.tibco.xpd.resources.ui.compare.viewer.internal.MergeContentViewerUtil;
import com.tibco.xpd.resources.ui.compare.viewer.internal.MergeTreeChangeDecorator;
import com.tibco.xpd.resources.ui.compare.viewer.internal.MergeViewerCrossoverControl;
import com.tibco.xpd.resources.ui.compare.viewer.internal.ShowInternalPropertiesAction;
import com.tibco.xpd.resources.ui.compare.viewer.internal.SynchExpandListener;
import com.tibco.xpd.resources.ui.compare.viewer.internal.SynchScrollPosListener;
import com.tibco.xpd.resources.ui.compare.viewer.internal.SynchSelectionListener;

/**
 * Content merge viewer based on XpdCompareNode tree data generated by sub-class
 * provided structure creator.
 * <p>
 * Each side of the compare is represented as a tree-view on that content.
 * <p>
 * <b>This level of class hierarchy exists to get some kind of separation of the
 * generic aspects of the tree based content merge and the EMF model aspects
 * handled by {@link EMFCompareMergeViewer}.
 * 
 * 
 * @author aallway
 * @since 12 Oct 2010
 */
public abstract class XpdCompareMergeViewer extends
        ContentMergeViewer {

    /**
     * Property added to XpdCOmpareNode's by
     * {@link MergeContentTreeContentProvider} that is a copy of the DiffNode
     * element of the model comparison in the top window diff viewer
     */
    public static final String DIFF_NODE_KIND_PROPERTY =
            "XpdCompareNodeLabelProvider.diffNodeKind"; //$NON-NLS-1$

    /**
     * The ancestor viewer (used in 3-way merges only i.e. svn compare with base
     * revision that has changed since checkout.
     */
    protected MergeContentTreeViewer ancestorViewer;

    /**
     * The left hand viewer
     */
    protected MergeContentTreeViewer leftViewer;

    /**
     * The right hand viewer.
     */
    protected MergeContentTreeViewer rightViewer;

    /**
     * The left/right view HEADER label provider. underlying class uses a little
     * bt of a strange setup whereby it caches the header label provider for
     * each different input that is set on this viewer.
     */
    private MergeContentTitleLabelProvider leftRightViewerTitleLabelProvider;

    /**
     * If the top window (diff viewer) allowed the user to select a non-atomic
     * node for the input for this (merge viewer) then we redirect our input to
     * the first atomic ancestor of the input. This flag prevents the
     * possibility of prblems when recursing thru
     * setInput()->updateContent()->setInput()->updateContent().
     */
    private boolean alreadyRedirectingToAtomicAncestor = false;

    /**
     * The centre control that contains the connector lines and difference type
     * icons
     */
    private MergeViewerCrossoverControl mergeViewerCrossoverControl;

    private SynchSelectionListener synchSelectionListener;

    private SynchExpandListener synchExpandListener;

    private SynchScrollPosListener synchScrollPosListener;

    /**
     * Parameters are as passed to {@link IViewerCreator}
     * 
     * @param parent
     * @param style
     * @param cc
     */
    public XpdCompareMergeViewer(Composite parent, int style,
            CompareConfiguration cc) {
        super(
                style,
                ResourceBundle
                        .getBundle("com.tibco.xpd.resources.ui.compare.viewer.XpdCompareMergeViewer"), //$NON-NLS-1$
                cc);
        leftRightViewerTitleLabelProvider =
                new MergeContentTitleLabelProvider(cc, this);

        init();

        buildControl(parent);
        setContentProvider(new XpdMergeViewerContentProvider(cc));
    }

    /**
     * Called during construction this provides an insertion point for
     * sub-class.
     * 
     */
    protected void init() {
        return;
    }

    /**
     * @see org.eclipse.compare.contentmergeviewer.ContentMergeViewer#createToolItems(org.eclipse.jface.action.ToolBarManager)
     * 
     * @param toolBarManager
     */
    @Override
    protected void createToolItems(ToolBarManager toolBarManager) {

        /* Create default actions */
        super.createToolItems(toolBarManager);

        /* Show internal properties toolbar button. */
        ShowInternalPropertiesAction showDetailedDiffs =
                new ShowInternalPropertiesAction(this);

        ActionContributionItem showInternalPropertiesAction =
                new ActionContributionItem(showDetailedDiffs);
        showDetailedDiffs
                .setChecked(((MergeContentTreeContentProvider) getLeftViewer()
                        .getContentProvider()).isExpandInternalProperties());

        showInternalPropertiesAction.setVisible(true);

        toolBarManager.appendToGroup("modes", showInternalPropertiesAction); //$NON-NLS-1$

        toolBarManager.insert(0, new Separator("xpd.comparenode.actions")); //$NON-NLS-1$

        /* Expand all button */
        ExpandAllCompareNodesAction expandAll =
                new ExpandAllCompareNodesAction(this, true);
        ActionContributionItem expandAllAction =
                new ActionContributionItem(expandAll);
        expandAllAction.setVisible(true);
        toolBarManager
                .appendToGroup("xpd.comparenode.actions", expandAllAction); //$NON-NLS-1$

        /* Collapse all button */
        ExpandAllCompareNodesAction collapseAll =
                new ExpandAllCompareNodesAction(this, false);
        ActionContributionItem collapseAllAction =
                new ActionContributionItem(collapseAll);
        expandAllAction.setVisible(true);
        toolBarManager.appendToGroup("xpd.comparenode.actions", //$NON-NLS-1$
                collapseAllAction);

        // TODO For now we will hide the merge controls - in later releases we
        // can re-enable merge.
        disableMergeActions(toolBarManager);

        return;
    }

    /**
     * For now we will hide the merge controls - in later releases we can
     * re-enable merge.
     * 
     * @param toolBarManager
     */
    @SuppressWarnings("restriction")
    private void disableMergeActions(ToolBarManager toolBarManager) {
        boolean foundMerge = false;

        IContributionItem[] items = toolBarManager.getItems();

        for (IContributionItem item : items) {
            /* Wait til we get to the "merge" group. */
            if (!foundMerge) {
                if (item instanceof Separator && "merge".equals(item.getId())) { //$NON-NLS-1$
                    foundMerge = true;
                    item.setVisible(false);
                }

            } else {
                /* Hide everything from "merge" separator to next separator. */
                if (item instanceof Separator) {
                    break;
                }

                item.setVisible(false);
            }
        }
    }

    /**
     * This method can be used prior to left viewer being setup with it's input
     * 
     * @return The left side content input.
     */
    public Object getLeftContent(Object input) {
        if (input instanceof ICompareInput) {
            return ((ICompareInput) getInput()).getLeft();
        }
        return null;
    }

    /**
     * This method can be used prior to right viewer being setup with it's input
     * 
     * @return The right side content input.
     */
    public Object getRightContent(Object input) {
        if (input instanceof ICompareInput) {
            return ((ICompareInput) getInput()).getRight();
        }
        return null;
    }

    /**
     * This method can be used prior to ancestor viewer being setup with it's
     * input
     * 
     * @return The ancestor side content input.
     */
    public Object getAncestorContent(Object input) {
        if (input instanceof ICompareInput) {
            return ((ICompareInput) getInput()).getLeft();
        }
        return null;
    }

    /**
     * Get the element in the difference tree content whose left / right content
     * is that of the given object.
     * 
     * @param leftContent
     * 
     * @return element if found else <code>null</code>
     */
    public IDiffElement getDiffNodeForMergeContent(Object content,
            boolean isLeftContent) {
        if (content != null) {
            Object input = getInput();

            if (input instanceof IDiffElement) {
                return recursiveGetDiffNodeForContent(content,
                        (IDiffElement) input,
                        isLeftContent);
            }
        }

        return null;
    }

    /**
     * @return the synchSelectionListener
     */
    public SynchSelectionListener getSynchSelectionListener() {
        return synchSelectionListener;
    }

    /**
     * @return the synchExpandListener
     */
    public SynchExpandListener getSynchExpandListener() {
        return synchExpandListener;
    }

    /**
     * @return the synchScrollPosListener
     */
    public SynchScrollPosListener getSynchScrollPosListener() {
        return synchScrollPosListener;
    }

    /**
     * Recursively search for the element in the difference tree content whose
     * left / right content is that of the given object.
     * 
     * @param content
     * @param diffEl
     * @param isLeftContent
     * 
     * @return appropriate difference tree element or <code>null</code> if not
     *         found.
     */
    protected IDiffElement recursiveGetDiffNodeForContent(Object content,
            IDiffElement diffEl, boolean isLeftContent) {
        /* Check if this is the IDiffElement we are looking for. */
        if (diffEl instanceof IDiffElement) {
            if (diffEl instanceof ICompareInput) {
                ICompareInput ci = (ICompareInput) diffEl;

                if (isLeftContent && content.equals(ci.getLeft())) {
                    return diffEl;

                } else if (!isLeftContent && content.equals(ci.getRight())) {
                    return diffEl;
                }
            }
        }

        /* If not, check it's children. */
        if (diffEl instanceof IDiffContainer) {
            IDiffElement[] children = ((IDiffContainer) diffEl).getChildren();

            if (children != null) {
                for (IDiffElement child : children) {
                    if (child instanceof IDiffElement) {
                        IDiffElement found =
                                recursiveGetDiffNodeForContent(content,
                                        child,
                                        isLeftContent);

                        if (found != null) {
                            return found;
                        }
                    }
                }
            }
        }

        return null;
    }

    /**
     * @see org.eclipse.compare.contentmergeviewer.ContentMergeViewer#createControls(org.eclipse.swt.widgets.Composite)
     * 
     * @param composite
     */
    @Override
    protected void createControls(Composite composite) {
        ancestorViewer =
                new MergeContentTreeViewer(composite, SWT.SINGLE
                        | SWT.FULL_SELECTION, getCompareConfiguration(),
                        MergeContentViewerType.ANCESTOR, true, false);
        (ancestorViewer).setAutoExpandLevel(0);

        leftViewer =
                new MergeContentTreeViewer(composite, SWT.SINGLE
                        | SWT.FULL_SELECTION, getCompareConfiguration(),
                        MergeContentViewerType.LEFT, true, false);
        leftViewer.setAutoExpandLevel(0);

        rightViewer =
                new MergeContentTreeViewer(composite, SWT.SINGLE
                        | SWT.FULL_SELECTION, getCompareConfiguration(),
                        MergeContentViewerType.RIGHT, true, false);
        (rightViewer).setAutoExpandLevel(0);

        /* Synchronise selection in left/right/ancestor. */
        synchSelectionListener =
                new SynchSelectionListener(new Viewer[] { leftViewer,
                        rightViewer, ancestorViewer });

        leftViewer.addSelectionChangedListener(synchSelectionListener);
        rightViewer.addSelectionChangedListener(synchSelectionListener);
        ancestorViewer.addSelectionChangedListener(synchSelectionListener);

        /*
         * Synchronise expansion in left/right/ancestor.
         */
        synchExpandListener =
                new SynchExpandListener(new Viewer[] { leftViewer, rightViewer,
                        ancestorViewer });

        leftViewer.addTreeListener(synchExpandListener);
        rightViewer.addTreeListener(synchExpandListener);
        ancestorViewer.addTreeListener(synchExpandListener);

        /*
         * Synchronise scroll position to nearest matching top item on each
         * side.
         */
        synchScrollPosListener =
                new SynchScrollPosListener(new TreeViewer[] { leftViewer,
                        rightViewer, ancestorViewer });

        /*
         * Add the decorator to the individual content viewers, this decorator
         * is designed to extend the centre control connector lines into the
         * tree items of those viewers (and also draw separator lines etc).
         */
        new MergeTreeChangeDecorator(leftViewer);
        new MergeTreeChangeDecorator(rightViewer);
        new MergeTreeChangeDecorator(ancestorViewer);

        if (mergeViewerCrossoverControl != null) {
            mergeViewerCrossoverControl.initialise(this);
        }

        return;
    }

    /**
     * @see org.eclipse.compare.contentmergeviewer.ContentMergeViewer#createCenterControl(org.eclipse.swt.widgets.Composite)
     * 
     * @param parent
     * @return the centre control.
     */
    @Override
    protected Control createCenterControl(Composite parent) {

        mergeViewerCrossoverControl = new MergeViewerCrossoverControl(parent);

        mergeViewerCrossoverControl
                .setBackground(ColorConstants.listBackground);

        if (getLeftViewer() != null && getRightViewer() != null) {
            mergeViewerCrossoverControl.initialise(this);
        }

        return mergeViewerCrossoverControl;
    }

    /**
     * @see org.eclipse.compare.contentmergeviewer.ContentMergeViewer#getCenterWidth()
     * 
     * @return The desired width of the centre control.
     */
    @Override
    protected int getCenterWidth() {
        return Math.max(50, (int) (this.getControl().getBounds().width * 0.15));
    }

    /**
     * @return the ancestorViewer
     */
    public MergeContentTreeViewer getAncestorViewer() {
        return ancestorViewer;
    }

    /**
     * @return the leftViewer
     */
    public MergeContentTreeViewer getLeftViewer() {
        return leftViewer;
    }

    /**
     * @return the rightViewer
     */
    public MergeContentTreeViewer getRightViewer() {
        return rightViewer;
    }

    /**
     * @return the leftRightViewerTitleLabelProvider
     */
    public ICompareInputLabelProvider getLeftRightViewerTitleLabelProvider() {
        return leftRightViewerTitleLabelProvider;
    }

    /**
     * @see org.eclipse.compare.contentmergeviewer.ContentMergeViewer#handleResizeAncestor(int,
     *      int, int, int)
     * 
     * @param x
     * @param y
     * @param width
     * @param height
     */
    @Override
    protected void handleResizeAncestor(int x, int y, int width, int height) {
        Control control = ancestorViewer.getControl();
        if (control != null && !control.isDisposed()) {
            if (width == 0 || height == 0) {
                control.setVisible(false);
            } else {
                control.setBounds(x, y, width, height);
                control.setVisible(true);
            }
        }

        return;
    }

    /**
     * @see org.eclipse.compare.contentmergeviewer.ContentMergeViewer#handleResizeLeftRight(int,
     *      int, int, int, int, int)
     * 
     * @param x
     * @param y
     * @param leftWidth
     * @param centerWidth
     * @param rightWidth
     * @param height
     */
    @Override
    protected void handleResizeLeftRight(int x, int y, int leftWidth,
            int centerWidth, int rightWidth, int height) {

        Control leftControl = leftViewer.getControl();
        if (leftControl != null && !leftControl.isDisposed()) {
            leftControl.setBounds(x, y, leftWidth, height);
        }

        Control centerControl = getCenterControl();
        if (centerControl != null && !centerControl.isDisposed()) {
            centerControl.setBounds(x + leftWidth, y, centerWidth, height);
        }

        Control rightControl = rightViewer.getControl();
        if (rightControl != null && !rightControl.isDisposed()) {
            rightControl.setBounds(x + leftWidth + centerWidth,
                    y,
                    rightWidth,
                    height);
        }

        return;
    }

    /**
     * @see org.eclipse.compare.contentmergeviewer.ContentMergeViewer#updateContent(java.lang.Object,
     *      java.lang.Object, java.lang.Object)
     * 
     * @param ancestor
     * @param left
     * @param right
     */
    @Override
    protected final void updateContent(Object ancestor, Object left,
            Object right) {
        Object input = getInput();

        /*
         * If this node has an ancestor that is atomic then don't drill-down any
         * further (select the atomic ancestor instead)
         */
        if (!alreadyRedirectingToAtomicAncestor) {
            Object parentAtomicNode = redirectToAtomicAncestor(input);

            if (parentAtomicNode != null && parentAtomicNode != input) {
                try {
                    /*
                     * setInput() will probably cause us to recurs into this
                     * method so protect against that.
                     */
                    alreadyRedirectingToAtomicAncestor = true;
                    setInput(parentAtomicNode);

                } finally {
                    alreadyRedirectingToAtomicAncestor = false;

                    /*
                     * When we have re-directed to a parent atomic node then
                     * select the actual element that the user selected in teh
                     * first place (to save them confusion)
                     */
                    initialSelection(ancestor, left, right);
                }
                return;
            }
        }

        /*
         * Store the initial file source input titles
         */
        if (left instanceof IStreamContentAccessor) {
            if (leftRightViewerTitleLabelProvider.getLeftResourceLabel() == null) {
                leftRightViewerTitleLabelProvider
                        .setLeftResourceLabel(getCompareConfiguration()
                                .getLabelProvider().getLeftLabel(input));
            }
        }
        if (right instanceof IStreamContentAccessor) {
            if (leftRightViewerTitleLabelProvider.getRightResourceLabel() == null) {
                leftRightViewerTitleLabelProvider
                        .setRightResourceLabel(getCompareConfiguration()
                                .getLabelProvider().getRightLabel(input));
            }
        }
        if (ancestor instanceof IStreamContentAccessor) {
            if (leftRightViewerTitleLabelProvider.getAncestorResourceLabel() == null) {
                leftRightViewerTitleLabelProvider
                        .setAncestorResourceLabel(getCompareConfiguration()
                                .getLabelProvider().getAncestorLabel(input));
            }
        }

        /*
         * Override the default label provider that is used for images/labels
         * above left/right viewer. Do this each time content is reset because
         * it is stored in a map based on the input DiffNode's hash code which
         * is different when left/right object reset (hecne a copy right to left
         * will mean that compare doesn't have specialised label provider in its
         * map for the same diffNode with different left/right.
         */
        if (input instanceof ICompareInput) {
            getCompareConfiguration().setLabelProvider((ICompareInput) input,
                    leftRightViewerTitleLabelProvider);
        }

        try {
            ancestorViewer.getTree().setRedraw(false);
            leftViewer.getTree().setRedraw(false);
            rightViewer.getTree().setRedraw(false);

            /*
             * Let sub-class do what it needs to do, it can redirect the inputs
             * etc if it wishes.
             */
            doUpdateContent(ancestor, left, right);

            /*
             * Set the difference kind status on the input nodes.
             */
            if (input instanceof ICompareInput && input instanceof IDiffElement) {
                ICompareInput compareInput = (ICompareInput) input;
                IDiffElement diffElement = (IDiffElement) input;

                if (compareInput.getLeft() instanceof XpdCompareNode) {
                    ((XpdCompareNode) compareInput.getLeft())
                            .setProperty(XpdCompareMergeViewer.DIFF_NODE_KIND_PROPERTY,
                                    diffElement.getKind());
                }

                if (compareInput.getRight() instanceof XpdCompareNode) {
                    ((XpdCompareNode) compareInput.getRight())
                            .setProperty(XpdCompareMergeViewer.DIFF_NODE_KIND_PROPERTY,
                                    diffElement.getKind());
                }

                if (compareInput.getAncestor() instanceof XpdCompareNode) {
                    ((XpdCompareNode) compareInput.getAncestor())
                            .setProperty(XpdCompareMergeViewer.DIFF_NODE_KIND_PROPERTY,
                                    diffElement.getKind());
                }
            }

            /*
             * When content input has changed collapse the left and right trees.
             */
            getLeftViewer().collapseAll();
            getRightViewer().collapseAll();

            if (!alreadyRedirectingToAtomicAncestor) {
                /*
                 * No selection if we did not redirect input to an atomic
                 * ancestor.
                 */
                initialSelection(null, null, null);
            }

        } finally {
            ancestorViewer.getTree().setRedraw(true);
            leftViewer.getTree().setRedraw(true);
            rightViewer.getTree().setRedraw(true);

        }

        /* Reset title of compare viewer. */
        if (this.getControl() != null) {
            this.getControl().setData(CompareUI.COMPARE_VIEWER_TITLE,
                    getTitle());
        }

        setupTooltip();

        return;
    }

    /**
     * If there is no content on left or right side then add a helpful tooltip
     * to indicate what's happened so user is not left in the dark.
     */
    private void setupTooltip() {
        String leftTooltip = null;
        String rightTooltip = null;

        if (getInput() instanceof ICompareInput) {
            ICompareInput ci = (ICompareInput) getInput();
            int diffKind = ci.getKind();

            if (diffKind != 0) {
                if (leftViewer.getInput() == null) {
                    leftTooltip =
                            MergeContentViewerUtil.getToolTip(diffKind,
                                    getLeftRightViewerTitleLabelProvider()
                                            .getLeftLabel(ci),
                                    getLeftRightViewerTitleLabelProvider()
                                            .getRightLabel(ci));
                }

                if (rightViewer.getInput() == null) {
                    rightTooltip =
                            MergeContentViewerUtil.getToolTip(diffKind,
                                    getLeftRightViewerTitleLabelProvider()
                                            .getLeftLabel(ci),
                                    getLeftRightViewerTitleLabelProvider()
                                            .getRightLabel(ci));
                }
            }
        }

        leftViewer.getTree().setToolTipText(leftTooltip);
        rightViewer.getTree().setToolTipText(rightTooltip);

        if (rightTooltip != null) {
            mergeViewerCrossoverControl.setDefaultTooltip(rightTooltip);
        } else if (leftTooltip != null) {
            mergeViewerCrossoverControl.setDefaultTooltip(leftTooltip);
        } else {
            mergeViewerCrossoverControl.setDefaultTooltip(null);
        }

        return;
    }

    /**
     * @see org.eclipse.compare.contentmergeviewer.ContentMergeViewer#getTitle()
     * 
     * @return
     */
    @Override
    public String getTitle() {
        Object input = getInput();

        String leftName =
                Messages.XpdCompareNodeContentMergeViewer_NoElement_label;
        String rightName =
                Messages.XpdCompareNodeContentMergeViewer_NoElement_label;

        if (input instanceof ICompareInput) {
            ICompareInput compareInput = (ICompareInput) input;

            /*
             * If we have left content (that may have been merged from right in
             * which case compareInput will equal null BUT left content will be
             * assigned) OR we're at top level then we have a label.
             */
            if (getLeftContent(compareInput) != null
                    || compareInput.getLeft() instanceof IStreamContentAccessor) {
                leftName =
                        leftRightViewerTitleLabelProvider
                                .getLeftLabel(compareInput);
            }

            /* Same for right hand side. */
            if (getRightContent(compareInput) != null
                    || compareInput.getRight() instanceof IStreamContentAccessor) {
                rightName =
                        leftRightViewerTitleLabelProvider
                                .getRightLabel(compareInput);
            }
        }

        String title =
                String
                        .format(Messages.XpdCompareNodeContentMergeViewer_Merge_label,
                                leftName,
                                rightName);

        return title;
    }

    /**
     * Select the given objects (may be null) in the appropriate viewers.
     * 
     * @param ancestor
     * @param left
     * @param right
     */
    protected void initialSelection(Object ancestor, Object left, Object right) {
        ancestorViewer.setSelection(ancestor != null ? new StructuredSelection(
                ancestor) : null, true);
        leftViewer.setSelection(left != null ? new StructuredSelection(left)
                : null, true);
        rightViewer.setSelection(right != null ? new StructuredSelection(right)
                : null, true);
    }

    /**
     * Return the first atomic ancestor (including the input itself) of the
     * given input.
     * 
     * @param input
     * 
     * @return The first atomic ancestor (including input itself) or
     *         <code>null</code> if none found.
     */
    private Object redirectToAtomicAncestor(Object input) {
        while (input != null) {
            if (input instanceof ICompareInput) {
                ICompareInput compareInput = (ICompareInput) input;

                if (compareInput.getLeft() instanceof XpdCompareNode
                        && ((XpdCompareNode) compareInput.getLeft()).isAtomic()) {
                    return input;
                }
                if (compareInput.getRight() instanceof XpdCompareNode
                        && ((XpdCompareNode) compareInput.getRight())
                                .isAtomic()) {
                    return input;
                }
                if (compareInput.getAncestor() instanceof XpdCompareNode
                        && ((XpdCompareNode) compareInput.getAncestor())
                                .isAtomic()) {
                    return input;
                }
            }

            /* Check parent. */
            if (input instanceof IDiffElement) {
                input = ((IDiffElement) input).getParent();
            } else {
                input = null;
            }
        }

        return null;
    }

    /**
     * Called during {@link #updateContent(Object, Object, Object)} this gives
     * the sub-class opportunity to act upon and input chaneg for this viewer.
     * <p>
     * This class will set label providers before and autoExpand after.
     * <p>
     * By default the objects are set directly on the viewers.
     * 
     * @param ancestor
     * @param left
     * @param right
     */
    protected void doUpdateContent(Object ancestor, Object left, Object right) {

        ancestorViewer.setInput(getInput(), ancestor);
        leftViewer.setInput(getInput(), left);
        rightViewer.setInput(getInput(), right);

        return;
    }

    /**
     * Traverse up thru tree of {@link IChildCompareNode}'s until reach the root
     * (any item without a parent or with parent that's not an
     * {@link IChildCompareNode}
     * <p>
     * Note that the root of the tree of which the element is a part <b>is not
     * necessarily</b> the same as the input object of this viewer (which may be
     * showing part of the tree.
     * 
     * @param element
     * @return highest element in tree that is not null or not
     *         {@link IChildCompareNode}
     */
    protected Object getTreeRoot(Object element) {
        while (element instanceof IChildCompareNode) {
            Object parent = ((IChildCompareNode) element).getParent();
            if (parent == null) {
                break;
            }
            element = parent;
        }

        return element;
    }

    /**
     * expose the isThreeWay method
     * 
     * @see org.eclipse.compare.contentmergeviewer.ContentMergeViewer#isThreeWay()
     * 
     * @return
     */
    @Override
    public boolean isThreeWay() {
        return super.isThreeWay();
    }

    /**
     * @see org.eclipse.compare.contentmergeviewer.ContentMergeViewer#getCompareConfiguration()
     * 
     * @return
     */
    @Override
    public CompareConfiguration getCompareConfiguration() {
        return super.getCompareConfiguration();
    }

    /**
     * Prevent copy from left/right unless one side or other is XpdCompareNode.
     * 
     * 
     * @author aallway
     * @since 15 Oct 2010
     */
    private class XpdMergeViewerContentProvider extends
            MergeViewerContentProvider {

        /**
         * @param cc
         */
        public XpdMergeViewerContentProvider(CompareConfiguration cc) {
            super(cc);
        }

        /**
         * @see org.eclipse.compare.internal.MergeViewerContentProvider#isLeftEditable(java.lang.Object)
         * 
         * @param element
         * @return
         */
        @Override
        public boolean isLeftEditable(Object element) {

            Object left =
                    getLeftViewer() != null ? getLeftViewer().getInput() : null;
            Object right =
                    getRightViewer() != null ? getRightViewer().getInput()
                            : null;

            if (left instanceof XpdCompareNode
                    || right instanceof XpdCompareNode) {
                return super.isLeftEditable(element);
            }
            return false;
        }

        /**
         * @see org.eclipse.compare.internal.MergeViewerContentProvider#isRightEditable(java.lang.Object)
         * 
         * @param element
         * @return
         */
        @Override
        public boolean isRightEditable(Object element) {
            if (element instanceof ICompareInput) {
                ITypedElement left = ((ICompareInput) element).getLeft();
                ITypedElement right = ((ICompareInput) element).getRight();

                if (left instanceof XpdCompareNode
                        || right instanceof XpdCompareNode) {
                    return super.isRightEditable(element);
                }
            }
            return false;
        }
    }

}
