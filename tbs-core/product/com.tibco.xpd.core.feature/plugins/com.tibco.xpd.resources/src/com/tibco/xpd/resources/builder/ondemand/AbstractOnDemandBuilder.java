/*
 * Copyright (c) TIBCO Software Inc 2004, 2011. All rights reserved.
 */

package com.tibco.xpd.resources.builder.ondemand;

import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.eclipse.core.resources.IContainer;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.resources.IResourceVisitor;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Status;
import org.eclipse.core.runtime.SubMonitor;

import com.tibco.xpd.resources.XpdResourcesPlugin;
import com.tibco.xpd.resources.internal.Messages;
import com.tibco.xpd.resources.logger.Logger;
import com.tibco.xpd.resources.logger.events.EventProcessor;
import com.tibco.xpd.resources.logger.events.SummaryEventHandler;
import com.tibco.xpd.resources.logger.events.TraceLogEventHandler;
import com.tibco.xpd.resources.logger.events.TraceLogSummaryEventHandler;
import com.tibco.xpd.resources.util.ProjectUtil;
import com.tibco.xpd.resources.util.SubProgressMonitorEx;

/**
 * An abstract class for enabling create on demand build of a particular target
 * type for an entire project.
 * <p>
 * Simply create an instance for a given project and call
 * {@link #buildProject(IProgressMonitor)}
 * <p>
 * This class functions on the premise that the sub-class creates a number of
 * {@link BuildSourceSet}'s (one or more source resources), then provides a
 * {@link BuildTargetSet} (one or more resources expected to be generated from
 * the source set) for each of these.
 * <p>
 * The sub-class is asked to perform a build for a given {@link BuildSourceSet}
 * <b>only</b> if a file in the {@link BuildTargetSet}'s expected resources does
 * not exist or has an earlier timestamp then any file in the source set.
 * <p>
 * After each {@link BuildSourceSet} is built, the resources in the target set
 * are checked for existence (causing a failure if they do not).
 * <p>
 * By default after ALL {@link BuildSourceSet} are built successfully, this
 * class will then removes any unused resources (
 * {@link #removeOldUnusedTargets(Map, IProgressMonitor)}) from the target root
 * folder no longer required (i.e. that is not one of the resources in the
 * latest set of {@link BuildTargetSet}'s. This behaviour is overridable and
 * must be if (a) there is no single root target folder or (b) the target folder
 * a repository for resources other than those generated by this class.
 * 
 * @author aallway
 * @since 14 Dec 2011
 */
public abstract class AbstractOnDemandBuilder {

    private IProject project;

    private EventProcessor traceEventProcessor;

    /**
     * @param project
     *            The project containing resources to be built.
     */
    public AbstractOnDemandBuilder(IProject project) {
        super();
        this.project = project;

        traceEventProcessor =
                new EventProcessor(new TraceLogEventHandler(XpdResourcesPlugin
                        .getDefault().getLogger(), Logger.CATEGORY_BUILD),
                        new TraceLogSummaryEventHandler(XpdResourcesPlugin
                                .getDefault().getLogger(),
                                Logger.CATEGORY_BUILD));

    }

    /**
     * @param project
     *            Nominally the title should contain the project name!
     * 
     * @return The main monitor label for this create on demand builder (for
     *         instance "Creating runtime processes..."
     */
    protected abstract String getMainMonitorLabel(IProject project);

    /**
     * Add the source sets to build to the give list- each source set is built
     * into a target set - this allows for a 1-to-many, many-to-1 or
     * many-to-many source/target relationship.
     * <p>
     * The source set should contain all resources that the target of the build
     * depends upon. This is used to ascertain whether any target is out-of-date
     * with every source so that
     * {@link #buildSourceSet(BuildSourceSet, BuildTargetSet, IProgressMonitor)}
     * will only be called if necessary.
     * 
     * @param project
     * 
     * @return sourceSets sort sets to check and build in the order in this
     *         list.
     * 
     * @throws CoreException
     *             Containing a Status with fault.
     */
    protected abstract List<BuildSourceSet> getBuildSourceSets(IProject project)
            throws CoreException;

    /**
     * Get the target set of <b>expected</b> resources for the given SourceSet.
     * This is used to understand whether the targets are up to date with the
     * sources.
     * <p>
     * Parent folders of target files are not required in this list
     * <b>unless</b> it is necessary to preserve empty folders during the clean
     * up phase (in other words, during clean up of unused targets, any existing
     * folder that does not have a descendant explicitly named in the target set
     * will be removed). If this is not desired then the folders themselves must
     * be listed in the target set.
     * <p>
     * It is also used for cleanup at the end of the build (by default the
     * removeOldTargets() will remove any files/folders in the main target
     * folder that are not listed in the targetSets for all sourceSets.
     * 
     * 
     * @param sourceSet
     * @param monitor
     * 
     * @return The target resource set for the given source set (throws
     *         CoreException if any error is encountered).
     * 
     * @throws CoreException
     *             Containing a Status with fault.
     */
    protected abstract BuildTargetSet getBuildTargetSet(BuildSourceSet sourceSet)
            throws CoreException;

    /**
     * Get the target resources folder (the highest level parent of all files
     * generated by this builder. <b>This is heavily linked to the removal of
     * old unused resources so this should NOT be the source target
     * project!!</b> resources in this target that are not mentioned in any
     * target set for the current source sets may be removed!
     * <p>
     * The default implementation of
     * {@link #removeOldUnusedTargets(Map, IProgressMonitor)} will remove all
     * files beneath this folder that are no longer in the complete set of
     * target resources identified via
     * {@link #getBuildTargetSet(BuildSourceSet)} for every source set returned
     * by {@link #getSourceSets(IProject, List)}
     * 
     * @param project
     * 
     * @return Root folder (or project) of all target resources.
     * 
     * @throws CoreException
     *             Containing a Status with fault.
     */
    protected abstract IContainer getTargetRootFolder(IProject project)
            throws CoreException;

    /**
     * Build the given source set (the target set returned by
     * {@link #getBuildTargetSet(BuildSourceSet)} is passed for convenience
     * <p>
     * Only called if the target set is out of date with the source set.
     * 
     * @param sourceSet
     * @param targetSet
     * @param monitor
     * 
     * @throws CoreException
     *             With status indicating error / cancel.
     */
    protected abstract void buildSourceSet(BuildSourceSet sourceSet,
            BuildTargetSet targetSet, IProgressMonitor monitor)
            throws CoreException;

    /**
     * perform an on-demand build of the given project.
     * 
     * @param monitor
     * @return Status - {@link IStatus#ERROR} on error else {@link IStatus#OK}
     *         on success
     */
    public IStatus buildProject(IProgressMonitor monitor) {

        try {
            beginProjectScopeTraceEvent("buildProject"); //$NON-NLS-1$

            /* Get source sets. */
            Collection<BuildSourceSet> sourceSets = getBuildSourceSets(project);

            monitor = SubMonitor.convert(monitor, getMainMonitorLabel(project), 2);

            /* Buuild target sets for current soruce sets */
            Map<BuildSourceSet, BuildTargetSet> targetSets =
                    internalBuildSourceSets(sourceSets,
                            SubProgressMonitorEx
                                    .createSubTaskProgressMonitor(monitor, 1));

            /* CLeanup old now unused target files */
            removeOldUnusedTargets(targetSets,
                    SubProgressMonitorEx.createSubTaskProgressMonitor(monitor,
                            1));

            return createStatus(IStatus.OK,
                    Messages.AbstractOnDemandBuilder_BuiltOk_message);

        } catch (CoreException e) {
            return e.getStatus();

        } catch (Exception e) {
            return createStatus(IStatus.ERROR,
                    Messages.AbstractOnDemandBuilder_UnexpectedException_message
                            + e.getMessage());

        } finally {
            endProjectScopeTraceEvent("buildProject"); //$NON-NLS-1$
            traceEventProcessor.event(SummaryEventHandler.PRINT_SUMMARY, this
                    .getClass().getName() + ": Build Summary..."); //$NON-NLS-1$
            monitor.done();
        }

    }

    /**
     * @param msg
     * @return Status with given code and Message formatted in a standard way
     *         (with given msg appended.
     */
    protected IStatus createStatus(int statusCode, String msg) {
        return new Status(statusCode, XpdResourcesPlugin.ID_PLUGIN,
                String.format("%1$s: %2$s", getMainMonitorLabel(project), msg)); //$NON-NLS-1$
    }

    /**
     * Build the source sets.
     * 
     * @param sourceSets
     * @param monitor
     * 
     * @return The set of targetSets for the given source set.
     * 
     * @throws CoreException
     *             On error / cancel
     */
    private Map<BuildSourceSet, BuildTargetSet> internalBuildSourceSets(
            Collection<BuildSourceSet> sourceSets, IProgressMonitor monitor)
            throws CoreException {
        try {
            beginProjectScopeTraceEvent("internalBuildSourceSets"); //$NON-NLS-1$

            monitor.beginTask("", sourceSets.size()); //$NON-NLS-1$

            Map<BuildSourceSet, BuildTargetSet> targetSets =
                    new HashMap<BuildSourceSet, BuildTargetSet>();

            for (BuildSourceSet sourceSet : sourceSets) {
                if (monitor.isCanceled()) {
                    throw new CoreException(
                            createStatus(IStatus.CANCEL,
                                    Messages.AbstractOnDemandBuilder_UserCancelled_message));
                }

                BuildTargetSet targetSet =
                        internalBuildSourceSet(sourceSet,
                                SubProgressMonitorEx
                                        .createSubTaskProgressMonitor(monitor,
                                                1));

                targetSets.put(sourceSet, targetSet);

                monitor.worked(1);
                checkCancel(monitor);
            }

            return targetSets;

        } finally {
            endProjectScopeTraceEvent("internalBuildSourceSets"); //$NON-NLS-1$
            monitor.done();
        }
    }

    /**
     * Handle processing of an individual source set.
     * 
     * @param sourceSet
     * @param monitor
     * 
     * @throws CoreException
     *             Containing a Status with fault.
     */
    private BuildTargetSet internalBuildSourceSet(BuildSourceSet sourceSet,
            IProgressMonitor monitor) throws CoreException {
        try {

            beginSourceSetScopeTraceEvent("internalBuildSourceSet", sourceSet); //$NON-NLS-1$

            monitor.beginTask(String
                    .format(Messages.AbstractOnDemandBuilder_BuildingTargets_message,
                            sourceSet.getName()),
                    1);

            /*
             * Complain if all source resources are not present (throws
             * appropriate CoreException if not).
             */
            checkSourceResourcesExist(sourceSet);

            /* Get the set of expected target resources for the source set. */
            BuildTargetSet targetSet = internalGetBuildTargetSet(sourceSet);

            /*
             * If they don't all exist OR any of the targets has an earlier
             * timestamp than all of the sources then we need to rebuild.
             */
            long latestSourceTimeStamp = sourceSet.getLatestTimeStamp();
            long earliestTargetTimeStamp = targetSet.getEarliestTimeStamp();

            if (!targetSet.allTargetsExist()
                    || latestSourceTimeStamp > earliestTargetTimeStamp) {

                logSourceSetScopeTraceEvent("  internalBuildSourceSet", //$NON-NLS-1$
                        sourceSet,
                        String.format("Target set is OUT OF DATE, BUILIDNG... (latestSource=%s  earliestTarget=%s)", //$NON-NLS-1$
                                new Date(latestSourceTimeStamp).toString(),
                                new Date(earliestTargetTimeStamp).toString()));

                /*
                 * Do the build
                 */
                buildSourceSet(sourceSet,
                        targetSet,
                        SubProgressMonitorEx
                                .createSubTaskProgressMonitor(monitor, 1));

                /*
                 * All targets in the target set should now exist.
                 */
                if (!targetSet.allTargetsExist()) {
                    throw new CoreException(
                            createStatus(IStatus.ERROR,
                                    String.format(Messages.AbstractOnDemandBuilder_ExpectedTargetsNotCreated_message,
                                            sourceSet.getName(),
                                            targetSet.getName(),
                                            targetSet.listTargets("\n")))); //$NON-NLS-1$

                } else if (sourceSet.getLatestTimeStamp() > targetSet
                        .getEarliestTimeStamp()) {
                    throw new CoreException(
                            createStatus(IStatus.ERROR,
                                    String.format(Messages.AbstractOnDemandBuilder_ExpectedTargetsNotUpdated_message,
                                            sourceSet.getName(),
                                            targetSet.getName(),
                                            targetSet.listTargets("\n")))); //$NON-NLS-1$
                }
            } else {
                logSourceSetScopeTraceEvent("  internalBuildSourceSet", //$NON-NLS-1$
                        sourceSet,
                        String.format("Target set is UP TO DATE, NOT BUILDING  (latestSource=%s  earliestTarget=%s)", //$NON-NLS-1$
                                new Date(latestSourceTimeStamp).toString(),
                                new Date(earliestTargetTimeStamp).toString()));

                logSourceSetScopeTraceEvent("internalBuildSourceSet", //$NON-NLS-1$
                        sourceSet,
                        "Target set is UP TO DATE, NOT BUILDING."); //$NON-NLS-1$
            }

            monitor.worked(1);
            checkCancel(monitor);

            return targetSet;

        } finally {
            endSourceSetScopeTraceEvent("internalBuildSourceSet", sourceSet); //$NON-NLS-1$
            monitor.done();
        }
    }

    /**
     * Remove any resources from target folder that are no longer used.
     * <p>
     * <b>Note: By default this method assumes that there is a single target
     * folder that contains only resources generated by this builder.</b>
     * <p>
     * After building all source sets, this method deletes any resources that
     * are not explicitly identified in the accumulation of all target resource
     * sets. Any resource beneath the folder returned by
     * {@link #getTargetRootFolder(IProject)} not in this set (or a parent
     * folder of files in the set) will be removed. When a folder is explicitly
     * identified as a build target then its content is ignored and it is the
     * {@link #internalBuildSourceSet(BuildSourceSet, IProgressMonitor)}
     * metrhod's responsibility to ensure that it is cleaned of old artifacts.
     * <p>
     * Therefore if targets are built into a folder hierarchy containing files
     * that must not be cleaned you <b>MUST</b> override
     * {@link #isOkToRemoveResource(IResource)} to prevent removal of resources
     * that do not belong to this builder <b>OTHERWISE</b must override this
     * method and perform its old-target removal.
     * 
     * @param targetSets
     * @param monitor
     * 
     * @throws CoreException
     *             Containing a Status with fault.
     */
    protected void removeOldUnusedTargets(
            Map<BuildSourceSet, BuildTargetSet> targetSets,
            final IProgressMonitor monitor) throws CoreException {
        try {
            beginProjectScopeTraceEvent("removeOldUnusedTargets"); //$NON-NLS-1$

            monitor.beginTask(Messages.AbstractOnDemandBuilder_CleaningUnusedTargets_message,
                    IProgressMonitor.UNKNOWN);

            final IContainer targetRootFolder = getTargetRootFolder(project);

            if (targetRootFolder.exists()) {
                /*
                 * Create a definitive set of all the resources that we expect
                 * to exist according to the existing sourceSets.
                 * 
                 * We will gather folders that have been explicitly identified
                 * as build targets, we will not remove any resources from
                 * these.
                 */
                final Set<IContainer> explictlyNamedTargetContainers =
                        new HashSet<IContainer>();

                final Set<IResource> completeTargetSet =
                        cacheAllExpectedTargetResources(targetSets.values(),
                                targetRootFolder,
                                explictlyNamedTargetContainers);

                final Set<IResource> toRemove = new HashSet<IResource>();

                /*
                 * Visit the targetRootFolder and create set of resources to
                 * remove.
                 */
                targetRootFolder.accept(new IResourceVisitor() {

                    @Override
                    public boolean visit(IResource resource)
                            throws CoreException {
                        if (monitor.isCanceled()) {
                            throw new CoreException(
                                    createStatus(IStatus.CANCEL,
                                            Messages.AbstractOnDemandBuilder_UserCancelledDuringRemove_message));
                        }

                        monitor.worked(1);
                        checkCancel(monitor);

                        /* Make sure not to delete root! */
                        if (!resource.equals(targetRootFolder)) {

                            /*
                             * If this is a folder/project that is explicitly
                             * identified as a build target then it is the not
                             * our responsibility to check for "no longer
                             * required content". Therefore we will simply not
                             * traverse down into it.
                             */
                            if (explictlyNamedTargetContainers
                                    .contains(resource)) {
                                logProjectScopeTraceEvent("  removeOldUnusedTargets", //$NON-NLS-1$
                                        String.format("  Ignoring content explicitly identified target container '%s'", //$NON-NLS-1$
                                                resource.getFullPath()
                                                        .toString()));
                                return false;

                            } else if (!completeTargetSet.contains(resource)) {
                                /*
                                 * If the resource is not in the set of expected
                                 * target resources then we can add it to the to
                                 * be removed list and not bother with any
                                 * descendents.
                                 * 
                                 * But only on final filter confirmation
                                 */
                                if (isOkToRemoveResource(resource)) {
                                    toRemove.add(resource);
                                    return false;
                                }
                            }
                        }

                        /*
                         * If the resource is meant to be there then recurs and
                         * check it's children
                         */
                        return true;
                    }
                });

                /*
                 * Remove the resources.
                 */
                for (IResource resource : toRemove) {
                    if (resource.exists()) {
                        if (monitor.isCanceled()) {
                            throw new CoreException(
                                    createStatus(IStatus.CANCEL,
                                            Messages.AbstractOnDemandBuilder_UserCancelledDuringRemove_message));
                        }

                        logProjectScopeTraceEvent("  removeOldUnusedTargets", //$NON-NLS-1$
                                String.format("  REMOVING resource '%1$s' from target folder as no longer mentioned as expected target in current source sets.", //$NON-NLS-1$
                                        resource.getFullPath().toString()));

                        resource.delete(true,
                                SubMonitor.convert(monitor, "", 1)); //$NON-NLS-1$

                        monitor.worked(1);
                        checkCancel(monitor);
                    }
                }
            }

        } finally {
            endProjectScopeTraceEvent("removeOldUnusedTargets"); //$NON-NLS-1$

            monitor.done();
        }
    }

    /**
     * Validate that it is ok to delete the given resource are part of the
     * {@link #removeOldUnusedTargets(Map, IProgressMonitor)} cycle.
     * 
     * @param resource
     * @return default implementation returns <code>true</code> assuming that
     *         all resources beneath the {@link #getTargetRootFolder(IProject)}
     *         are or were generated vi this builder.
     */
    protected boolean isOkToRemoveResource(IResource resource) {
        return true;
    }

    /**
     * @param targetSets
     * @param targetRootFolder
     * @param explictlyNamedTargetContainers
     *            Collection of containers (folders/projects that explicitly
     *            identified as targets. By explicitly identifying them in this
     *            way the sub-class has said that it handles the clean up of no
     *            longer required files these folders rather than
     *            {@link #removeOldUnusedTargets(Map, IProgressMonitor)}
     * 
     * @return The combination of all expected target resources <b>INCLUDING</b>
     *         the ancestors Folders of all of those resources (between the
     *         target root and the resources)
     */
    private Set<IResource> cacheAllExpectedTargetResources(
            Collection<BuildTargetSet> targetSets, IContainer targetRootFolder,
            Set<IContainer> explictlyNamedTargetContainers) {
        Set<IResource> expectedResources = new HashSet<IResource>();

        for (BuildTargetSet targetSet : targetSets) {

            /*
             * Store the list of folders/projects that are explicitly identified
             * in target sets (rather than included in the complete set because
             * the folder is implicitly required because there is a target file
             * under it.
             */
            for (IResource target : targetSet.getTargetResources()) {
                if (target instanceof IContainer) {
                    IContainer explicitTargetContainer = (IContainer) target;
                    if (!explictlyNamedTargetContainers
                            .contains(explicitTargetContainer)) {
                        explictlyNamedTargetContainers
                                .add(explicitTargetContainer);
                    }
                }
            }

            /*
             * Then go thru again and store all the explicitly named
             * files/folders AND their implicit parent folders (between them and
             * the root target folder.
             */

            for (IResource target : targetSet.getTargetResources()) {

                while (target != null && !target.equals(targetRootFolder)) {
                    if (!expectedResources.contains(target)) {
                        expectedResources.add(target);
                    }

                    target = target.getParent();
                }
            }
        }

        return expectedResources;
    }

    /**
     * Get the BuildTargetSet for the given source set.
     * 
     * @param sourceSet
     * @return
     * @throws CoreException
     */
    private BuildTargetSet internalGetBuildTargetSet(BuildSourceSet sourceSet)
            throws CoreException {
        BuildTargetSet targetSet = getBuildTargetSet(sourceSet);

        logTargetSetScopeTraceEvent("internalGetBuildTargetSet", //$NON-NLS-1$
                targetSet,
                "Expected Targets: \n  " + targetSet.listTargets("\n  ")); //$NON-NLS-1$//$NON-NLS-2$

        return targetSet;
    }

    /**
     * Throw CoreException if all source resources are not present.
     * 
     * @param sourceSet
     * @throws CoreException
     */
    private void checkSourceResourcesExist(BuildSourceSet sourceSet)
            throws CoreException {
        boolean allExist = true;

        StringBuilder sb = null;

        for (IResource sourceResource : sourceSet.getSourceResources()) {
            if (!sourceResource.exists()) {
                allExist = false;

                if (sb == null) {
                    sb = new StringBuilder();
                    sb.append(String
                            .format(Messages.AbstractOnDemandBuilder_MessinSource_message,
                                    sourceSet.getName()));
                }

                sb.append("\n  "); //$NON-NLS-1$
                sb.append(", " + sourceResource.getFullPath().toString()); //$NON-NLS-1$
            }
        }

        if (!allExist) {
            throw new CoreException(createStatus(IStatus.ERROR, sb.toString()));
        } else {
            logSourceSetScopeTraceEvent("checkSourceResourcesExist", //$NON-NLS-1$
                    sourceSet,
                    "Content: \n  " + sourceSet.listSources("\n  ")); //$NON-NLS-1$ //$NON-NLS-2$
        }

    }

    /**
     * @param traceObject
     * @param message
     * @return
     */
    private static String getTraceMessage(Object traceObject, String message) {
        return String.format("[T=%d]%s(%s): %s", //$NON-NLS-1$
                Thread.currentThread().getId(),
                traceObject.getClass().getSimpleName(),
                traceObject.hashCode(),
                message);
    }

    protected void beginProjectScopeTraceEvent(String scopeName) {
        traceEventProcessor.begin(this.getClass().getSimpleName(),
                project.getName(),
                scopeName);
    }

    protected void endProjectScopeTraceEvent(String scopeName) {
        traceEventProcessor.end(this.getClass().getSimpleName(),
                project.getName(),
                scopeName);
    }

    protected void beginSourceSetScopeTraceEvent(String scopeName,
            BuildSourceSet sourceSet) {
        traceEventProcessor.begin(this.getClass().getSimpleName(),
                project.getName(),
                scopeName,
                sourceSet.getName());
    }

    protected void endSourceSetScopeTraceEvent(String scopeName,
            BuildSourceSet sourceSet) {
        traceEventProcessor.end(this.getClass().getSimpleName(),
                project.getName(),
                scopeName,
                sourceSet.getName());
    }

    protected void logProjectScopeTraceEvent(String scopeName, String message) {
        traceEventProcessor.begin(this.getClass().getSimpleName(),
                project.getName(),
                scopeName,
                message);
    }

    protected void logSourceSetScopeTraceEvent(String scopeName,
            BuildSourceSet sourceSet, String message) {
        traceEventProcessor.begin(this.getClass().getSimpleName(),
                project.getName(),
                scopeName,
                sourceSet.getName(),
                message);
    }

    protected void logTargetSetScopeTraceEvent(String scopeName,
            BuildTargetSet targetSet, String message) {
        traceEventProcessor.begin(this.getClass().getSimpleName(),
                project.getName(),
                scopeName,
                targetSet.getName(),
                message);
    }

    /**
     * Cancel current processing.
     * 
     * @param monitor
     *            Progress monitor
     */
    protected void checkCancel(IProgressMonitor monitor) {
        ProjectUtil.checkBuildCancel(monitor, null);
    }

}
